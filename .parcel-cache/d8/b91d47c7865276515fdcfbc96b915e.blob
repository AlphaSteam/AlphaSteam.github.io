// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, cache, entry, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject.parcelRequire === 'function' &&
    globalObject.parcelRequire;
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  globalObject.parcelRequire = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"8c5b5622742e8e98989ec4c3a2f890b3":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_ENV_HASH = "d751713988987e9331980363e24189ce";
module.bundle.HMR_BUNDLE_ID = "0e8c7faf4a017ca71fe3d26b611d7ec1";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH */

var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept, acceptedAssets; // eslint-disable-next-line no-redeclare

var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
  var port = HMR_PORT || location.port;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    acceptedAssets = {};
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      // Remove error overlay if there is one
      removeErrorOverlay();
      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH); // Handle HMR Update

      var handled = false;
      assets.forEach(asset => {
        var didAccept = asset.type === 'css' || hmrAcceptCheck(global.parcelRequire, asset.id);

        if (didAccept) {
          handled = true;
        }
      });

      if (handled) {
        console.clear();
        assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });

        for (var i = 0; i < assetsToAccept.length; i++) {
          var id = assetsToAccept[i][1];

          if (!acceptedAssets[id]) {
            hmrAcceptRun(assetsToAccept[i][0], id);
          }
        }
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'error') {
      // Log parcel errors to console
      for (let ansiDiagnostic of data.diagnostics.ansi) {
        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
        console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
      } // Render the fancy html overlay


      removeErrorOverlay();
      var overlay = createErrorOverlay(data.diagnostics.html);
      document.body.appendChild(overlay);
    }
  };

  ws.onerror = function (e) {
    console.error(e.message);
  };

  ws.onclose = function (e) {
    console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
    console.log('[parcel] âœ¨ Error resolved');
  }
}

function createErrorOverlay(diagnostics) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;
  let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';

  for (let diagnostic of diagnostics) {
    let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
    errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          ðŸš¨ ${diagnostic.message}
        </div>
        <pre>
          ${stack}
        </pre>
        <div>
          ${diagnostic.hints.map(hint => '<div>' + hint + '</div>').join('')}
        </div>
      </div>
    `;
  }

  errorHTML += '</div>';
  overlay.innerHTML = errorHTML;
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push([bundle, k]);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    if (link.parentNode !== null) {
      link.parentNode.removeChild(link);
    }
  };

  newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now());
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      var absolute = /^https?:\/\//i.test(links[i].getAttribute('href'));

      if (!absolute) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    if (asset.type === 'css') {
      reloadCSS();
    } else {
      var fn = new Function('require', 'module', 'exports', asset.output);
      modules[asset.id] = [fn, asset.depsByBundle[bundle.HMR_BUNDLE_ID]];
    }
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (v) {
    return hmrAcceptCheck(v[0], v[1]);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached && cached.hot) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      var assetsToAlsoAccept = cb(function () {
        return getParents(global.parcelRequire, id);
      });

      if (assetsToAlsoAccept && assetsToAccept.length) {
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
      }
    });
  }

  acceptedAssets[id] = true;
}
},{}],"73e588dc321745e8ecbe86c06ea14bd1":[function(require,module,exports) {
void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) {
  return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
}), void 0 === Math.sign && (Math.sign = function (t) {
  return t < 0 ? -1 : t > 0 ? 1 : +t;
}), "name" in Function.prototype == 0 && Object.defineProperty(Function.prototype, "name", {
  get: function () {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  }
}), void 0 === Object.assign && (Object.assign = function (t) {
  if (null == t) throw new TypeError("Cannot convert undefined or null to object");
  const e = Object(t);

  for (let t = 1; t < arguments.length; t++) {
    const n = arguments[t];
    if (null != n) for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
  }

  return e;
});

function t() {}

Object.assign(t.prototype, {
  addEventListener: function (t, e) {
    void 0 === this._listeners && (this._listeners = {});
    const n = this._listeners;
    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
  },
  hasEventListener: function (t, e) {
    if (void 0 === this._listeners) return !1;
    const n = this._listeners;
    return void 0 !== n[t] && -1 !== n[t].indexOf(e);
  },
  removeEventListener: function (t, e) {
    if (void 0 === this._listeners) return;
    const n = this._listeners[t];

    if (void 0 !== n) {
      const t = n.indexOf(e);
      -1 !== t && n.splice(t, 1);
    }
  },
  dispatchEvent: function (t) {
    if (void 0 === this._listeners) return;
    const e = this._listeners[t.type];

    if (void 0 !== e) {
      t.target = this;
      const n = e.slice(0);

      for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
    }
  }
});
const e = [];

for (let t = 0; t < 256; t++) e[t] = (t < 16 ? "0" : "") + t.toString(16);

const n = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    const t = 4294967295 * Math.random() | 0,
          n = 4294967295 * Math.random() | 0,
          i = 4294967295 * Math.random() | 0,
          r = 4294967295 * Math.random() | 0;
    return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & n] + e[n >> 8 & 255] + "-" + e[n >> 16 & 15 | 64] + e[n >> 24 & 255] + "-" + e[63 & i | 128] + e[i >> 8 & 255] + "-" + e[i >> 16 & 255] + e[i >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]).toUpperCase();
  },
  clamp: function (t, e, n) {
    return Math.max(e, Math.min(n, t));
  },
  euclideanModulo: function (t, e) {
    return (t % e + e) % e;
  },
  mapLinear: function (t, e, n, i, r) {
    return i + (t - e) * (r - i) / (n - e);
  },
  lerp: function (t, e, n) {
    return (1 - n) * t + n * e;
  },
  smoothstep: function (t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
  },
  smootherstep: function (t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
  },
  randInt: function (t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  randFloat: function (t, e) {
    return t + Math.random() * (e - t);
  },
  randFloatSpread: function (t) {
    return t * (.5 - Math.random());
  },
  degToRad: function (t) {
    return t * n.DEG2RAD;
  },
  radToDeg: function (t) {
    return t * n.RAD2DEG;
  },
  isPowerOfTwo: function (t) {
    return 0 == (t & t - 1) && 0 !== t;
  },
  ceilPowerOfTwo: function (t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  },
  floorPowerOfTwo: function (t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  },
  setQuaternionFromProperEuler: function (t, e, n, i, r) {
    const o = Math.cos,
          s = Math.sin,
          a = o(n / 2),
          c = s(n / 2),
          l = o((e + i) / 2),
          u = s((e + i) / 2),
          h = o((e - i) / 2),
          d = s((e - i) / 2),
          p = o((i - e) / 2),
          f = s((i - e) / 2);

    switch (r) {
      case "XYX":
        t.set(a * u, c * h, c * d, a * l);
        break;

      case "YZY":
        t.set(c * d, a * u, c * h, a * l);
        break;

      case "ZXZ":
        t.set(c * h, c * d, a * u, a * l);
        break;

      case "XZX":
        t.set(a * u, c * f, c * p, a * l);
        break;

      case "YXY":
        t.set(c * p, a * u, c * f, a * l);
        break;

      case "ZYZ":
        t.set(c * f, c * p, a * u, a * l);
        break;

      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
    }
  }
};

function i(t = 0, e = 0) {
  this.x = t, this.y = e;
}

function r() {
  this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}

let o;
Object.defineProperties(i.prototype, {
  width: {
    get: function () {
      return this.x;
    },
    set: function (t) {
      this.x = t;
    }
  },
  height: {
    get: function () {
      return this.y;
    },
    set: function (t) {
      this.y = t;
    }
  }
}), Object.assign(i.prototype, {
  isVector2: !0,
  set: function (t, e) {
    return this.x = t, this.y = e, this;
  },
  setScalar: function (t) {
    return this.x = t, this.y = t, this;
  },
  setX: function (t) {
    return this.x = t, this;
  },
  setY: function (t) {
    return this.y = t, this;
  },
  setComponent: function (t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;

      case 1:
        this.y = e;
        break;

      default:
        throw new Error("index is out of range: " + t);
    }

    return this;
  },
  getComponent: function (t) {
    switch (t) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y);
  },
  copy: function (t) {
    return this.x = t.x, this.y = t.y, this;
  },
  add: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
  },
  addScalar: function (t) {
    return this.x += t, this.y += t, this;
  },
  addVectors: function (t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  },
  addScaledVector: function (t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  },
  sub: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
  },
  subScalar: function (t) {
    return this.x -= t, this.y -= t, this;
  },
  subVectors: function (t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  },
  multiply: function (t) {
    return this.x *= t.x, this.y *= t.y, this;
  },
  multiplyScalar: function (t) {
    return this.x *= t, this.y *= t, this;
  },
  divide: function (t) {
    return this.x /= t.x, this.y /= t.y, this;
  },
  divideScalar: function (t) {
    return this.multiplyScalar(1 / t);
  },
  applyMatrix3: function (t) {
    const e = this.x,
          n = this.y,
          i = t.elements;
    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this;
  },
  min: function (t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  },
  max: function (t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  },
  clamp: function (t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  },
  clampScalar: function (t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  },
  clampLength: function (t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  },
  floor: function () {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  },
  ceil: function () {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  },
  round: function () {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  },
  roundToZero: function () {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  },
  negate: function () {
    return this.x = -this.x, this.y = -this.y, this;
  },
  dot: function (t) {
    return this.x * t.x + this.y * t.y;
  },
  cross: function (t) {
    return this.x * t.y - this.y * t.x;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  angle: function () {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  },
  distanceTo: function (t) {
    return Math.sqrt(this.distanceToSquared(t));
  },
  distanceToSquared: function (t) {
    const e = this.x - t.x,
          n = this.y - t.y;
    return e * e + n * n;
  },
  manhattanDistanceTo: function (t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  },
  setLength: function (t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function (t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  },
  lerpVectors: function (t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
  },
  equals: function (t) {
    return t.x === this.x && t.y === this.y;
  },
  fromArray: function (t, e) {
    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this;
  },
  toArray: function (t, e) {
    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t;
  },
  fromBufferAttribute: function (t, e, n) {
    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this;
  },
  rotateAround: function (t, e) {
    const n = Math.cos(e),
          i = Math.sin(e),
          r = this.x - t.x,
          o = this.y - t.y;
    return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this;
  },
  random: function () {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
}), Object.assign(r.prototype, {
  isMatrix3: !0,
  set: function (t, e, n, i, r, o, s, a, c) {
    const l = this.elements;
    return l[0] = t, l[1] = i, l[2] = s, l[3] = e, l[4] = r, l[5] = a, l[6] = n, l[7] = o, l[8] = c, this;
  },
  identity: function () {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  },
  clone: function () {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function (t) {
    const e = this.elements,
          n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
  },
  extractBasis: function (t, e, n) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  },
  setFromMatrix4: function (t) {
    const e = t.elements;
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
  },
  multiply: function (t) {
    return this.multiplyMatrices(this, t);
  },
  premultiply: function (t) {
    return this.multiplyMatrices(t, this);
  },
  multiplyMatrices: function (t, e) {
    const n = t.elements,
          i = e.elements,
          r = this.elements,
          o = n[0],
          s = n[3],
          a = n[6],
          c = n[1],
          l = n[4],
          u = n[7],
          h = n[2],
          d = n[5],
          p = n[8],
          f = i[0],
          m = i[3],
          g = i[6],
          v = i[1],
          y = i[4],
          x = i[7],
          _ = i[2],
          b = i[5],
          w = i[8];
    return r[0] = o * f + s * v + a * _, r[3] = o * m + s * y + a * b, r[6] = o * g + s * x + a * w, r[1] = c * f + l * v + u * _, r[4] = c * m + l * y + u * b, r[7] = c * g + l * x + u * w, r[2] = h * f + d * v + p * _, r[5] = h * m + d * y + p * b, r[8] = h * g + d * x + p * w, this;
  },
  multiplyScalar: function (t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  },
  determinant: function () {
    const t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          o = t[4],
          s = t[5],
          a = t[6],
          c = t[7],
          l = t[8];
    return e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a;
  },
  getInverse: function (t, e) {
    void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
    const n = t.elements,
          i = this.elements,
          r = n[0],
          o = n[1],
          s = n[2],
          a = n[3],
          c = n[4],
          l = n[5],
          u = n[6],
          h = n[7],
          d = n[8],
          p = d * c - l * h,
          f = l * u - d * a,
          m = h * a - c * u,
          g = r * p + o * f + s * m;
    if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / g;
    return i[0] = p * v, i[1] = (s * h - d * o) * v, i[2] = (l * o - s * c) * v, i[3] = f * v, i[4] = (d * r - s * u) * v, i[5] = (s * a - l * r) * v, i[6] = m * v, i[7] = (o * u - h * r) * v, i[8] = (c * r - o * a) * v, this;
  },
  transpose: function () {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  },
  getNormalMatrix: function (t) {
    return this.setFromMatrix4(t).getInverse(this).transpose();
  },
  transposeIntoArray: function (t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  },
  setUvTransform: function (t, e, n, i, r, o, s) {
    const a = Math.cos(r),
          c = Math.sin(r);
    this.set(n * a, n * c, -n * (a * o + c * s) + o + t, -i * c, i * a, -i * (-c * o + a * s) + s + e, 0, 0, 1);
  },
  scale: function (t, e) {
    const n = this.elements;
    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this;
  },
  rotate: function (t) {
    const e = Math.cos(t),
          n = Math.sin(t),
          i = this.elements,
          r = i[0],
          o = i[3],
          s = i[6],
          a = i[1],
          c = i[4],
          l = i[7];
    return i[0] = e * r + n * a, i[3] = e * o + n * c, i[6] = e * s + n * l, i[1] = -n * r + e * a, i[4] = -n * o + e * c, i[7] = -n * s + e * l, this;
  },
  translate: function (t, e) {
    const n = this.elements;
    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this;
  },
  equals: function (t) {
    const e = this.elements,
          n = t.elements;

    for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;

    return !0;
  },
  fromArray: function (t, e) {
    void 0 === e && (e = 0);

    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];

    return this;
  },
  toArray: function (t, e) {
    void 0 === t && (t = []), void 0 === e && (e = 0);
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
  }
});
const s = {
  getDataURL: function (t) {
    if (/^data:/i.test(t.src)) return t.src;
    if ("undefined" == typeof HTMLCanvasElement) return t.src;
    let e;
    if (t instanceof HTMLCanvasElement) e = t;else {
      void 0 === o && (o = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), o.width = t.width, o.height = t.height;
      const n = o.getContext("2d");
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = o;
    }
    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png");
  }
};
let a = 0;

function c(t, e, o, s, l, u, h, d, p, f) {
  Object.defineProperty(this, "id", {
    value: a++
  }), this.uuid = n.generateUUID(), this.name = "", this.image = void 0 !== t ? t : c.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : c.DEFAULT_MAPPING, this.wrapS = void 0 !== o ? o : 1001, this.wrapT = void 0 !== s ? s : 1001, this.magFilter = void 0 !== l ? l : 1006, this.minFilter = void 0 !== u ? u : 1008, this.anisotropy = void 0 !== p ? p : 1, this.format = void 0 !== h ? h : 1023, this.internalFormat = null, this.type = void 0 !== d ? d : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new r(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== f ? f : 3e3, this.version = 0, this.onUpdate = null;
}

function l(t = 0, e = 0, n = 0, i = 1) {
  this.x = t, this.y = e, this.z = n, this.w = i;
}

function u(t, e, n) {
  this.width = t, this.height = e, this.scissor = new l(0, 0, t, e), this.scissorTest = !1, this.viewport = new l(0, 0, t, e), n = n || {}, this.texture = new c(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null;
}

function h(t, e, n) {
  u.call(this, t, e, n), this.samples = 4;
}

function d(t = 0, e = 0, n = 0, i = 1) {
  this._x = t, this._y = e, this._z = n, this._w = i;
}

c.DEFAULT_IMAGE = void 0, c.DEFAULT_MAPPING = 300, c.prototype = Object.assign(Object.create(t.prototype), {
  constructor: c,
  isTexture: !0,
  updateMatrix: function () {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this;
  },
  toJSON: function (t) {
    const e = void 0 === t || "string" == typeof t;
    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };

    if (void 0 !== this.image) {
      const r = this.image;

      if (void 0 === r.uuid && (r.uuid = n.generateUUID()), !e && void 0 === t.images[r.uuid]) {
        let e;

        if (Array.isArray(r)) {
          e = [];

          for (let t = 0, n = r.length; t < n; t++) e.push(s.getDataURL(r[t]));
        } else e = s.getDataURL(r);

        t.images[r.uuid] = {
          uuid: r.uuid,
          url: e
        };
      }

      i.image = r.uuid;
    }

    return e || (t.textures[this.uuid] = i), i;
  },
  dispose: function () {
    this.dispatchEvent({
      type: "dispose"
    });
  },
  transformUv: function (t) {
    if (300 !== this.mapping) return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
      case 1e3:
        t.x = t.x - Math.floor(t.x);
        break;

      case 1001:
        t.x = t.x < 0 ? 0 : 1;
        break;

      case 1002:
        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
    }
    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
      case 1e3:
        t.y = t.y - Math.floor(t.y);
        break;

      case 1001:
        t.y = t.y < 0 ? 0 : 1;
        break;

      case 1002:
        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
    }
    return this.flipY && (t.y = 1 - t.y), t;
  }
}), Object.defineProperty(c.prototype, "needsUpdate", {
  set: function (t) {
    !0 === t && this.version++;
  }
}), Object.defineProperties(l.prototype, {
  width: {
    get: function () {
      return this.z;
    },
    set: function (t) {
      this.z = t;
    }
  },
  height: {
    get: function () {
      return this.w;
    },
    set: function (t) {
      this.w = t;
    }
  }
}), Object.assign(l.prototype, {
  isVector4: !0,
  set: function (t, e, n, i) {
    return this.x = t, this.y = e, this.z = n, this.w = i, this;
  },
  setScalar: function (t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  },
  setX: function (t) {
    return this.x = t, this;
  },
  setY: function (t) {
    return this.y = t, this;
  },
  setZ: function (t) {
    return this.z = t, this;
  },
  setW: function (t) {
    return this.w = t, this;
  },
  setComponent: function (t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;

      case 1:
        this.y = e;
        break;

      case 2:
        this.z = e;
        break;

      case 3:
        this.w = e;
        break;

      default:
        throw new Error("index is out of range: " + t);
    }

    return this;
  },
  getComponent: function (t) {
    switch (t) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      case 3:
        return this.w;

      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function (t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this;
  },
  add: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
  },
  addScalar: function (t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  },
  addVectors: function (t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  },
  addScaledVector: function (t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  },
  sub: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
  },
  subScalar: function (t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  },
  subVectors: function (t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  },
  multiplyScalar: function (t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  },
  applyMatrix4: function (t) {
    const e = this.x,
          n = this.y,
          i = this.z,
          r = this.w,
          o = t.elements;
    return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this;
  },
  divideScalar: function (t) {
    return this.multiplyScalar(1 / t);
  },
  setAxisAngleFromQuaternion: function (t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  },
  setAxisAngleFromRotationMatrix: function (t) {
    let e, n, i, r;
    const o = t.elements,
          s = o[0],
          a = o[4],
          c = o[8],
          l = o[1],
          u = o[5],
          h = o[9],
          d = o[2],
          p = o[6],
          f = o[10];

    if (Math.abs(a - l) < .01 && Math.abs(c - d) < .01 && Math.abs(h - p) < .01) {
      if (Math.abs(a + l) < .1 && Math.abs(c + d) < .1 && Math.abs(h + p) < .1 && Math.abs(s + u + f - 3) < .1) return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const t = (s + 1) / 2,
            o = (u + 1) / 2,
            m = (f + 1) / 2,
            g = (a + l) / 4,
            v = (c + d) / 4,
            y = (h + p) / 4;
      return t > o && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = g / n, r = v / n) : o > m ? o < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = g / i, r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(m), n = v / r, i = y / r), this.set(n, i, r, e), this;
    }

    let m = Math.sqrt((p - h) * (p - h) + (c - d) * (c - d) + (l - a) * (l - a));
    return Math.abs(m) < .001 && (m = 1), this.x = (p - h) / m, this.y = (c - d) / m, this.z = (l - a) / m, this.w = Math.acos((s + u + f - 1) / 2), this;
  },
  min: function (t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  },
  max: function (t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  },
  clamp: function (t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  },
  clampScalar: function (t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  },
  clampLength: function (t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  },
  floor: function () {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  },
  ceil: function () {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  },
  round: function () {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  },
  roundToZero: function () {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  },
  negate: function () {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  },
  dot: function (t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function (t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  },
  lerpVectors: function (t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
  },
  equals: function (t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  },
  fromArray: function (t, e) {
    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  },
  toArray: function (t, e) {
    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  },
  fromBufferAttribute: function (t, e, n) {
    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  },
  random: function () {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
}), u.prototype = Object.assign(Object.create(t.prototype), {
  constructor: u,
  isWebGLRenderTarget: !0,
  setSize: function (t, e) {
    this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: "dispose"
    });
  }
}), h.prototype = Object.assign(Object.create(u.prototype), {
  constructor: h,
  isWebGLMultisampleRenderTarget: !0,
  copy: function (t) {
    return u.prototype.copy.call(this, t), this.samples = t.samples, this;
  }
}), Object.assign(d, {
  slerp: function (t, e, n, i) {
    return n.copy(t).slerp(e, i);
  },
  slerpFlat: function (t, e, n, i, r, o, s) {
    let a = n[i + 0],
        c = n[i + 1],
        l = n[i + 2],
        u = n[i + 3];
    const h = r[o + 0],
          d = r[o + 1],
          p = r[o + 2],
          f = r[o + 3];

    if (u !== f || a !== h || c !== d || l !== p) {
      let t = 1 - s,
          e = a * h + c * d + l * p + u * f,
          n = e >= 0 ? 1 : -1,
          i = 1 - e * e;

      if (i > Number.EPSILON) {
        const r = Math.sqrt(i),
              o = Math.atan2(r, e * n);
        t = Math.sin(t * o) / r, s = Math.sin(s * o) / r;
      }

      const r = s * n;

      if (a = a * t + h * r, c = c * t + d * r, l = l * t + p * r, u = u * t + f * r, t === 1 - s) {
        const t = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
        a *= t, c *= t, l *= t, u *= t;
      }
    }

    t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u;
  },
  multiplyQuaternionsFlat: function (t, e, n, i, r, o) {
    const s = n[i],
          a = n[i + 1],
          c = n[i + 2],
          l = n[i + 3],
          u = r[o],
          h = r[o + 1],
          d = r[o + 2],
          p = r[o + 3];
    return t[e] = s * p + l * u + a * d - c * h, t[e + 1] = a * p + l * h + c * u - s * d, t[e + 2] = c * p + l * d + s * h - a * u, t[e + 3] = l * p - s * u - a * h - c * d, t;
  }
}), Object.defineProperties(d.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (t) {
      this._x = t, this._onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (t) {
      this._y = t, this._onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (t) {
      this._z = t, this._onChangeCallback();
    }
  },
  w: {
    get: function () {
      return this._w;
    },
    set: function (t) {
      this._w = t, this._onChangeCallback();
    }
  }
}), Object.assign(d.prototype, {
  isQuaternion: !0,
  set: function (t, e, n, i) {
    return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function (t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  },
  setFromEuler: function (t, e) {
    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const n = t._x,
          i = t._y,
          r = t._z,
          o = t.order,
          s = Math.cos,
          a = Math.sin,
          c = s(n / 2),
          l = s(i / 2),
          u = s(r / 2),
          h = a(n / 2),
          d = a(i / 2),
          p = a(r / 2);

    switch (o) {
      case "XYZ":
        this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;
        break;

      case "YXZ":
        this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;
        break;

      case "ZXY":
        this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;
        break;

      case "ZYX":
        this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;
        break;

      case "YZX":
        this._x = h * l * u + c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u - h * d * p;
        break;

      case "XZY":
        this._x = h * l * u - c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u + h * d * p;
        break;

      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }

    return !1 !== e && this._onChangeCallback(), this;
  },
  setFromAxisAngle: function (t, e) {
    const n = e / 2,
          i = Math.sin(n);
    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  },
  setFromRotationMatrix: function (t) {
    const e = t.elements,
          n = e[0],
          i = e[4],
          r = e[8],
          o = e[1],
          s = e[5],
          a = e[9],
          c = e[2],
          l = e[6],
          u = e[10],
          h = n + s + u;

    if (h > 0) {
      const t = .5 / Math.sqrt(h + 1);
      this._w = .25 / t, this._x = (l - a) * t, this._y = (r - c) * t, this._z = (o - i) * t;
    } else if (n > s && n > u) {
      const t = 2 * Math.sqrt(1 + n - s - u);
      this._w = (l - a) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (r + c) / t;
    } else if (s > u) {
      const t = 2 * Math.sqrt(1 + s - n - u);
      this._w = (r - c) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (a + l) / t;
    } else {
      const t = 2 * Math.sqrt(1 + u - n - s);
      this._w = (o - i) / t, this._x = (r + c) / t, this._y = (a + l) / t, this._z = .25 * t;
    }

    return this._onChangeCallback(), this;
  },
  setFromUnitVectors: function (t, e) {
    let n = t.dot(e) + 1;
    return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
  },
  angleTo: function (t) {
    return 2 * Math.acos(Math.abs(n.clamp(this.dot(t), -1, 1)));
  },
  rotateTowards: function (t, e) {
    const n = this.angleTo(t);
    if (0 === n) return this;
    const i = Math.min(1, e / n);
    return this.slerp(t, i), this;
  },
  inverse: function () {
    return this.conjugate();
  },
  conjugate: function () {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  },
  dot: function (t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    let t = this.length();
    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  },
  multiply: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
  },
  premultiply: function (t) {
    return this.multiplyQuaternions(t, this);
  },
  multiplyQuaternions: function (t, e) {
    const n = t._x,
          i = t._y,
          r = t._z,
          o = t._w,
          s = e._x,
          a = e._y,
          c = e._z,
          l = e._w;
    return this._x = n * l + o * s + i * c - r * a, this._y = i * l + o * a + r * s - n * c, this._z = r * l + o * c + n * a - i * s, this._w = o * l - n * s - i * a - r * c, this._onChangeCallback(), this;
  },
  slerp: function (t, e) {
    if (0 === e) return this;
    if (1 === e) return this.copy(t);
    const n = this._x,
          i = this._y,
          r = this._z,
          o = this._w;
    let s = o * t._w + n * t._x + i * t._y + r * t._z;
    if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
    const a = 1 - s * s;

    if (a <= Number.EPSILON) {
      const t = 1 - e;
      return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this;
    }

    const c = Math.sqrt(a),
          l = Math.atan2(c, s),
          u = Math.sin((1 - e) * l) / c,
          h = Math.sin(e * l) / c;
    return this._w = o * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this;
  },
  equals: function (t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  },
  fromArray: function (t, e) {
    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  },
  toArray: function (t, e) {
    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  },
  fromBufferAttribute: function (t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
  },
  _onChange: function (t) {
    return this._onChangeCallback = t, this;
  },
  _onChangeCallback: function () {}
});
const p = new m(),
      f = new d();

function m(t = 0, e = 0, n = 0) {
  this.x = t, this.y = e, this.z = n;
}

Object.assign(m.prototype, {
  isVector3: !0,
  set: function (t, e, n) {
    return this.x = t, this.y = e, this.z = n, this;
  },
  setScalar: function (t) {
    return this.x = t, this.y = t, this.z = t, this;
  },
  setX: function (t) {
    return this.x = t, this;
  },
  setY: function (t) {
    return this.y = t, this;
  },
  setZ: function (t) {
    return this.z = t, this;
  },
  setComponent: function (t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;

      case 1:
        this.y = e;
        break;

      case 2:
        this.z = e;
        break;

      default:
        throw new Error("index is out of range: " + t);
    }

    return this;
  },
  getComponent: function (t) {
    switch (t) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error("index is out of range: " + t);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function (t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  },
  add: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
  },
  addScalar: function (t) {
    return this.x += t, this.y += t, this.z += t, this;
  },
  addVectors: function (t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  },
  addScaledVector: function (t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  },
  sub: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
  },
  subScalar: function (t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  },
  subVectors: function (t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  },
  multiply: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
  },
  multiplyScalar: function (t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  },
  multiplyVectors: function (t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  },
  applyEuler: function (t) {
    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(f.setFromEuler(t));
  },
  applyAxisAngle: function (t, e) {
    return this.applyQuaternion(f.setFromAxisAngle(t, e));
  },
  applyMatrix3: function (t) {
    const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
    return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this;
  },
  applyNormalMatrix: function (t) {
    return this.applyMatrix3(t).normalize();
  },
  applyMatrix4: function (t) {
    const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements,
          o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
    return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this;
  },
  applyQuaternion: function (t) {
    const e = this.x,
          n = this.y,
          i = this.z,
          r = t.x,
          o = t.y,
          s = t.z,
          a = t.w,
          c = a * e + o * i - s * n,
          l = a * n + s * e - r * i,
          u = a * i + r * n - o * e,
          h = -r * e - o * n - s * i;
    return this.x = c * a + h * -r + l * -s - u * -o, this.y = l * a + h * -o + u * -r - c * -s, this.z = u * a + h * -s + c * -o - l * -r, this;
  },
  project: function (t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  },
  unproject: function (t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  },
  transformDirection: function (t) {
    const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
    return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize();
  },
  divide: function (t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  },
  divideScalar: function (t) {
    return this.multiplyScalar(1 / t);
  },
  min: function (t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  },
  max: function (t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  },
  clamp: function (t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  },
  clampScalar: function (t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  },
  clampLength: function (t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  },
  floor: function () {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  },
  ceil: function () {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  },
  round: function () {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  },
  roundToZero: function () {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  },
  negate: function () {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  },
  dot: function (t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (t) {
    return this.normalize().multiplyScalar(t);
  },
  lerp: function (t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  },
  lerpVectors: function (t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
  },
  cross: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
  },
  crossVectors: function (t, e) {
    const n = t.x,
          i = t.y,
          r = t.z,
          o = e.x,
          s = e.y,
          a = e.z;
    return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this;
  },
  projectOnVector: function (t) {
    const e = t.lengthSq();
    if (0 === e) return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  },
  projectOnPlane: function (t) {
    return p.copy(this).projectOnVector(t), this.sub(p);
  },
  reflect: function (t) {
    return this.sub(p.copy(t).multiplyScalar(2 * this.dot(t)));
  },
  angleTo: function (t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (0 === e) return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(n.clamp(i, -1, 1));
  },
  distanceTo: function (t) {
    return Math.sqrt(this.distanceToSquared(t));
  },
  distanceToSquared: function (t) {
    const e = this.x - t.x,
          n = this.y - t.y,
          i = this.z - t.z;
    return e * e + n * n + i * i;
  },
  manhattanDistanceTo: function (t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  },
  setFromSpherical: function (t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  },
  setFromSphericalCoords: function (t, e, n) {
    const i = Math.sin(e) * t;
    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this;
  },
  setFromCylindrical: function (t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  },
  setFromCylindricalCoords: function (t, e, n) {
    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
  },
  setFromMatrixPosition: function (t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  },
  setFromMatrixScale: function (t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          i = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = n, this.z = i, this;
  },
  setFromMatrixColumn: function (t, e) {
    return this.fromArray(t.elements, 4 * e);
  },
  setFromMatrix3Column: function (t, e) {
    return this.fromArray(t.elements, 3 * e);
  },
  equals: function (t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  },
  fromArray: function (t, e) {
    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  },
  toArray: function (t, e) {
    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  },
  fromBufferAttribute: function (t, e, n) {
    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  },
  random: function () {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
});

const g = new m(),
      v = new M(),
      y = new m(0, 0, 0),
      x = new m(1, 1, 1),
      _ = new m(),
      b = new m(),
      w = new m();

function M() {
  this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}

Object.assign(M.prototype, {
  isMatrix4: !0,
  set: function (t, e, n, i, r, o, s, a, c, l, u, h, d, p, f, m) {
    const g = this.elements;
    return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this;
  },
  identity: function () {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  },
  clone: function () {
    return new M().fromArray(this.elements);
  },
  copy: function (t) {
    const e = this.elements,
          n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
  },
  copyPosition: function (t) {
    const e = this.elements,
          n = t.elements;
    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
  },
  extractBasis: function (t, e, n) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  },
  makeBasis: function (t, e, n) {
    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
  },
  extractRotation: function (t) {
    const e = this.elements,
          n = t.elements,
          i = 1 / g.setFromMatrixColumn(t, 0).length(),
          r = 1 / g.setFromMatrixColumn(t, 1).length(),
          o = 1 / g.setFromMatrixColumn(t, 2).length();
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  },
  makeRotationFromEuler: function (t) {
    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z,
          o = Math.cos(n),
          s = Math.sin(n),
          a = Math.cos(i),
          c = Math.sin(i),
          l = Math.cos(r),
          u = Math.sin(r);

    if ("XYZ" === t.order) {
      const t = o * l,
            n = o * u,
            i = s * l,
            r = s * u;
      e[0] = a * l, e[4] = -a * u, e[8] = c, e[1] = n + i * c, e[5] = t - r * c, e[9] = -s * a, e[2] = r - t * c, e[6] = i + n * c, e[10] = o * a;
    } else if ("YXZ" === t.order) {
      const t = a * l,
            n = a * u,
            i = c * l,
            r = c * u;
      e[0] = t + r * s, e[4] = i * s - n, e[8] = o * c, e[1] = o * u, e[5] = o * l, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = o * a;
    } else if ("ZXY" === t.order) {
      const t = a * l,
            n = a * u,
            i = c * l,
            r = c * u;
      e[0] = t - r * s, e[4] = -o * u, e[8] = i + n * s, e[1] = n + i * s, e[5] = o * l, e[9] = r - t * s, e[2] = -o * c, e[6] = s, e[10] = o * a;
    } else if ("ZYX" === t.order) {
      const t = o * l,
            n = o * u,
            i = s * l,
            r = s * u;
      e[0] = a * l, e[4] = i * c - n, e[8] = t * c + r, e[1] = a * u, e[5] = r * c + t, e[9] = n * c - i, e[2] = -c, e[6] = s * a, e[10] = o * a;
    } else if ("YZX" === t.order) {
      const t = o * a,
            n = o * c,
            i = s * a,
            r = s * c;
      e[0] = a * l, e[4] = r - t * u, e[8] = i * u + n, e[1] = u, e[5] = o * l, e[9] = -s * l, e[2] = -c * l, e[6] = n * u + i, e[10] = t - r * u;
    } else if ("XZY" === t.order) {
      const t = o * a,
            n = o * c,
            i = s * a,
            r = s * c;
      e[0] = a * l, e[4] = -u, e[8] = c * l, e[1] = t * u + r, e[5] = o * l, e[9] = n * u - i, e[2] = i * u - n, e[6] = s * l, e[10] = r * u + t;
    }

    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  },
  makeRotationFromQuaternion: function (t) {
    return this.compose(y, t, x);
  },
  lookAt: function (t, e, n) {
    const i = this.elements;
    return w.subVectors(t, e), 0 === w.lengthSq() && (w.z = 1), w.normalize(), _.crossVectors(n, w), 0 === _.lengthSq() && (1 === Math.abs(n.z) ? w.x += 1e-4 : w.z += 1e-4, w.normalize(), _.crossVectors(n, w)), _.normalize(), b.crossVectors(w, _), i[0] = _.x, i[4] = b.x, i[8] = w.x, i[1] = _.y, i[5] = b.y, i[9] = w.y, i[2] = _.z, i[6] = b.z, i[10] = w.z, this;
  },
  multiply: function (t, e) {
    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
  },
  premultiply: function (t) {
    return this.multiplyMatrices(t, this);
  },
  multiplyMatrices: function (t, e) {
    const n = t.elements,
          i = e.elements,
          r = this.elements,
          o = n[0],
          s = n[4],
          a = n[8],
          c = n[12],
          l = n[1],
          u = n[5],
          h = n[9],
          d = n[13],
          p = n[2],
          f = n[6],
          m = n[10],
          g = n[14],
          v = n[3],
          y = n[7],
          x = n[11],
          _ = n[15],
          b = i[0],
          w = i[4],
          M = i[8],
          S = i[12],
          E = i[1],
          T = i[5],
          A = i[9],
          L = i[13],
          C = i[2],
          R = i[6],
          P = i[10],
          O = i[14],
          N = i[3],
          D = i[7],
          I = i[11],
          z = i[15];
    return r[0] = o * b + s * E + a * C + c * N, r[4] = o * w + s * T + a * R + c * D, r[8] = o * M + s * A + a * P + c * I, r[12] = o * S + s * L + a * O + c * z, r[1] = l * b + u * E + h * C + d * N, r[5] = l * w + u * T + h * R + d * D, r[9] = l * M + u * A + h * P + d * I, r[13] = l * S + u * L + h * O + d * z, r[2] = p * b + f * E + m * C + g * N, r[6] = p * w + f * T + m * R + g * D, r[10] = p * M + f * A + m * P + g * I, r[14] = p * S + f * L + m * O + g * z, r[3] = v * b + y * E + x * C + _ * N, r[7] = v * w + y * T + x * R + _ * D, r[11] = v * M + y * A + x * P + _ * I, r[15] = v * S + y * L + x * O + _ * z, this;
  },
  multiplyScalar: function (t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  },
  determinant: function () {
    const t = this.elements,
          e = t[0],
          n = t[4],
          i = t[8],
          r = t[12],
          o = t[1],
          s = t[5],
          a = t[9],
          c = t[13],
          l = t[2],
          u = t[6],
          h = t[10],
          d = t[14];
    return t[3] * (+r * a * u - i * c * u - r * s * h + n * c * h + i * s * d - n * a * d) + t[7] * (+e * a * d - e * c * h + r * o * h - i * o * d + i * c * l - r * a * l) + t[11] * (+e * c * u - e * s * d - r * o * u + n * o * d + r * s * l - n * c * l) + t[15] * (-i * s * l - e * a * u + e * s * h + i * o * u - n * o * h + n * a * l);
  },
  transpose: function () {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  },
  setPosition: function (t, e, n) {
    const i = this.elements;
    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this;
  },
  getInverse: function (t, e) {
    void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");

    const n = this.elements,
          i = t.elements,
          r = i[0],
          o = i[1],
          s = i[2],
          a = i[3],
          c = i[4],
          l = i[5],
          u = i[6],
          h = i[7],
          d = i[8],
          p = i[9],
          f = i[10],
          m = i[11],
          g = i[12],
          v = i[13],
          y = i[14],
          x = i[15],
          _ = p * y * h - v * f * h + v * u * m - l * y * m - p * u * x + l * f * x,
          b = g * f * h - d * y * h - g * u * m + c * y * m + d * u * x - c * f * x,
          w = d * v * h - g * p * h + g * l * m - c * v * m - d * l * x + c * p * x,
          M = g * p * u - d * v * u - g * l * f + c * v * f + d * l * y - c * p * y,
          S = r * _ + o * b + s * w + a * M;

    if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / S;
    return n[0] = _ * E, n[1] = (v * f * a - p * y * a - v * s * m + o * y * m + p * s * x - o * f * x) * E, n[2] = (l * y * a - v * u * a + v * s * h - o * y * h - l * s * x + o * u * x) * E, n[3] = (p * u * a - l * f * a - p * s * h + o * f * h + l * s * m - o * u * m) * E, n[4] = b * E, n[5] = (d * y * a - g * f * a + g * s * m - r * y * m - d * s * x + r * f * x) * E, n[6] = (g * u * a - c * y * a - g * s * h + r * y * h + c * s * x - r * u * x) * E, n[7] = (c * f * a - d * u * a + d * s * h - r * f * h - c * s * m + r * u * m) * E, n[8] = w * E, n[9] = (g * p * a - d * v * a - g * o * m + r * v * m + d * o * x - r * p * x) * E, n[10] = (c * v * a - g * l * a + g * o * h - r * v * h - c * o * x + r * l * x) * E, n[11] = (d * l * a - c * p * a - d * o * h + r * p * h + c * o * m - r * l * m) * E, n[12] = M * E, n[13] = (d * v * s - g * p * s + g * o * f - r * v * f - d * o * y + r * p * y) * E, n[14] = (g * l * s - c * v * s - g * o * u + r * v * u + c * o * y - r * l * y) * E, n[15] = (c * p * s - d * l * s + d * o * u - r * p * u - c * o * f + r * l * f) * E, this;
  },
  scale: function (t) {
    const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z;
    return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this;
  },
  getMaxScaleOnAxis: function () {
    const t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, i));
  },
  makeTranslation: function (t, e, n) {
    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
  },
  makeRotationX: function (t) {
    const e = Math.cos(t),
          n = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
  },
  makeRotationY: function (t) {
    const e = Math.cos(t),
          n = Math.sin(t);
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
  },
  makeRotationZ: function (t) {
    const e = Math.cos(t),
          n = Math.sin(t);
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  },
  makeRotationAxis: function (t, e) {
    const n = Math.cos(e),
          i = Math.sin(e),
          r = 1 - n,
          o = t.x,
          s = t.y,
          a = t.z,
          c = r * o,
          l = r * s;
    return this.set(c * o + n, c * s - i * a, c * a + i * s, 0, c * s + i * a, l * s + n, l * a - i * o, 0, c * a - i * s, l * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this;
  },
  makeScale: function (t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  },
  makeShear: function (t, e, n) {
    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
  },
  compose: function (t, e, n) {
    const i = this.elements,
          r = e._x,
          o = e._y,
          s = e._z,
          a = e._w,
          c = r + r,
          l = o + o,
          u = s + s,
          h = r * c,
          d = r * l,
          p = r * u,
          f = o * l,
          m = o * u,
          g = s * u,
          v = a * c,
          y = a * l,
          x = a * u,
          _ = n.x,
          b = n.y,
          w = n.z;
    return i[0] = (1 - (f + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - v) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
  },
  decompose: function (t, e, n) {
    const i = this.elements;
    let r = g.set(i[0], i[1], i[2]).length(),
        o = g.set(i[4], i[5], i[6]).length(),
        s = g.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], v.copy(this);
    const a = 1 / r,
          c = 1 / o,
          l = 1 / s;
    return v.elements[0] *= a, v.elements[1] *= a, v.elements[2] *= a, v.elements[4] *= c, v.elements[5] *= c, v.elements[6] *= c, v.elements[8] *= l, v.elements[9] *= l, v.elements[10] *= l, e.setFromRotationMatrix(v), n.x = r, n.y = o, n.z = s, this;
  },
  makePerspective: function (t, e, n, i, r, o) {
    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const s = this.elements,
          a = 2 * r / (e - t),
          c = 2 * r / (n - i),
          l = (e + t) / (e - t),
          u = (n + i) / (n - i),
          h = -(o + r) / (o - r),
          d = -2 * o * r / (o - r);
    return s[0] = a, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = c, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this;
  },
  makeOrthographic: function (t, e, n, i, r, o) {
    const s = this.elements,
          a = 1 / (e - t),
          c = 1 / (n - i),
          l = 1 / (o - r),
          u = (e + t) * a,
          h = (n + i) * c,
          d = (o + r) * l;
    return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this;
  },
  equals: function (t) {
    const e = this.elements,
          n = t.elements;

    for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;

    return !0;
  },
  fromArray: function (t, e) {
    void 0 === e && (e = 0);

    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];

    return this;
  },
  toArray: function (t, e) {
    void 0 === t && (t = []), void 0 === e && (e = 0);
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
  }
});
const S = new M(),
      E = new d();

function T(t = 0, e = 0, n = 0, i = T.DefaultOrder) {
  this._x = t, this._y = e, this._z = n, this._order = i;
}

function A() {
  this.mask = 1;
}

T.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], T.DefaultOrder = "XYZ", Object.defineProperties(T.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (t) {
      this._x = t, this._onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (t) {
      this._y = t, this._onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (t) {
      this._z = t, this._onChangeCallback();
    }
  },
  order: {
    get: function () {
      return this._order;
    },
    set: function (t) {
      this._order = t, this._onChangeCallback();
    }
  }
}), Object.assign(T.prototype, {
  isEuler: !0,
  set: function (t, e, n, i) {
    return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function (t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  },
  setFromRotationMatrix: function (t, e, i) {
    const r = n.clamp,
          o = t.elements,
          s = o[0],
          a = o[4],
          c = o[8],
          l = o[1],
          u = o[5],
          h = o[9],
          d = o[2],
          p = o[6],
          f = o[10];

    switch (e = e || this._order) {
      case "XYZ":
        this._y = Math.asin(r(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(p, u), this._z = 0);
        break;

      case "YXZ":
        this._x = Math.asin(-r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(c, f), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-d, s), this._z = 0);
        break;

      case "ZXY":
        this._x = Math.asin(r(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;

      case "ZYX":
        this._y = Math.asin(-r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, u));
        break;

      case "YZX":
        this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, u), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(c, f));
        break;

      case "XZY":
        this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(p, u), this._y = Math.atan2(c, s)) : (this._x = Math.atan2(-h, f), this._y = 0);
        break;

      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }

    return this._order = e, !1 !== i && this._onChangeCallback(), this;
  },
  setFromQuaternion: function (t, e, n) {
    return S.makeRotationFromQuaternion(t), this.setFromRotationMatrix(S, e, n);
  },
  setFromVector3: function (t, e) {
    return this.set(t.x, t.y, t.z, e || this._order);
  },
  reorder: function (t) {
    return E.setFromEuler(this), this.setFromQuaternion(E, t);
  },
  equals: function (t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  },
  fromArray: function (t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
  },
  toArray: function (t, e) {
    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  },
  toVector3: function (t) {
    return t ? t.set(this._x, this._y, this._z) : new m(this._x, this._y, this._z);
  },
  _onChange: function (t) {
    return this._onChangeCallback = t, this;
  },
  _onChangeCallback: function () {}
}), Object.assign(A.prototype, {
  set: function (t) {
    this.mask = 1 << t | 0;
  },
  enable: function (t) {
    this.mask |= 1 << t | 0;
  },
  enableAll: function () {
    this.mask = -1;
  },
  toggle: function (t) {
    this.mask ^= 1 << t | 0;
  },
  disable: function (t) {
    this.mask &= ~(1 << t | 0);
  },
  disableAll: function () {
    this.mask = 0;
  },
  test: function (t) {
    return 0 != (this.mask & t.mask);
  }
});
let L = 0;
const C = new m(),
      R = new d(),
      P = new M(),
      O = new m(),
      N = new m(),
      D = new m(),
      I = new d(),
      z = new m(1, 0, 0),
      B = new m(0, 1, 0),
      k = new m(0, 0, 1),
      H = {
  type: "added"
},
      F = {
  type: "removed"
};

function U() {
  Object.defineProperty(this, "id", {
    value: L++
  }), this.uuid = n.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = U.DefaultUp.clone();
  const t = new m(),
        e = new T(),
        i = new d(),
        o = new m(1, 1, 1);
  e._onChange(function () {
    i.setFromEuler(e, !1);
  }), i._onChange(function () {
    e.setFromQuaternion(i, void 0, !1);
  }), Object.defineProperties(this, {
    position: {
      configurable: !0,
      enumerable: !0,
      value: t
    },
    rotation: {
      configurable: !0,
      enumerable: !0,
      value: e
    },
    quaternion: {
      configurable: !0,
      enumerable: !0,
      value: i
    },
    scale: {
      configurable: !0,
      enumerable: !0,
      value: o
    },
    modelViewMatrix: {
      value: new M()
    },
    normalMatrix: {
      value: new r()
    }
  }), this.matrix = new M(), this.matrixWorld = new M(), this.matrixAutoUpdate = U.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new A(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {};
}

function G() {
  U.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
    detail: this
  }));
}

U.DefaultUp = new m(0, 1, 0), U.DefaultMatrixAutoUpdate = !0, U.prototype = Object.assign(Object.create(t.prototype), {
  constructor: U,
  isObject3D: !0,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix4: function (t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (t) {
    return this.quaternion.premultiply(t), this;
  },
  setRotationFromAxisAngle: function (t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  },
  setRotationFromEuler: function (t) {
    this.quaternion.setFromEuler(t, !0);
  },
  setRotationFromMatrix: function (t) {
    this.quaternion.setFromRotationMatrix(t);
  },
  setRotationFromQuaternion: function (t) {
    this.quaternion.copy(t);
  },
  rotateOnAxis: function (t, e) {
    return R.setFromAxisAngle(t, e), this.quaternion.multiply(R), this;
  },
  rotateOnWorldAxis: function (t, e) {
    return R.setFromAxisAngle(t, e), this.quaternion.premultiply(R), this;
  },
  rotateX: function (t) {
    return this.rotateOnAxis(z, t);
  },
  rotateY: function (t) {
    return this.rotateOnAxis(B, t);
  },
  rotateZ: function (t) {
    return this.rotateOnAxis(k, t);
  },
  translateOnAxis: function (t, e) {
    return C.copy(t).applyQuaternion(this.quaternion), this.position.add(C.multiplyScalar(e)), this;
  },
  translateX: function (t) {
    return this.translateOnAxis(z, t);
  },
  translateY: function (t) {
    return this.translateOnAxis(B, t);
  },
  translateZ: function (t) {
    return this.translateOnAxis(k, t);
  },
  localToWorld: function (t) {
    return t.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function (t) {
    return t.applyMatrix4(P.getInverse(this.matrixWorld));
  },
  lookAt: function (t, e, n) {
    t.isVector3 ? O.copy(t) : O.set(t, e, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), N.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? P.lookAt(N, O, this.up) : P.lookAt(O, N, this.up), this.quaternion.setFromRotationMatrix(P), i && (P.extractRotation(i.matrixWorld), R.setFromRotationMatrix(P), this.quaternion.premultiply(R.inverse()));
  },
  add: function (t) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);

      return this;
    }

    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(H)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  },
  remove: function (t) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);

      return this;
    }

    const e = this.children.indexOf(t);
    return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(F)), this;
  },
  attach: function (t) {
    return this.updateWorldMatrix(!0, !1), P.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), P.multiply(t.parent.matrixWorld)), t.applyMatrix4(P), t.updateWorldMatrix(!1, !1), this.add(t), this;
  },
  getObjectById: function (t) {
    return this.getObjectByProperty("id", t);
  },
  getObjectByName: function (t) {
    return this.getObjectByProperty("name", t);
  },
  getObjectByProperty: function (t, e) {
    if (this[t] === e) return this;

    for (let n = 0, i = this.children.length; n < i; n++) {
      const i = this.children[n].getObjectByProperty(t, e);
      if (void 0 !== i) return i;
    }
  },
  getWorldPosition: function (t) {
    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new m()), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function (t) {
    return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new d()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(N, t, D), t;
  },
  getWorldScale: function (t) {
    return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new m()), this.updateMatrixWorld(!0), this.matrixWorld.decompose(N, I, t), t;
  },
  getWorldDirection: function (t) {
    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new m()), this.updateMatrixWorld(!0);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (t) {
    t(this);
    const e = this.children;

    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
  },
  traverseVisible: function (t) {
    if (!1 === this.visible) return;
    t(this);
    const e = this.children;

    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
  },
  traverseAncestors: function (t) {
    const e = this.parent;
    null !== e && (t(e), e.traverseAncestors(t));
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function (t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;

    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
  },
  updateWorldMatrix: function (t, e) {
    const n = this.parent;

    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
      const t = this.children;

      for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0);
    }
  },
  toJSON: function (t) {
    const e = void 0 === t || "string" == typeof t,
          n = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {}
    }, n.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};

    function r(e, n) {
      return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
    }

    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(t.geometries, this.geometry);
      const e = this.geometry.parameters;

      if (void 0 !== e && void 0 !== e.shapes) {
        const n = e.shapes;
        if (Array.isArray(n)) for (let e = 0, i = n.length; e < i; e++) {
          const i = n[e];
          r(t.shapes, i);
        } else r(t.shapes, n);
      }
    }

    if (void 0 !== this.material) if (Array.isArray(this.material)) {
      const e = [];

      for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));

      i.material = e;
    } else i.material = r(t.materials, this.material);

    if (this.children.length > 0) {
      i.children = [];

      for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object);
    }

    if (e) {
      const e = o(t.geometries),
            i = o(t.materials),
            r = o(t.textures),
            s = o(t.images),
            a = o(t.shapes);
      e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a);
    }

    return n.object = i, n;

    function o(t) {
      const e = [];

      for (const n in t) {
        const i = t[n];
        delete i.metadata, e.push(i);
      }

      return e;
    }
  },
  clone: function (t) {
    return new this.constructor().copy(this, t);
  },
  copy: function (t, e) {
    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) {
      const n = t.children[e];
      this.add(n.clone());
    }
    return this;
  }
}), G.prototype = Object.assign(Object.create(U.prototype), {
  constructor: G,
  isScene: !0,
  copy: function (t, e) {
    return U.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  },
  toJSON: function (t) {
    const e = U.prototype.toJSON.call(this, t);
    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
  },
  dispose: function () {
    this.dispatchEvent({
      type: "dispose"
    });
  }
});
const j = [new m(), new m(), new m(), new m(), new m(), new m(), new m(), new m()],
      V = new m(),
      W = new nt(),
      q = new m(),
      X = new m(),
      Y = new m(),
      Z = new m(),
      J = new m(),
      Q = new m(),
      K = new m(),
      $ = new m(),
      tt = new m(),
      et = new m();

function nt(t, e) {
  this.min = void 0 !== t ? t : new m(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new m(-1 / 0, -1 / 0, -1 / 0);
}

function it(t, e, n, i, r) {
  for (let o = 0, s = t.length - 3; o <= s; o += 3) {
    et.fromArray(t, o);
    const s = r.x * Math.abs(et.x) + r.y * Math.abs(et.y) + r.z * Math.abs(et.z),
          a = e.dot(et),
          c = n.dot(et),
          l = i.dot(et);
    if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1;
  }

  return !0;
}

Object.assign(nt.prototype, {
  isBox3: !0,
  set: function (t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  },
  setFromArray: function (t) {
    let e = 1 / 0,
        n = 1 / 0,
        i = 1 / 0,
        r = -1 / 0,
        o = -1 / 0,
        s = -1 / 0;

    for (let a = 0, c = t.length; a < c; a += 3) {
      const c = t[a],
            l = t[a + 1],
            u = t[a + 2];
      c < e && (e = c), l < n && (n = l), u < i && (i = u), c > r && (r = c), l > o && (o = l), u > s && (s = u);
    }

    return this.min.set(e, n, i), this.max.set(r, o, s), this;
  },
  setFromBufferAttribute: function (t) {
    let e = 1 / 0,
        n = 1 / 0,
        i = 1 / 0,
        r = -1 / 0,
        o = -1 / 0,
        s = -1 / 0;

    for (let a = 0, c = t.count; a < c; a++) {
      const c = t.getX(a),
            l = t.getY(a),
            u = t.getZ(a);
      c < e && (e = c), l < n && (n = l), u < i && (i = u), c > r && (r = c), l > o && (o = l), u > s && (s = u);
    }

    return this.min.set(e, n, i), this.max.set(r, o, s), this;
  },
  setFromPoints: function (t) {
    this.makeEmpty();

    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);

    return this;
  },
  setFromCenterAndSize: function (t, e) {
    const n = V.copy(e).multiplyScalar(.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  },
  setFromObject: function (t) {
    return this.makeEmpty(), this.expandByObject(t);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  },
  makeEmpty: function () {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  },
  isEmpty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function (t) {
    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new m()), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
  },
  getSize: function (t) {
    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new m()), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  },
  expandByPoint: function (t) {
    return this.min.min(t), this.max.max(t), this;
  },
  expandByVector: function (t) {
    return this.min.sub(t), this.max.add(t), this;
  },
  expandByScalar: function (t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  },
  expandByObject: function (t) {
    t.updateWorldMatrix(!1, !1);
    const e = t.geometry;
    void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), W.copy(e.boundingBox), W.applyMatrix4(t.matrixWorld), this.union(W));
    const n = t.children;

    for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);

    return this;
  },
  containsPoint: function (t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
  },
  containsBox: function (t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  },
  getParameter: function (t, e) {
    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new m()), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function (t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
  },
  intersectsSphere: function (t) {
    return this.clampPoint(t.center, V), V.distanceToSquared(t.center) <= t.radius * t.radius;
  },
  intersectsPlane: function (t) {
    let e, n;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
  },
  intersectsTriangle: function (t) {
    if (this.isEmpty()) return !1;
    this.getCenter(K), $.subVectors(this.max, K), q.subVectors(t.a, K), X.subVectors(t.b, K), Y.subVectors(t.c, K), Z.subVectors(X, q), J.subVectors(Y, X), Q.subVectors(q, Y);
    let e = [0, -Z.z, Z.y, 0, -J.z, J.y, 0, -Q.z, Q.y, Z.z, 0, -Z.x, J.z, 0, -J.x, Q.z, 0, -Q.x, -Z.y, Z.x, 0, -J.y, J.x, 0, -Q.y, Q.x, 0];
    return !!it(e, q, X, Y, $) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!it(e, q, X, Y, $) && (tt.crossVectors(Z, J), e = [tt.x, tt.y, tt.z], it(e, q, X, Y, $)));
  },
  clampPoint: function (t, e) {
    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new m()), e.copy(t).clamp(this.min, this.max);
  },
  distanceToPoint: function (t) {
    return V.copy(t).clamp(this.min, this.max).sub(t).length();
  },
  getBoundingSphere: function (t) {
    return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(V).length(), t;
  },
  intersect: function (t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  },
  union: function (t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  },
  applyMatrix4: function (t) {
    return this.isEmpty() || (j[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), j[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), j[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), j[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), j[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), j[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), j[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), j[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(j)), this;
  },
  translate: function (t) {
    return this.min.add(t), this.max.add(t), this;
  },
  equals: function (t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
});
const rt = new nt();

function ot(t, e) {
  this.center = void 0 !== t ? t : new m(), this.radius = void 0 !== e ? e : -1;
}

Object.assign(ot.prototype, {
  set: function (t, e) {
    return this.center.copy(t), this.radius = e, this;
  },
  setFromPoints: function (t, e) {
    const n = this.center;
    void 0 !== e ? n.copy(e) : rt.setFromPoints(t).getCenter(n);
    let i = 0;

    for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));

    return this.radius = Math.sqrt(i), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  },
  isEmpty: function () {
    return this.radius < 0;
  },
  makeEmpty: function () {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  },
  containsPoint: function (t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (t) {
    return t.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  },
  intersectsBox: function (t) {
    return t.intersectsSphere(this);
  },
  intersectsPlane: function (t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function (t, e) {
    const n = this.center.distanceToSquared(t);
    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new m()), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  },
  getBoundingBox: function (t) {
    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new nt()), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  },
  applyMatrix4: function (t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  },
  translate: function (t) {
    return this.center.add(t), this;
  },
  equals: function (t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
});
const st = new m(),
      at = new m(),
      ct = new m(),
      lt = new m(),
      ut = new m(),
      ht = new m(),
      dt = new m();

function pt(t, e) {
  this.origin = void 0 !== t ? t : new m(), this.direction = void 0 !== e ? e : new m(0, 0, -1);
}

Object.assign(pt.prototype, {
  set: function (t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  },
  at: function (t, e) {
    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new m()), e.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function (t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  },
  recast: function (t) {
    return this.origin.copy(this.at(t, st)), this;
  },
  closestPointToPoint: function (t, e) {
    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new m()), e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
  },
  distanceToPoint: function (t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  },
  distanceSqToPoint: function (t) {
    const e = st.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (st.copy(this.direction).multiplyScalar(e).add(this.origin), st.distanceToSquared(t));
  },
  distanceSqToSegment: function (t, e, n, i) {
    at.copy(t).add(e).multiplyScalar(.5), ct.copy(e).sub(t).normalize(), lt.copy(this.origin).sub(at);
    const r = .5 * t.distanceTo(e),
          o = -this.direction.dot(ct),
          s = lt.dot(this.direction),
          a = -lt.dot(ct),
          c = lt.lengthSq(),
          l = Math.abs(1 - o * o);
    let u, h, d, p;
    if (l > 0) {
      if (u = o * a - s, h = o * s - a, p = r * l, u >= 0) {
        if (h >= -p) {
          if (h <= p) {
            const t = 1 / l;
            u *= t, h *= t, d = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + c;
          } else h = r, u = Math.max(0, -(o * h + s)), d = -u * u + h * (h + 2 * a) + c;
        } else h = -r, u = Math.max(0, -(o * h + s)), d = -u * u + h * (h + 2 * a) + c;
      } else h <= -p ? (u = Math.max(0, -(-o * r + s)), h = u > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + c) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -a), r), d = h * (h + 2 * a) + c) : (u = Math.max(0, -(o * r + s)), h = u > 0 ? r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + c);
    } else h = o > 0 ? -r : r, u = Math.max(0, -(o * h + s)), d = -u * u + h * (h + 2 * a) + c;
    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(ct).multiplyScalar(h).add(at), d;
  },
  intersectSphere: function (t, e) {
    st.subVectors(t.center, this.origin);
    const n = st.dot(this.direction),
          i = st.dot(st) - n * n,
          r = t.radius * t.radius;
    if (i > r) return null;
    const o = Math.sqrt(r - i),
          s = n - o,
          a = n + o;
    return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
  },
  intersectsSphere: function (t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  },
  distanceToPlane: function (t) {
    const e = t.normal.dot(this.direction);
    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  },
  intersectPlane: function (t, e) {
    const n = this.distanceToPlane(t);
    return null === n ? null : this.at(n, e);
  },
  intersectsPlane: function (t) {
    const e = t.distanceToPoint(this.origin);
    return 0 === e || t.normal.dot(this.direction) * e < 0;
  },
  intersectBox: function (t, e) {
    let n, i, r, o, s, a;
    const c = 1 / this.direction.x,
          l = 1 / this.direction.y,
          u = 1 / this.direction.z,
          h = this.origin;
    return c >= 0 ? (n = (t.min.x - h.x) * c, i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, i = (t.min.x - h.x) * c), l >= 0 ? (r = (t.min.y - h.y) * l, o = (t.max.y - h.y) * l) : (r = (t.max.y - h.y) * l, o = (t.min.y - h.y) * l), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), u >= 0 ? (s = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (s = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)));
  },
  intersectsBox: function (t) {
    return null !== this.intersectBox(t, st);
  },
  intersectTriangle: function (t, e, n, i, r) {
    ut.subVectors(e, t), ht.subVectors(n, t), dt.crossVectors(ut, ht);
    let o,
        s = this.direction.dot(dt);

    if (s > 0) {
      if (i) return null;
      o = 1;
    } else {
      if (!(s < 0)) return null;
      o = -1, s = -s;
    }

    lt.subVectors(this.origin, t);
    const a = o * this.direction.dot(ht.crossVectors(lt, ht));
    if (a < 0) return null;
    const c = o * this.direction.dot(ut.cross(lt));
    if (c < 0) return null;
    if (a + c > s) return null;
    const l = -o * lt.dot(dt);
    return l < 0 ? null : this.at(l / s, r);
  },
  applyMatrix4: function (t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  },
  equals: function (t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
});
const ft = new m(),
      mt = new m(),
      gt = new r();

function vt(t, e) {
  this.normal = void 0 !== t ? t : new m(1, 0, 0), this.constant = void 0 !== e ? e : 0;
}

Object.assign(vt.prototype, {
  isPlane: !0,
  set: function (t, e) {
    return this.normal.copy(t), this.constant = e, this;
  },
  setComponents: function (t, e, n, i) {
    return this.normal.set(t, e, n), this.constant = i, this;
  },
  setFromNormalAndCoplanarPoint: function (t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  },
  setFromCoplanarPoints: function (t, e, n) {
    const i = ft.subVectors(n, e).cross(mt.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  },
  normalize: function () {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  },
  negate: function () {
    return this.constant *= -1, this.normal.negate(), this;
  },
  distanceToPoint: function (t) {
    return this.normal.dot(t) + this.constant;
  },
  distanceToSphere: function (t) {
    return this.distanceToPoint(t.center) - t.radius;
  },
  projectPoint: function (t, e) {
    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new m()), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
  },
  intersectLine: function (t, e) {
    void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new m());
    const n = t.delta(ft),
          i = this.normal.dot(n);
    if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
    const r = -(t.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start);
  },
  intersectsLine: function (t) {
    const e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
    return e < 0 && n > 0 || n < 0 && e > 0;
  },
  intersectsBox: function (t) {
    return t.intersectsPlane(this);
  },
  intersectsSphere: function (t) {
    return t.intersectsPlane(this);
  },
  coplanarPoint: function (t) {
    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new m()), t.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function (t, e) {
    const n = e || gt.getNormalMatrix(t),
          i = this.coplanarPoint(ft).applyMatrix4(t),
          r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(r), this;
  },
  translate: function (t) {
    return this.constant -= t.dot(this.normal), this;
  },
  equals: function (t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
});

const yt = new m(),
      xt = new m(),
      _t = new m(),
      bt = new m(),
      wt = new m(),
      Mt = new m(),
      St = new m(),
      Et = new m(),
      Tt = new m(),
      At = new m();

function Lt(t, e, n) {
  this.a = void 0 !== t ? t : new m(), this.b = void 0 !== e ? e : new m(), this.c = void 0 !== n ? n : new m();
}

Object.assign(Lt, {
  getNormal: function (t, e, n, i) {
    void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new m()), i.subVectors(n, e), yt.subVectors(t, e), i.cross(yt);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  },
  getBarycoord: function (t, e, n, i, r) {
    yt.subVectors(i, e), xt.subVectors(n, e), _t.subVectors(t, e);
    const o = yt.dot(yt),
          s = yt.dot(xt),
          a = yt.dot(_t),
          c = xt.dot(xt),
          l = xt.dot(_t),
          u = o * c - s * s;
    if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new m()), 0 === u) return r.set(-2, -1, -1);
    const h = 1 / u,
          d = (c * a - s * l) * h,
          p = (o * l - s * a) * h;
    return r.set(1 - d - p, p, d);
  },
  containsPoint: function (t, e, n, i) {
    return Lt.getBarycoord(t, e, n, i, bt), bt.x >= 0 && bt.y >= 0 && bt.x + bt.y <= 1;
  },
  getUV: function (t, e, n, i, r, o, s, a) {
    return this.getBarycoord(t, e, n, i, bt), a.set(0, 0), a.addScaledVector(r, bt.x), a.addScaledVector(o, bt.y), a.addScaledVector(s, bt.z), a;
  },
  isFrontFacing: function (t, e, n, i) {
    return yt.subVectors(n, e), xt.subVectors(t, e), yt.cross(xt).dot(i) < 0;
  }
}), Object.assign(Lt.prototype, {
  set: function (t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  },
  setFromPointsAndIndices: function (t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  },
  getArea: function () {
    return yt.subVectors(this.c, this.b), xt.subVectors(this.a, this.b), .5 * yt.cross(xt).length();
  },
  getMidpoint: function (t) {
    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new m()), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function (t) {
    return Lt.getNormal(this.a, this.b, this.c, t);
  },
  getPlane: function (t) {
    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new vt()), t.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function (t, e) {
    return Lt.getBarycoord(t, this.a, this.b, this.c, e);
  },
  getUV: function (t, e, n, i, r) {
    return Lt.getUV(t, this.a, this.b, this.c, e, n, i, r);
  },
  containsPoint: function (t) {
    return Lt.containsPoint(t, this.a, this.b, this.c);
  },
  isFrontFacing: function (t) {
    return Lt.isFrontFacing(this.a, this.b, this.c, t);
  },
  intersectsBox: function (t) {
    return t.intersectsTriangle(this);
  },
  closestPointToPoint: function (t, e) {
    void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new m());
    const n = this.a,
          i = this.b,
          r = this.c;
    let o, s;
    wt.subVectors(i, n), Mt.subVectors(r, n), Et.subVectors(t, n);
    const a = wt.dot(Et),
          c = Mt.dot(Et);
    if (a <= 0 && c <= 0) return e.copy(n);
    Tt.subVectors(t, i);
    const l = wt.dot(Tt),
          u = Mt.dot(Tt);
    if (l >= 0 && u <= l) return e.copy(i);
    const h = a * u - l * c;
    if (h <= 0 && a >= 0 && l <= 0) return o = a / (a - l), e.copy(n).addScaledVector(wt, o);
    At.subVectors(t, r);
    const d = wt.dot(At),
          p = Mt.dot(At);
    if (p >= 0 && d <= p) return e.copy(r);
    const f = d * c - a * p;
    if (f <= 0 && c >= 0 && p <= 0) return s = c / (c - p), e.copy(n).addScaledVector(Mt, s);
    const g = l * p - d * u;
    if (g <= 0 && u - l >= 0 && d - p >= 0) return St.subVectors(r, i), s = (u - l) / (u - l + (d - p)), e.copy(i).addScaledVector(St, s);
    const v = 1 / (g + f + h);
    return o = f * v, s = h * v, e.copy(n).addScaledVector(wt, o).addScaledVector(Mt, s);
  },
  equals: function (t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
});
const Ct = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
},
      Rt = {
  h: 0,
  s: 0,
  l: 0
},
      Pt = {
  h: 0,
  s: 0,
  l: 0
};

function Ot(t, e, n) {
  return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
}

function Nt(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t;
}

function Dt(t) {
  return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4);
}

function It(t) {
  return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055;
}

function zt(t, e, n, i, r, o) {
  this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new m(), this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Ot(), this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0;
}

Object.assign(Ot.prototype, {
  isColor: !0,
  r: 1,
  g: 1,
  b: 1,
  set: function (t) {
    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
  },
  setScalar: function (t) {
    return this.r = t, this.g = t, this.b = t, this;
  },
  setHex: function (t) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this;
  },
  setRGB: function (t, e, n) {
    return this.r = t, this.g = e, this.b = n, this;
  },
  setHSL: function (t, e, i) {
    if (t = n.euclideanModulo(t, 1), e = n.clamp(e, 0, 1), i = n.clamp(i, 0, 1), 0 === e) this.r = this.g = this.b = i;else {
      const n = i <= .5 ? i * (1 + e) : i + e - i * e,
            r = 2 * i - n;
      this.r = Nt(r, n, t + 1 / 3), this.g = Nt(r, n, t), this.b = Nt(r, n, t - 1 / 3);
    }
    return this;
  },
  setStyle: function (t) {
    function e(e) {
      void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }

    let n;

    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
      let t;
      const i = n[1],
            r = n[2];

      switch (i) {
        case "rgb":
        case "rgba":
          if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this;
          if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this;
          break;

        case "hsl":
        case "hsla":
          if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
            const n = parseFloat(t[1]) / 360,
                  i = parseInt(t[2], 10) / 100,
                  r = parseInt(t[3], 10) / 100;
            return e(t[5]), this.setHSL(n, i, r);
          }

      }
    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
      const t = n[1],
            e = t.length;
      if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
      if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this;
    }

    return t && t.length > 0 ? this.setColorName(t) : this;
  },
  setColorName: function (t) {
    const e = Ct[t];
    return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this;
  },
  clone: function () {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function (t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  },
  copyGammaToLinear: function (t, e) {
    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this;
  },
  copyLinearToGamma: function (t, e) {
    void 0 === e && (e = 2);
    const n = e > 0 ? 1 / e : 1;
    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this;
  },
  convertGammaToLinear: function (t) {
    return this.copyGammaToLinear(this, t), this;
  },
  convertLinearToGamma: function (t) {
    return this.copyLinearToGamma(this, t), this;
  },
  copySRGBToLinear: function (t) {
    return this.r = Dt(t.r), this.g = Dt(t.g), this.b = Dt(t.b), this;
  },
  copyLinearToSRGB: function (t) {
    return this.r = It(t.r), this.g = It(t.g), this.b = It(t.b), this;
  },
  convertSRGBToLinear: function () {
    return this.copySRGBToLinear(this), this;
  },
  convertLinearToSRGB: function () {
    return this.copyLinearToSRGB(this), this;
  },
  getHex: function () {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  },
  getHexString: function () {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (t) {
    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
      h: 0,
      s: 0,
      l: 0
    });
    const e = this.r,
          n = this.g,
          i = this.b,
          r = Math.max(e, n, i),
          o = Math.min(e, n, i);
    let s, a;
    const c = (o + r) / 2;
    if (o === r) s = 0, a = 0;else {
      const t = r - o;

      switch (a = c <= .5 ? t / (r + o) : t / (2 - r - o), r) {
        case e:
          s = (n - i) / t + (n < i ? 6 : 0);
          break;

        case n:
          s = (i - e) / t + 2;
          break;

        case i:
          s = (e - n) / t + 4;
      }

      s /= 6;
    }
    return t.h = s, t.s = a, t.l = c, t;
  },
  getStyle: function () {
    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
  },
  offsetHSL: function (t, e, n) {
    return this.getHSL(Rt), Rt.h += t, Rt.s += e, Rt.l += n, this.setHSL(Rt.h, Rt.s, Rt.l), this;
  },
  add: function (t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  },
  addColors: function (t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  },
  addScalar: function (t) {
    return this.r += t, this.g += t, this.b += t, this;
  },
  sub: function (t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  },
  multiply: function (t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  },
  multiplyScalar: function (t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  },
  lerp: function (t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  },
  lerpHSL: function (t, e) {
    this.getHSL(Rt), t.getHSL(Pt);
    const i = n.lerp(Rt.h, Pt.h, e),
          r = n.lerp(Rt.s, Pt.s, e),
          o = n.lerp(Rt.l, Pt.l, e);
    return this.setHSL(i, r, o), this;
  },
  equals: function (t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  },
  fromArray: function (t, e) {
    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  },
  toArray: function (t, e) {
    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  },
  fromBufferAttribute: function (t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  },
  toJSON: function () {
    return this.getHex();
  }
}), Ot.NAMES = Ct, Object.assign(zt.prototype, {
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;

    for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();

    for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();

    return this;
  }
});
let Bt = 0;

function kt() {
  Object.defineProperty(this, "id", {
    value: Bt++
  }), this.uuid = n.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0;
}

function Ht(t) {
  kt.call(this), this.type = "MeshBasicMaterial", this.color = new Ot(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t);
}

kt.prototype = Object.assign(Object.create(t.prototype), {
  constructor: kt,
  isMaterial: !0,
  onBeforeCompile: function () {},
  customProgramCacheKey: function () {
    return this.onBeforeCompile.toString();
  },
  setValues: function (t) {
    if (void 0 !== t) for (const e in t) {
      const n = t[e];

      if (void 0 === n) {
        console.warn("THREE.Material: '" + e + "' parameter is undefined.");
        continue;
      }

      if ("shading" === e) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
        continue;
      }

      const i = this[e];
      void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
    }
  },
  toJSON: function (t) {
    const e = void 0 === t || "string" == typeof t;
    e && (t = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };

    function i(t) {
      const e = [];

      for (const n in t) {
        const i = t[n];
        delete i.metadata, e.push(i);
      }

      return e;
    }

    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
      const e = i(t.textures),
            r = i(t.images);
      e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
    }

    return n;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let n = null;

    if (null !== e) {
      const t = e.length;
      n = new Array(t);

      for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
    }

    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: "dispose"
    });
  }
}), Object.defineProperty(kt.prototype, "needsUpdate", {
  set: function (t) {
    !0 === t && this.version++;
  }
}), Ht.prototype = Object.create(kt.prototype), Ht.prototype.constructor = Ht, Ht.prototype.isMeshBasicMaterial = !0, Ht.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this;
};
const Ft = new m(),
      Ut = new i();

function Gt(t, e, n) {
  if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
    offset: 0,
    count: -1
  }, this.version = 0;
}

function jt(t, e, n) {
  Gt.call(this, new Int8Array(t), e, n);
}

function Vt(t, e, n) {
  Gt.call(this, new Uint8Array(t), e, n);
}

function Wt(t, e, n) {
  Gt.call(this, new Uint8ClampedArray(t), e, n);
}

function qt(t, e, n) {
  Gt.call(this, new Int16Array(t), e, n);
}

function Xt(t, e, n) {
  Gt.call(this, new Uint16Array(t), e, n);
}

function Yt(t, e, n) {
  Gt.call(this, new Int32Array(t), e, n);
}

function Zt(t, e, n) {
  Gt.call(this, new Uint32Array(t), e, n);
}

function Jt(t, e, n) {
  Gt.call(this, new Float32Array(t), e, n);
}

function Qt(t, e, n) {
  Gt.call(this, new Float64Array(t), e, n);
}

function Kt() {
  this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1;
}

function $t(t) {
  if (0 === t.length) return -1 / 0;
  let e = t[0];

  for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);

  return e;
}

Object.defineProperty(Gt.prototype, "needsUpdate", {
  set: function (t) {
    !0 === t && this.version++;
  }
}), Object.assign(Gt.prototype, {
  isBufferAttribute: !0,
  onUploadCallback: function () {},
  setUsage: function (t) {
    return this.usage = t, this;
  },
  copy: function (t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
  },
  copyAt: function (t, e, n) {
    t *= this.itemSize, n *= e.itemSize;

    for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];

    return this;
  },
  copyArray: function (t) {
    return this.array.set(t), this;
  },
  copyColorsArray: function (t) {
    const e = this.array;
    let n = 0;

    for (let i = 0, r = t.length; i < r; i++) {
      let r = t[i];
      void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Ot()), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b;
    }

    return this;
  },
  copyVector2sArray: function (t) {
    const e = this.array;
    let n = 0;

    for (let r = 0, o = t.length; r < o; r++) {
      let o = t[r];
      void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new i()), e[n++] = o.x, e[n++] = o.y;
    }

    return this;
  },
  copyVector3sArray: function (t) {
    const e = this.array;
    let n = 0;

    for (let i = 0, r = t.length; i < r; i++) {
      let r = t[i];
      void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new m()), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z;
    }

    return this;
  },
  copyVector4sArray: function (t) {
    const e = this.array;
    let n = 0;

    for (let i = 0, r = t.length; i < r; i++) {
      let r = t[i];
      void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new l()), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w;
    }

    return this;
  },
  applyMatrix3: function (t) {
    if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) Ut.fromBufferAttribute(this, e), Ut.applyMatrix3(t), this.setXY(e, Ut.x, Ut.y);else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++) Ft.fromBufferAttribute(this, e), Ft.applyMatrix3(t), this.setXYZ(e, Ft.x, Ft.y, Ft.z);
    return this;
  },
  applyMatrix4: function (t) {
    for (let e = 0, n = this.count; e < n; e++) Ft.x = this.getX(e), Ft.y = this.getY(e), Ft.z = this.getZ(e), Ft.applyMatrix4(t), this.setXYZ(e, Ft.x, Ft.y, Ft.z);

    return this;
  },
  applyNormalMatrix: function (t) {
    for (let e = 0, n = this.count; e < n; e++) Ft.x = this.getX(e), Ft.y = this.getY(e), Ft.z = this.getZ(e), Ft.applyNormalMatrix(t), this.setXYZ(e, Ft.x, Ft.y, Ft.z);

    return this;
  },
  transformDirection: function (t) {
    for (let e = 0, n = this.count; e < n; e++) Ft.x = this.getX(e), Ft.y = this.getY(e), Ft.z = this.getZ(e), Ft.transformDirection(t), this.setXYZ(e, Ft.x, Ft.y, Ft.z);

    return this;
  },
  set: function (t, e) {
    return void 0 === e && (e = 0), this.array.set(t, e), this;
  },
  getX: function (t) {
    return this.array[t * this.itemSize];
  },
  setX: function (t, e) {
    return this.array[t * this.itemSize] = e, this;
  },
  getY: function (t) {
    return this.array[t * this.itemSize + 1];
  },
  setY: function (t, e) {
    return this.array[t * this.itemSize + 1] = e, this;
  },
  getZ: function (t) {
    return this.array[t * this.itemSize + 2];
  },
  setZ: function (t, e) {
    return this.array[t * this.itemSize + 2] = e, this;
  },
  getW: function (t) {
    return this.array[t * this.itemSize + 3];
  },
  setW: function (t, e) {
    return this.array[t * this.itemSize + 3] = e, this;
  },
  setXY: function (t, e, n) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this;
  },
  setXYZ: function (t, e, n, i) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this;
  },
  setXYZW: function (t, e, n, i, r) {
    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this;
  },
  onUpload: function (t) {
    return this.onUploadCallback = t, this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function () {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
}), jt.prototype = Object.create(Gt.prototype), jt.prototype.constructor = jt, Vt.prototype = Object.create(Gt.prototype), Vt.prototype.constructor = Vt, Wt.prototype = Object.create(Gt.prototype), Wt.prototype.constructor = Wt, qt.prototype = Object.create(Gt.prototype), qt.prototype.constructor = qt, Xt.prototype = Object.create(Gt.prototype), Xt.prototype.constructor = Xt, Yt.prototype = Object.create(Gt.prototype), Yt.prototype.constructor = Yt, Zt.prototype = Object.create(Gt.prototype), Zt.prototype.constructor = Zt, Jt.prototype = Object.create(Gt.prototype), Jt.prototype.constructor = Jt, Qt.prototype = Object.create(Gt.prototype), Qt.prototype.constructor = Qt, Object.assign(Kt.prototype, {
  computeGroups: function (t) {
    const e = [];
    let n,
        i,
        r = void 0;
    const o = t.faces;

    for (i = 0; i < o.length; i++) {
      const t = o[i];
      t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = {
        start: 3 * i,
        materialIndex: r
      });
    }

    void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e;
  },
  fromGeometry: function (t) {
    const e = t.faces,
          n = t.vertices,
          r = t.faceVertexUvs,
          o = r[0] && r[0].length > 0,
          s = r[1] && r[1].length > 0,
          a = t.morphTargets,
          c = a.length;
    let l;

    if (c > 0) {
      l = [];

      for (let t = 0; t < c; t++) l[t] = {
        name: a[t].name,
        data: []
      };

      this.morphTargets.position = l;
    }

    const u = t.morphNormals,
          h = u.length;
    let d;

    if (h > 0) {
      d = [];

      for (let t = 0; t < h; t++) d[t] = {
        name: u[t].name,
        data: []
      };

      this.morphTargets.normal = d;
    }

    const p = t.skinIndices,
          f = t.skinWeights,
          m = p.length === n.length,
          g = f.length === n.length;
    n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");

    for (let t = 0; t < e.length; t++) {
      const v = e[t];
      this.vertices.push(n[v.a], n[v.b], n[v.c]);
      const y = v.vertexNormals;
      if (3 === y.length) this.normals.push(y[0], y[1], y[2]);else {
        const t = v.normal;
        this.normals.push(t, t, t);
      }
      const x = v.vertexColors;
      if (3 === x.length) this.colors.push(x[0], x[1], x[2]);else {
        const t = v.color;
        this.colors.push(t, t, t);
      }

      if (!0 === o) {
        const e = r[0][t];
        void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t), this.uvs.push(new i(), new i(), new i()));
      }

      if (!0 === s) {
        const e = r[1][t];
        void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t), this.uvs2.push(new i(), new i(), new i()));
      }

      for (let t = 0; t < c; t++) {
        const e = a[t].vertices;
        l[t].data.push(e[v.a], e[v.b], e[v.c]);
      }

      for (let e = 0; e < h; e++) {
        const n = u[e].vertexNormals[t];
        d[e].data.push(n.a, n.b, n.c);
      }

      m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]);
    }

    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this;
  }
});
let te = 1;
const ee = new M(),
      ne = new U(),
      ie = new m(),
      re = new nt(),
      oe = new nt(),
      se = new m();

function ae() {
  Object.defineProperty(this, "id", {
    value: te += 2
  }), this.uuid = n.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
    start: 0,
    count: 1 / 0
  }, this.userData = {};
}

ae.prototype = Object.assign(Object.create(t.prototype), {
  constructor: ae,
  isBufferGeometry: !0,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (t) {
    Array.isArray(t) ? this.index = new ($t(t) > 65535 ? Zt : Xt)(t, 1) : this.index = t;
  },
  getAttribute: function (t) {
    return this.attributes[t];
  },
  setAttribute: function (t, e) {
    return this.attributes[t] = e, this;
  },
  deleteAttribute: function (t) {
    return delete this.attributes[t], this;
  },
  addGroup: function (t, e, n) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: void 0 !== n ? n : 0
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  },
  applyMatrix4: function (t) {
    const e = this.attributes.position;
    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
    const n = this.attributes.normal;

    if (void 0 !== n) {
      const e = new r().getNormalMatrix(t);
      n.applyNormalMatrix(e), n.needsUpdate = !0;
    }

    const i = this.attributes.tangent;
    return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
  },
  rotateX: function (t) {
    return ee.makeRotationX(t), this.applyMatrix4(ee), this;
  },
  rotateY: function (t) {
    return ee.makeRotationY(t), this.applyMatrix4(ee), this;
  },
  rotateZ: function (t) {
    return ee.makeRotationZ(t), this.applyMatrix4(ee), this;
  },
  translate: function (t, e, n) {
    return ee.makeTranslation(t, e, n), this.applyMatrix4(ee), this;
  },
  scale: function (t, e, n) {
    return ee.makeScale(t, e, n), this.applyMatrix4(ee), this;
  },
  lookAt: function (t) {
    return ne.lookAt(t), ne.updateMatrix(), this.applyMatrix4(ne.matrix), this;
  },
  center: function () {
    return this.computeBoundingBox(), this.boundingBox.getCenter(ie).negate(), this.translate(ie.x, ie.y, ie.z), this;
  },
  setFromObject: function (t) {
    const e = t.geometry;

    if (t.isPoints || t.isLine) {
      const t = new Jt(3 * e.vertices.length, 3),
            n = new Jt(3 * e.colors.length, 3);

      if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
        const t = new Jt(e.lineDistances.length, 1);
        this.setAttribute("lineDistance", t.copyArray(e.lineDistances));
      }

      null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone());
    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);

    return this;
  },
  setFromPoints: function (t) {
    const e = [];

    for (let n = 0, i = t.length; n < i; n++) {
      const i = t[n];
      e.push(i.x, i.y, i.z || 0);
    }

    return this.setAttribute("position", new Jt(e, 3)), this;
  },
  updateFromObject: function (t) {
    let e = t.geometry;

    if (t.isMesh) {
      let t = e.__directGeometry;
      if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e);
      t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t;
    }

    if (!0 === e.verticesNeedUpdate) {
      const t = this.attributes.position;
      void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1;
    }

    if (!0 === e.normalsNeedUpdate) {
      const t = this.attributes.normal;
      void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1;
    }

    if (!0 === e.colorsNeedUpdate) {
      const t = this.attributes.color;
      void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1;
    }

    if (e.uvsNeedUpdate) {
      const t = this.attributes.uv;
      void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1;
    }

    if (e.lineDistancesNeedUpdate) {
      const t = this.attributes.lineDistance;
      void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1;
    }

    return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this;
  },
  fromGeometry: function (t) {
    return t.__directGeometry = new Kt().fromGeometry(t), this.fromDirectGeometry(t.__directGeometry);
  },
  fromDirectGeometry: function (t) {
    const e = new Float32Array(3 * t.vertices.length);

    if (this.setAttribute("position", new Gt(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
      const e = new Float32Array(3 * t.normals.length);
      this.setAttribute("normal", new Gt(e, 3).copyVector3sArray(t.normals));
    }

    if (t.colors.length > 0) {
      const e = new Float32Array(3 * t.colors.length);
      this.setAttribute("color", new Gt(e, 3).copyColorsArray(t.colors));
    }

    if (t.uvs.length > 0) {
      const e = new Float32Array(2 * t.uvs.length);
      this.setAttribute("uv", new Gt(e, 2).copyVector2sArray(t.uvs));
    }

    if (t.uvs2.length > 0) {
      const e = new Float32Array(2 * t.uvs2.length);
      this.setAttribute("uv2", new Gt(e, 2).copyVector2sArray(t.uvs2));
    }

    this.groups = t.groups;

    for (const e in t.morphTargets) {
      const n = [],
            i = t.morphTargets[e];

      for (let t = 0, e = i.length; t < e; t++) {
        const e = i[t],
              r = new Jt(3 * e.data.length, 3);
        r.name = e.name, n.push(r.copyVector3sArray(e.data));
      }

      this.morphAttributes[e] = n;
    }

    if (t.skinIndices.length > 0) {
      const e = new Jt(4 * t.skinIndices.length, 4);
      this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices));
    }

    if (t.skinWeights.length > 0) {
      const e = new Jt(4 * t.skinWeights.length, 4);
      this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights));
    }

    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this;
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new nt());
    const t = this.attributes.position,
          e = this.morphAttributes.position;

    if (void 0 !== t) {
      if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) {
        const n = e[t];
        re.setFromBufferAttribute(n), this.morphTargetsRelative ? (se.addVectors(this.boundingBox.min, re.min), this.boundingBox.expandByPoint(se), se.addVectors(this.boundingBox.max, re.max), this.boundingBox.expandByPoint(se)) : (this.boundingBox.expandByPoint(re.min), this.boundingBox.expandByPoint(re.max));
      }
    } else this.boundingBox.makeEmpty();

    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  },
  computeBoundingSphere: function () {
    null === this.boundingSphere && (this.boundingSphere = new ot());
    const t = this.attributes.position,
          e = this.morphAttributes.position;

    if (t) {
      const n = this.boundingSphere.center;
      if (re.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) {
        const n = e[t];
        oe.setFromBufferAttribute(n), this.morphTargetsRelative ? (se.addVectors(re.min, oe.min), re.expandByPoint(se), se.addVectors(re.max, oe.max), re.expandByPoint(se)) : (re.expandByPoint(oe.min), re.expandByPoint(oe.max));
      }
      re.getCenter(n);
      let i = 0;

      for (let e = 0, r = t.count; e < r; e++) se.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(se));

      if (e) for (let r = 0, o = e.length; r < o; r++) {
        const o = e[r],
              s = this.morphTargetsRelative;

        for (let e = 0, r = o.count; e < r; e++) se.fromBufferAttribute(o, e), s && (ie.fromBufferAttribute(t, e), se.add(ie)), i = Math.max(i, n.distanceToSquared(se));
      }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeFaceNormals: function () {},
  computeVertexNormals: function () {
    const t = this.index,
          e = this.getAttribute("position");

    if (void 0 !== e) {
      let n = this.getAttribute("normal");
      if (void 0 === n) n = new Gt(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
      const i = new m(),
            r = new m(),
            o = new m(),
            s = new m(),
            a = new m(),
            c = new m(),
            l = new m(),
            u = new m();
      if (t) for (let h = 0, d = t.count; h < d; h += 3) {
        const d = t.getX(h + 0),
              p = t.getX(h + 1),
              f = t.getX(h + 2);
        i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), o.fromBufferAttribute(e, f), l.subVectors(o, r), u.subVectors(i, r), l.cross(u), s.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), c.fromBufferAttribute(n, f), s.add(l), a.add(l), c.add(l), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, c.x, c.y, c.z);
      } else for (let t = 0, s = e.count; t < s; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), l.subVectors(o, r), u.subVectors(i, r), l.cross(u), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  },
  merge: function (t, e) {
    if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
    const n = this.attributes;

    for (const i in n) {
      if (void 0 === t.attributes[i]) continue;
      const r = n[i].array,
            o = t.attributes[i],
            s = o.array,
            a = o.itemSize * e,
            c = Math.min(s.length, r.length - a);

      for (let t = 0, e = a; t < c; t++, e++) r[e] = s[t];
    }

    return this;
  },
  normalizeNormals: function () {
    const t = this.attributes.normal;

    for (let e = 0, n = t.count; e < n; e++) se.fromBufferAttribute(t, e), se.normalize(), t.setXYZ(e, se.x, se.y, se.z);
  },
  toNonIndexed: function () {
    function t(t, e) {
      const n = t.array,
            i = t.itemSize,
            r = t.normalized,
            o = new n.constructor(e.length * i);
      let s = 0,
          a = 0;

      for (let t = 0, r = e.length; t < r; t++) {
        s = e[t] * i;

        for (let t = 0; t < i; t++) o[a++] = n[s++];
      }

      return new Gt(o, i, r);
    }

    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    const e = new ae(),
          n = this.index.array,
          i = this.attributes;

    for (const r in i) {
      const o = t(i[r], n);
      e.setAttribute(r, o);
    }

    const r = this.morphAttributes;

    for (const i in r) {
      const o = [],
            s = r[i];

      for (let e = 0, i = s.length; e < i; e++) {
        const i = t(s[e], n);
        o.push(i);
      }

      e.morphAttributes[i] = o;
    }

    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;

    for (let t = 0, n = o.length; t < n; t++) {
      const n = o[t];
      e.addGroup(n.start, n.count, n.materialIndex);
    }

    return e;
  },
  toJSON: function () {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };

    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
      const e = this.parameters;

      for (const n in e) void 0 !== e[n] && (t[n] = e[n]);

      return t;
    }

    t.data = {
      attributes: {}
    };
    const e = this.index;
    null !== e && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const n = this.attributes;

    for (const e in n) {
      const i = n[e],
            r = i.toJSON(t.data);
      "" !== i.name && (r.name = i.name), t.data.attributes[e] = r;
    }

    const i = {};
    let r = !1;

    for (const e in this.morphAttributes) {
      const n = this.morphAttributes[e],
            o = [];

      for (let e = 0, i = n.length; e < i; e++) {
        const i = n[e],
              r = i.toJSON(t.data);
        "" !== i.name && (r.name = i.name), o.push(r);
      }

      o.length > 0 && (i[e] = o, r = !0);
    }

    r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const s = this.boundingSphere;
    return null !== s && (t.data.boundingSphere = {
      center: s.center.toArray(),
      radius: s.radius
    }), t;
  },
  clone: function () {
    return new ae().copy(this);
  },
  copy: function (t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const n = t.index;
    null !== n && this.setIndex(n.clone(e));
    const i = t.attributes;

    for (const t in i) {
      const n = i[t];
      this.setAttribute(t, n.clone(e));
    }

    const r = t.morphAttributes;

    for (const t in r) {
      const n = [],
            i = r[t];

      for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));

      this.morphAttributes[t] = n;
    }

    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;

    for (let t = 0, e = o.length; t < e; t++) {
      const e = o[t];
      this.addGroup(e.start, e.count, e.materialIndex);
    }

    const s = t.boundingBox;
    null !== s && (this.boundingBox = s.clone());
    const a = t.boundingSphere;
    return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: "dispose"
    });
  }
});

const ce = new M(),
      le = new pt(),
      ue = new ot(),
      he = new m(),
      de = new m(),
      pe = new m(),
      fe = new m(),
      me = new m(),
      ge = new m(),
      ve = new m(),
      ye = new m(),
      xe = new m(),
      _e = new i(),
      be = new i(),
      we = new i(),
      Me = new m(),
      Se = new m();

function Ee(t, e) {
  U.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ae(), this.material = void 0 !== e ? e : new Ht(), this.updateMorphTargets();
}

function Te(t, e, n, i, r, o, s, a) {
  let c;
  if (c = 1 === e.side ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, 2 !== e.side, a), null === c) return null;
  Se.copy(a), Se.applyMatrix4(t.matrixWorld);
  const l = n.ray.origin.distanceTo(Se);
  return l < n.near || l > n.far ? null : {
    distance: l,
    point: Se.clone(),
    object: t
  };
}

function Ae(t, e, n, r, o, s, a, c, l, u, h, d) {
  he.fromBufferAttribute(o, u), de.fromBufferAttribute(o, h), pe.fromBufferAttribute(o, d);
  const p = t.morphTargetInfluences;

  if (e.morphTargets && s && p) {
    ve.set(0, 0, 0), ye.set(0, 0, 0), xe.set(0, 0, 0);

    for (let t = 0, e = s.length; t < e; t++) {
      const e = p[t],
            n = s[t];
      0 !== e && (fe.fromBufferAttribute(n, u), me.fromBufferAttribute(n, h), ge.fromBufferAttribute(n, d), a ? (ve.addScaledVector(fe, e), ye.addScaledVector(me, e), xe.addScaledVector(ge, e)) : (ve.addScaledVector(fe.sub(he), e), ye.addScaledVector(me.sub(de), e), xe.addScaledVector(ge.sub(pe), e)));
    }

    he.add(ve), de.add(ye), pe.add(xe);
  }

  t.isSkinnedMesh && (t.boneTransform(u, he), t.boneTransform(h, de), t.boneTransform(d, pe));
  const f = Te(t, e, n, r, he, de, pe, Me);

  if (f) {
    c && (_e.fromBufferAttribute(c, u), be.fromBufferAttribute(c, h), we.fromBufferAttribute(c, d), f.uv = Lt.getUV(Me, he, de, pe, _e, be, we, new i())), l && (_e.fromBufferAttribute(l, u), be.fromBufferAttribute(l, h), we.fromBufferAttribute(l, d), f.uv2 = Lt.getUV(Me, he, de, pe, _e, be, we, new i()));
    const t = new zt(u, h, d);
    Lt.getNormal(he, de, pe, t.normal), f.face = t;
  }

  return f;
}

Ee.prototype = Object.assign(Object.create(U.prototype), {
  constructor: Ee,
  isMesh: !0,
  copy: function (t) {
    return U.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
  },
  updateMorphTargets: function () {
    const t = this.geometry;

    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
            n = Object.keys(e);

      if (n.length > 0) {
        const t = e[n[0]];

        if (void 0 !== t) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};

          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  raycast: function (t, e) {
    const n = this.geometry,
          r = this.material,
          o = this.matrixWorld;
    if (void 0 === r) return;
    if (null === n.boundingSphere && n.computeBoundingSphere(), ue.copy(n.boundingSphere), ue.applyMatrix4(o), !1 === t.ray.intersectsSphere(ue)) return;
    if (ce.getInverse(o), le.copy(t.ray).applyMatrix4(ce), null !== n.boundingBox && !1 === le.intersectsBox(n.boundingBox)) return;
    let s;

    if (n.isBufferGeometry) {
      const i = n.index,
            o = n.attributes.position,
            a = n.morphAttributes.position,
            c = n.morphTargetsRelative,
            l = n.attributes.uv,
            u = n.attributes.uv2,
            h = n.groups,
            d = n.drawRange;
      if (null !== i) {
        if (Array.isArray(r)) for (let n = 0, p = h.length; n < p; n++) {
          const p = h[n],
                f = r[p.materialIndex];

          for (let n = Math.max(p.start, d.start), r = Math.min(p.start + p.count, d.start + d.count); n < r; n += 3) {
            const r = i.getX(n),
                  h = i.getX(n + 1),
                  d = i.getX(n + 2);
            s = Ae(this, f, t, le, o, a, c, l, u, r, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s));
          }
        } else for (let n = Math.max(0, d.start), h = Math.min(i.count, d.start + d.count); n < h; n += 3) {
          const h = i.getX(n),
                d = i.getX(n + 1),
                p = i.getX(n + 2);
          s = Ae(this, r, t, le, o, a, c, l, u, h, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s));
        }
      } else if (void 0 !== o) if (Array.isArray(r)) for (let n = 0, i = h.length; n < i; n++) {
        const i = h[n],
              p = r[i.materialIndex];

        for (let n = Math.max(i.start, d.start), r = Math.min(i.start + i.count, d.start + d.count); n < r; n += 3) s = Ae(this, p, t, le, o, a, c, l, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, e.push(s));
      } else for (let n = Math.max(0, d.start), i = Math.min(o.count, d.start + d.count); n < i; n += 3) s = Ae(this, r, t, le, o, a, c, l, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s));
    } else if (n.isGeometry) {
      const o = Array.isArray(r),
            a = n.vertices,
            c = n.faces;
      let l;
      const u = n.faceVertexUvs[0];
      u.length > 0 && (l = u);

      for (let n = 0, u = c.length; n < u; n++) {
        const u = c[n],
              h = o ? r[u.materialIndex] : r;
        if (void 0 === h) continue;
        const d = a[u.a],
              p = a[u.b],
              f = a[u.c];

        if (s = Te(this, h, t, le, d, p, f, Me), s) {
          if (l && l[n]) {
            const t = l[n];
            _e.copy(t[0]), be.copy(t[1]), we.copy(t[2]), s.uv = Lt.getUV(Me, d, p, f, _e, be, we, new i());
          }

          s.face = u, s.faceIndex = n, e.push(s);
        }
      }
    }
  }
});
let Le = 0;
const Ce = new M(),
      Re = new U(),
      Pe = new m();

function Oe() {
  Object.defineProperty(this, "id", {
    value: Le += 2
  }), this.uuid = n.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
}

Oe.prototype = Object.assign(Object.create(t.prototype), {
  constructor: Oe,
  isGeometry: !0,
  applyMatrix4: function (t) {
    const e = new r().getNormalMatrix(t);

    for (let e = 0, n = this.vertices.length; e < n; e++) this.vertices[e].applyMatrix4(t);

    for (let t = 0, n = this.faces.length; t < n; t++) {
      const n = this.faces[t];
      n.normal.applyMatrix3(e).normalize();

      for (let t = 0, i = n.vertexNormals.length; t < i; t++) n.vertexNormals[t].applyMatrix3(e).normalize();
    }

    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
  },
  rotateX: function (t) {
    return Ce.makeRotationX(t), this.applyMatrix4(Ce), this;
  },
  rotateY: function (t) {
    return Ce.makeRotationY(t), this.applyMatrix4(Ce), this;
  },
  rotateZ: function (t) {
    return Ce.makeRotationZ(t), this.applyMatrix4(Ce), this;
  },
  translate: function (t, e, n) {
    return Ce.makeTranslation(t, e, n), this.applyMatrix4(Ce), this;
  },
  scale: function (t, e, n) {
    return Ce.makeScale(t, e, n), this.applyMatrix4(Ce), this;
  },
  lookAt: function (t) {
    return Re.lookAt(t), Re.updateMatrix(), this.applyMatrix4(Re.matrix), this;
  },
  fromBufferGeometry: function (t) {
    const e = this,
          n = null !== t.index ? t.index : void 0,
          r = t.attributes;
    if (void 0 === r.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
    const o = r.position,
          s = r.normal,
          a = r.color,
          c = r.uv,
          l = r.uv2;
    void 0 !== l && (this.faceVertexUvs[1] = []);

    for (let t = 0; t < o.count; t++) e.vertices.push(new m().fromBufferAttribute(o, t)), void 0 !== a && e.colors.push(new Ot().fromBufferAttribute(a, t));

    function u(t, n, r, o) {
      const u = void 0 === a ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()],
            h = new zt(t, n, r, void 0 === s ? [] : [new m().fromBufferAttribute(s, t), new m().fromBufferAttribute(s, n), new m().fromBufferAttribute(s, r)], u, o);
      e.faces.push(h), void 0 !== c && e.faceVertexUvs[0].push([new i().fromBufferAttribute(c, t), new i().fromBufferAttribute(c, n), new i().fromBufferAttribute(c, r)]), void 0 !== l && e.faceVertexUvs[1].push([new i().fromBufferAttribute(l, t), new i().fromBufferAttribute(l, n), new i().fromBufferAttribute(l, r)]);
    }

    const h = t.groups;
    if (h.length > 0) for (let t = 0; t < h.length; t++) {
      const e = h[t],
            i = e.start;

      for (let t = i, r = i + e.count; t < r; t += 3) void 0 !== n ? u(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex) : u(t, t + 1, t + 2, e.materialIndex);
    } else if (void 0 !== n) for (let t = 0; t < n.count; t += 3) u(n.getX(t), n.getX(t + 1), n.getX(t + 2));else for (let t = 0; t < o.count; t += 3) u(t, t + 1, t + 2);
    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this;
  },
  center: function () {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Pe).negate(), this.translate(Pe.x, Pe.y, Pe.z), this;
  },
  normalize: function () {
    this.computeBoundingSphere();
    const t = this.boundingSphere.center,
          e = this.boundingSphere.radius,
          n = 0 === e ? 1 : 1 / e,
          i = new M();
    return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this;
  },
  computeFaceNormals: function () {
    const t = new m(),
          e = new m();

    for (let n = 0, i = this.faces.length; n < i; n++) {
      const i = this.faces[n],
            r = this.vertices[i.a],
            o = this.vertices[i.b],
            s = this.vertices[i.c];
      t.subVectors(s, o), e.subVectors(r, o), t.cross(e), t.normalize(), i.normal.copy(t);
    }
  },
  computeVertexNormals: function (t) {
    void 0 === t && (t = !0);
    const e = new Array(this.vertices.length);

    for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new m();

    if (t) {
      const t = new m(),
            n = new m();

      for (let i = 0, r = this.faces.length; i < r; i++) {
        const r = this.faces[i],
              o = this.vertices[r.a],
              s = this.vertices[r.b],
              a = this.vertices[r.c];
        t.subVectors(a, s), n.subVectors(o, s), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t);
      }
    } else {
      this.computeFaceNormals();

      for (let t = 0, n = this.faces.length; t < n; t++) {
        const n = this.faces[t];
        e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal);
      }
    }

    for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize();

    for (let t = 0, n = this.faces.length; t < n; t++) {
      const n = this.faces[t],
            i = n.vertexNormals;
      3 === i.length ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c])) : (i[0] = e[n.a].clone(), i[1] = e[n.b].clone(), i[2] = e[n.c].clone());
    }

    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function () {
    this.computeFaceNormals();

    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t],
            n = e.vertexNormals;
      3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone());
    }

    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function () {
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t];
      e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []);

      for (let t = 0, n = e.vertexNormals.length; t < n; t++) e.__originalVertexNormals[t] ? e.__originalVertexNormals[t].copy(e.vertexNormals[t]) : e.__originalVertexNormals[t] = e.vertexNormals[t].clone();
    }

    const t = new Oe();
    t.faces = this.faces;

    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
      if (!this.morphNormals[e]) {
        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
        const t = this.morphNormals[e].faceNormals,
              n = this.morphNormals[e].vertexNormals;

        for (let e = 0, i = this.faces.length; e < i; e++) {
          const e = new m(),
                i = {
            a: new m(),
            b: new m(),
            c: new m()
          };
          t.push(e), n.push(i);
        }
      }

      const n = this.morphNormals[e];
      t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();

      for (let t = 0, e = this.faces.length; t < e; t++) {
        const e = this.faces[t],
              i = n.faceNormals[t],
              r = n.vertexNormals[t];
        i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2]);
      }
    }

    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t];
      e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;
    }
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new nt()), this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    null === this.boundingSphere && (this.boundingSphere = new ot()), this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (t, e, n) {
    if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
    let i,
        o = this.vertices.length,
        s = this.vertices,
        a = t.vertices,
        c = this.faces,
        l = t.faces,
        u = this.colors,
        h = t.colors;
    void 0 === n && (n = 0), void 0 !== e && (i = new r().getNormalMatrix(e));

    for (let t = 0, n = a.length; t < n; t++) {
      const n = a[t].clone();
      void 0 !== e && n.applyMatrix4(e), s.push(n);
    }

    for (let t = 0, e = h.length; t < e; t++) u.push(h[t].clone());

    for (let t = 0, e = l.length; t < e; t++) {
      let e,
          r,
          s,
          a = l[t],
          u = a.vertexNormals,
          h = a.vertexColors;
      e = new zt(a.a + o, a.b + o, a.c + o), e.normal.copy(a.normal), void 0 !== i && e.normal.applyMatrix3(i).normalize();

      for (let t = 0, n = u.length; t < n; t++) r = u[t].clone(), void 0 !== i && r.applyMatrix3(i).normalize(), e.vertexNormals.push(r);

      e.color.copy(a.color);

      for (let t = 0, n = h.length; t < n; t++) s = h[t], e.vertexColors.push(s.clone());

      e.materialIndex = a.materialIndex + n, c.push(e);
    }

    for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
      const n = t.faceVertexUvs[e];
      void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);

      for (let t = 0, i = n.length; t < i; t++) {
        const i = n[t],
              r = [];

        for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone());

        this.faceVertexUvs[e].push(r);
      }
    }
  },
  mergeMesh: function (t) {
    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
  },
  mergeVertices: function () {
    const t = {},
          e = [],
          n = [],
          i = Math.pow(10, 4);

    for (let r = 0, o = this.vertices.length; r < o; r++) {
      const o = this.vertices[r],
            s = Math.round(o.x * i) + "_" + Math.round(o.y * i) + "_" + Math.round(o.z * i);
      void 0 === t[s] ? (t[s] = r, e.push(this.vertices[r]), n[r] = e.length - 1) : n[r] = n[t[s]];
    }

    const r = [];

    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t];
      e.a = n[e.a], e.b = n[e.b], e.c = n[e.c];
      const i = [e.a, e.b, e.c];

      for (let e = 0; e < 3; e++) if (i[e] === i[(e + 1) % 3]) {
        r.push(t);
        break;
      }
    }

    for (let t = r.length - 1; t >= 0; t--) {
      const e = r[t];
      this.faces.splice(e, 1);

      for (let t = 0, n = this.faceVertexUvs.length; t < n; t++) this.faceVertexUvs[t].splice(e, 1);
    }

    const o = this.vertices.length - e.length;
    return this.vertices = e, o;
  },
  setFromPoints: function (t) {
    this.vertices = [];

    for (let e = 0, n = t.length; e < n; e++) {
      const n = t[e];
      this.vertices.push(new m(n.x, n.y, n.z || 0));
    }

    return this;
  },
  sortFacesByMaterialIndex: function () {
    const t = this.faces,
          e = t.length;

    for (let n = 0; n < e; n++) t[n]._id = n;

    t.sort(function (t, e) {
      return t.materialIndex - e.materialIndex;
    });
    const n = this.faceVertexUvs[0],
          i = this.faceVertexUvs[1];
    let r, o;
    n && n.length === e && (r = []), i && i.length === e && (o = []);

    for (let s = 0; s < e; s++) {
      const e = t[s]._id;
      r && r.push(n[e]), o && o.push(i[e]);
    }

    r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o);
  },
  toJSON: function () {
    const t = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };

    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
      const e = this.parameters;

      for (const n in e) void 0 !== e[n] && (t[n] = e[n]);

      return t;
    }

    const e = [];

    for (let t = 0; t < this.vertices.length; t++) {
      const n = this.vertices[t];
      e.push(n.x, n.y, n.z);
    }

    const n = [],
          i = [],
          r = {},
          o = [],
          s = {},
          a = [],
          c = {};

    for (let t = 0; t < this.faces.length; t++) {
      const e = this.faces[t],
            i = !0,
            r = !1,
            o = void 0 !== this.faceVertexUvs[0][t],
            s = e.normal.length() > 0,
            a = e.vertexNormals.length > 0,
            c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
            p = e.vertexColors.length > 0;
      let f = 0;

      if (f = l(f, 0, 0), f = l(f, 1, i), f = l(f, 2, r), f = l(f, 3, o), f = l(f, 4, s), f = l(f, 5, a), f = l(f, 6, c), f = l(f, 7, p), n.push(f), n.push(e.a, e.b, e.c), n.push(e.materialIndex), o) {
        const e = this.faceVertexUvs[0][t];
        n.push(d(e[0]), d(e[1]), d(e[2]));
      }

      if (s && n.push(u(e.normal)), a) {
        const t = e.vertexNormals;
        n.push(u(t[0]), u(t[1]), u(t[2]));
      }

      if (c && n.push(h(e.color)), p) {
        const t = e.vertexColors;
        n.push(h(t[0]), h(t[1]), h(t[2]));
      }
    }

    function l(t, e, n) {
      return n ? t | 1 << e : t & ~(1 << e);
    }

    function u(t) {
      const e = t.x.toString() + t.y.toString() + t.z.toString();
      return void 0 !== r[e] || (r[e] = i.length / 3, i.push(t.x, t.y, t.z)), r[e];
    }

    function h(t) {
      const e = t.r.toString() + t.g.toString() + t.b.toString();
      return void 0 !== s[e] || (s[e] = o.length, o.push(t.getHex())), s[e];
    }

    function d(t) {
      const e = t.x.toString() + t.y.toString();
      return void 0 !== c[e] || (c[e] = a.length / 2, a.push(t.x, t.y)), c[e];
    }

    return t.data = {}, t.data.vertices = e, t.data.normals = i, o.length > 0 && (t.data.colors = o), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t;
  },
  clone: function () {
    return new Oe().copy(this);
  },
  copy: function (t) {
    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
    const e = t.vertices;

    for (let t = 0, n = e.length; t < n; t++) this.vertices.push(e[t].clone());

    const n = t.colors;

    for (let t = 0, e = n.length; t < e; t++) this.colors.push(n[t].clone());

    const i = t.faces;

    for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone());

    for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
      const n = t.faceVertexUvs[e];
      void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);

      for (let t = 0, i = n.length; t < i; t++) {
        const i = n[t],
              r = [];

        for (let t = 0, e = i.length; t < e; t++) {
          const e = i[t];
          r.push(e.clone());
        }

        this.faceVertexUvs[e].push(r);
      }
    }

    const r = t.morphTargets;

    for (let t = 0, e = r.length; t < e; t++) {
      const e = {};

      if (e.name = r[t].name, void 0 !== r[t].vertices) {
        e.vertices = [];

        for (let n = 0, i = r[t].vertices.length; n < i; n++) e.vertices.push(r[t].vertices[n].clone());
      }

      if (void 0 !== r[t].normals) {
        e.normals = [];

        for (let n = 0, i = r[t].normals.length; n < i; n++) e.normals.push(r[t].normals[n].clone());
      }

      this.morphTargets.push(e);
    }

    const o = t.morphNormals;

    for (let t = 0, e = o.length; t < e; t++) {
      const e = {};

      if (void 0 !== o[t].vertexNormals) {
        e.vertexNormals = [];

        for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) {
          const i = o[t].vertexNormals[n],
                r = {};
          r.a = i.a.clone(), r.b = i.b.clone(), r.c = i.c.clone(), e.vertexNormals.push(r);
        }
      }

      if (void 0 !== o[t].faceNormals) {
        e.faceNormals = [];

        for (let n = 0, i = o[t].faceNormals.length; n < i; n++) e.faceNormals.push(o[t].faceNormals[n].clone());
      }

      this.morphNormals.push(e);
    }

    const s = t.skinWeights;

    for (let t = 0, e = s.length; t < e; t++) this.skinWeights.push(s[t].clone());

    const a = t.skinIndices;

    for (let t = 0, e = a.length; t < e; t++) this.skinIndices.push(a[t].clone());

    const c = t.lineDistances;

    for (let t = 0, e = c.length; t < e; t++) this.lineDistances.push(c[t]);

    const l = t.boundingBox;
    null !== l && (this.boundingBox = l.clone());
    const u = t.boundingSphere;
    return null !== u && (this.boundingSphere = u.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: "dispose"
    });
  }
});

class Ne extends ae {
  constructor(t, e, n, i, r, o) {
    super(), this.type = "BoxBufferGeometry", this.parameters = {
      width: t,
      height: e,
      depth: n,
      widthSegments: i,
      heightSegments: r,
      depthSegments: o
    };
    const s = this;
    t = t || 1, e = e || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
    const a = [],
          c = [],
          l = [],
          u = [];
    let h = 0,
        d = 0;

    function p(t, e, n, i, r, o, p, f, g, v, y) {
      const x = o / g,
            _ = p / v,
            b = o / 2,
            w = p / 2,
            M = f / 2,
            S = g + 1,
            E = v + 1;

      let T = 0,
          A = 0;
      const L = new m();

      for (let o = 0; o < E; o++) {
        const s = o * _ - w;

        for (let a = 0; a < S; a++) {
          const h = a * x - b;
          L[t] = h * i, L[e] = s * r, L[n] = M, c.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[n] = f > 0 ? 1 : -1, l.push(L.x, L.y, L.z), u.push(a / g), u.push(1 - o / v), T += 1;
        }
      }

      for (let t = 0; t < v; t++) for (let e = 0; e < g; e++) {
        const n = h + e + S * t,
              i = h + e + S * (t + 1),
              r = h + (e + 1) + S * (t + 1),
              o = h + (e + 1) + S * t;
        a.push(n, i, o), a.push(i, r, o), A += 6;
      }

      s.addGroup(d, A, y), d += A, h += T;
    }

    p("z", "y", "x", -1, -1, n, e, t, o, r, 0), p("z", "y", "x", 1, -1, n, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, o, 2), p("x", "z", "y", 1, -1, t, n, -e, i, o, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Jt(c, 3)), this.setAttribute("normal", new Jt(l, 3)), this.setAttribute("uv", new Jt(u, 2));
  }

}

function De(t) {
  const e = {};

  for (const n in t) {
    e[n] = {};

    for (const i in t[n]) {
      const r = t[n][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r;
    }
  }

  return e;
}

function Ie(t) {
  const e = {};

  for (let n = 0; n < t.length; n++) {
    const i = De(t[n]);

    for (const t in i) e[t] = i[t];
  }

  return e;
}

const ze = {
  clone: De,
  merge: Ie
};

function Be(t) {
  kt.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
    derivatives: !1,
    fragDepth: !1,
    drawBuffers: !1,
    shaderTextureLOD: !1
  }, this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
}

function ke() {
  U.call(this), this.type = "Camera", this.matrixWorldInverse = new M(), this.projectionMatrix = new M(), this.projectionMatrixInverse = new M();
}

function He(t, e, n, i) {
  ke.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}

function Fe(t, e, n) {
  if (U.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
  this.renderTarget = n;
  const i = new He(90, 1, t, e);
  i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new m(1, 0, 0)), this.add(i);
  const r = new He(90, 1, t, e);
  r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new m(-1, 0, 0)), this.add(r);
  const o = new He(90, 1, t, e);
  o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new m(0, 1, 0)), this.add(o);
  const s = new He(90, 1, t, e);
  s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new m(0, -1, 0)), this.add(s);
  const a = new He(90, 1, t, e);
  a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new m(0, 0, 1)), this.add(a);
  const c = new He(90, 1, t, e);
  c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new m(0, 0, -1)), this.add(c), this.update = function (t, e) {
    null === this.parent && this.updateMatrixWorld();
    const l = t.xr.enabled,
          u = t.getRenderTarget();
    t.xr.enabled = !1;
    const h = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = l;
  }, this.clear = function (t, e, i, r) {
    const o = t.getRenderTarget();

    for (let o = 0; o < 6; o++) t.setRenderTarget(n, o), t.clear(e, i, r);

    t.setRenderTarget(o);
  };
}

function Ue(t, e, n) {
  Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), u.call(this, t, t, e);
}

function Ge(t, e, n, i, r, o, s, a, l, u, h, d) {
  c.call(this, null, o, s, a, l, u, i, r, h, d), this.image = {
    data: t || null,
    width: e || 1,
    height: n || 1
  }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== u ? u : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0;
}

Be.prototype = Object.create(kt.prototype), Be.prototype.constructor = Be, Be.prototype.isShaderMaterial = !0, Be.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = De(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this;
}, Be.prototype.toJSON = function (t) {
  const e = kt.prototype.toJSON.call(this, t);
  e.uniforms = {};

  for (const n in this.uniforms) {
    const i = this.uniforms[n].value;
    i && i.isTexture ? e.uniforms[n] = {
      type: "t",
      value: i.toJSON(t).uuid
    } : i && i.isColor ? e.uniforms[n] = {
      type: "c",
      value: i.getHex()
    } : i && i.isVector2 ? e.uniforms[n] = {
      type: "v2",
      value: i.toArray()
    } : i && i.isVector3 ? e.uniforms[n] = {
      type: "v3",
      value: i.toArray()
    } : i && i.isVector4 ? e.uniforms[n] = {
      type: "v4",
      value: i.toArray()
    } : i && i.isMatrix3 ? e.uniforms[n] = {
      type: "m3",
      value: i.toArray()
    } : i && i.isMatrix4 ? e.uniforms[n] = {
      type: "m4",
      value: i.toArray()
    } : e.uniforms[n] = {
      value: i
    };
  }

  Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
  const n = {};

  for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);

  return Object.keys(n).length > 0 && (e.extensions = n), e;
}, ke.prototype = Object.assign(Object.create(U.prototype), {
  constructor: ke,
  isCamera: !0,
  copy: function (t, e) {
    return U.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
  },
  getWorldDirection: function (t) {
    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new m()), this.updateMatrixWorld(!0);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (t) {
    U.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  updateWorldMatrix: function (t, e) {
    U.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
}), He.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: He,
  isPerspectiveCamera: !0,
  copy: function (t, e) {
    return ke.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  },
  setFocalLength: function (t) {
    const e = .5 * this.getFilmHeight() / t;
    this.fov = 2 * n.RAD2DEG * Math.atan(e), this.updateProjectionMatrix();
  },
  getFocalLength: function () {
    const t = Math.tan(.5 * n.DEG2RAD * this.fov);
    return .5 * this.getFilmHeight() / t;
  },
  getEffectiveFOV: function () {
    return 2 * n.RAD2DEG * Math.atan(Math.tan(.5 * n.DEG2RAD * this.fov) / this.zoom);
  },
  getFilmWidth: function () {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function (t, e, n, i, r, o) {
    this.aspect = t / e, null === this.view && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    let t = this.near,
        e = t * Math.tan(.5 * n.DEG2RAD * this.fov) / this.zoom,
        i = 2 * e,
        r = this.aspect * i,
        o = -.5 * r,
        s = this.view;

    if (null !== this.view && this.view.enabled) {
      const t = s.fullWidth,
            n = s.fullHeight;
      o += s.offsetX * r / t, e -= s.offsetY * i / n, r *= s.width / t, i *= s.height / n;
    }

    const a = this.filmOffset;
    0 !== a && (o += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (t) {
    const e = U.prototype.toJSON.call(this, t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
}), Fe.prototype = Object.create(U.prototype), Fe.prototype.constructor = Fe, Ue.prototype = Object.create(u.prototype), Ue.prototype.constructor = Ue, Ue.prototype.isWebGLCubeRenderTarget = !0, Ue.prototype.fromEquirectangularTexture = function (t, e) {
  this.texture.type = e.type, this.texture.format = e.format, this.texture.encoding = e.encoding;
  const n = new G(),
        i = {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#include <common>", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV = equirectUv( direction );", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
  },
        r = new Be({
    name: "CubemapFromEquirect",
    uniforms: De(i.uniforms),
    vertexShader: i.vertexShader,
    fragmentShader: i.fragmentShader,
    side: 1,
    blending: 0
  });
  r.uniforms.tEquirect.value = e;
  const o = new Ee(new Ne(5, 5, 5), r);
  return n.add(o), new Fe(1, 10, this).update(t, n), o.geometry.dispose(), o.material.dispose(), this;
}, Ge.prototype = Object.create(c.prototype), Ge.prototype.constructor = Ge, Ge.prototype.isDataTexture = !0;
const je = new ot(),
      Ve = new m();

function We(t, e, n, i, r, o) {
  this.planes = [void 0 !== t ? t : new vt(), void 0 !== e ? e : new vt(), void 0 !== n ? n : new vt(), void 0 !== i ? i : new vt(), void 0 !== r ? r : new vt(), void 0 !== o ? o : new vt()];
}

Object.assign(We.prototype, {
  set: function (t, e, n, i, r, o) {
    const s = this.planes;
    return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    const e = this.planes;

    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);

    return this;
  },
  setFromProjectionMatrix: function (t) {
    const e = this.planes,
          n = t.elements,
          i = n[0],
          r = n[1],
          o = n[2],
          s = n[3],
          a = n[4],
          c = n[5],
          l = n[6],
          u = n[7],
          h = n[8],
          d = n[9],
          p = n[10],
          f = n[11],
          m = n[12],
          g = n[13],
          v = n[14],
          y = n[15];
    return e[0].setComponents(s - i, u - a, f - h, y - m).normalize(), e[1].setComponents(s + i, u + a, f + h, y + m).normalize(), e[2].setComponents(s + r, u + c, f + d, y + g).normalize(), e[3].setComponents(s - r, u - c, f - d, y - g).normalize(), e[4].setComponents(s - o, u - l, f - p, y - v).normalize(), e[5].setComponents(s + o, u + l, f + p, y + v).normalize(), this;
  },
  intersectsObject: function (t) {
    const e = t.geometry;
    return null === e.boundingSphere && e.computeBoundingSphere(), je.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(je);
  },
  intersectsSprite: function (t) {
    return je.center.set(0, 0, 0), je.radius = .7071067811865476, je.applyMatrix4(t.matrixWorld), this.intersectsSphere(je);
  },
  intersectsSphere: function (t) {
    const e = this.planes,
          n = t.center,
          i = -t.radius;

    for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1;

    return !0;
  },
  intersectsBox: function (t) {
    const e = this.planes;

    for (let n = 0; n < 6; n++) {
      const i = e[n];
      if (Ve.x = i.normal.x > 0 ? t.max.x : t.min.x, Ve.y = i.normal.y > 0 ? t.max.y : t.min.y, Ve.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Ve) < 0) return !1;
    }

    return !0;
  },
  containsPoint: function (t) {
    const e = this.planes;

    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;

    return !0;
  }
});
const qe = {
  common: {
    diffuse: {
      value: new Ot(15658734)
    },
    opacity: {
      value: 1
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new r()
    },
    uv2Transform: {
      value: new r()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1
    },
    refractionRatio: {
      value: .98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new i(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 25e-5
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2e3
    },
    fogColor: {
      value: new Ot(16777215)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    }
  },
  points: {
    diffuse: {
      value: new Ot(15658734)
    },
    opacity: {
      value: 1
    },
    size: {
      value: 1
    },
    scale: {
      value: 1
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new r()
    }
  },
  sprite: {
    diffuse: {
      value: new Ot(15658734)
    },
    opacity: {
      value: 1
    },
    center: {
      value: new i(.5, .5)
    },
    rotation: {
      value: 0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new r()
    }
  }
};

function Xe() {
  let t = null,
      e = !1,
      n = null,
      i = null;

  function r(e, o) {
    n(e, o), i = t.requestAnimationFrame(r);
  }

  return {
    start: function () {
      !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0);
    },
    stop: function () {
      t.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function (t) {
      n = t;
    },
    setContext: function (e) {
      t = e;
    }
  };
}

function Ye(t, e) {
  const n = e.isWebGL2,
        i = new WeakMap();
  return {
    get: function (t) {
      return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
    },
    remove: function (e) {
      e.isInterleavedBufferAttribute && (e = e.data);
      const n = i.get(e);
      n && (t.deleteBuffer(n.buffer), i.delete(e));
    },
    update: function (e, r) {
      e.isInterleavedBufferAttribute && (e = e.data);
      const o = i.get(e);
      void 0 === o ? i.set(e, function (e, n) {
        const i = e.array,
              r = e.usage,
              o = t.createBuffer();
        t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback();
        let s = 5126;
        return i instanceof Float32Array ? s = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? s = 5123 : i instanceof Int16Array ? s = 5122 : i instanceof Uint32Array ? s = 5125 : i instanceof Int32Array ? s = 5124 : i instanceof Int8Array ? s = 5120 : i instanceof Uint8Array && (s = 5121), {
          buffer: o,
          type: s,
          bytesPerElement: i.BYTES_PER_ELEMENT,
          version: e.version
        };
      }(e, r)) : o.version < e.version && (function (e, i, r) {
        const o = i.array,
              s = i.updateRange;
        t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1);
      }(o.buffer, e, r), o.version = e.version);
    }
  };
}

function Ze(t, e, n, i) {
  Oe.call(this), this.type = "PlaneGeometry", this.parameters = {
    width: t,
    height: e,
    widthSegments: n,
    heightSegments: i
  }, this.fromBufferGeometry(new Je(t, e, n, i)), this.mergeVertices();
}

function Je(t, e, n, i) {
  ae.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
    width: t,
    height: e,
    widthSegments: n,
    heightSegments: i
  };
  const r = (t = t || 1) / 2,
        o = (e = e || 1) / 2,
        s = Math.floor(n) || 1,
        a = Math.floor(i) || 1,
        c = s + 1,
        l = a + 1,
        u = t / s,
        h = e / a,
        d = [],
        p = [],
        f = [],
        m = [];

  for (let t = 0; t < l; t++) {
    const e = t * h - o;

    for (let n = 0; n < c; n++) {
      const i = n * u - r;
      p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / a);
    }
  }

  for (let t = 0; t < a; t++) for (let e = 0; e < s; e++) {
    const n = e + c * t,
          i = e + c * (t + 1),
          r = e + 1 + c * (t + 1),
          o = e + 1 + c * t;
    d.push(n, i, o), d.push(i, r, o);
  }

  this.setIndex(d), this.setAttribute("position", new Jt(p, 3)), this.setAttribute("normal", new Jt(f, 3)), this.setAttribute("uv", new Jt(m, 2));
}

Ze.prototype = Object.create(Oe.prototype), Ze.prototype.constructor = Ze, Je.prototype = Object.create(ae.prototype), Je.prototype.constructor = Je;
const Qe = {
  alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
  alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
  alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
  aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
  aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
  begin_vertex: "vec3 transformed = vec3( position );",
  beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
  bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
  bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
  clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
  clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
  clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
  clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
  color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
  color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
  color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
  color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
  common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
  cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
  defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
  displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
  displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
  emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
  emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
  encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
  envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
  envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
  envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
  envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
  envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
  envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
  fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
  fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
  fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
  fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
  gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
  lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
  lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
  lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
  lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
  lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
  lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
  lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
  lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
  lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
  lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
  lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
  lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
  lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
  logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
  logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
  logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
  logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
  map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
  map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
  map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
  map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
  metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
  metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
  morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
  morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
  morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
  normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
  normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
  normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
  clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
  clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
  clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
  packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
  premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
  project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
  dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
  dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
  roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
  roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
  shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
  shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
  shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
  shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
  skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
  skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
  skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
  skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
  specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
  specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
  tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
  tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
  uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
  uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
  uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
  uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
  uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
  uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
  worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
  background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
  background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
  cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
  cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
  depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
  depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
  distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
  distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
  equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
  equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
  linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
  linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
  meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
  meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
  meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
  meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
  normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
  points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
  points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
  shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
  shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
  sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
  sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
},
      Ke = {
  basic: {
    uniforms: Ie([qe.common, qe.specularmap, qe.envmap, qe.aomap, qe.lightmap, qe.fog]),
    vertexShader: Qe.meshbasic_vert,
    fragmentShader: Qe.meshbasic_frag
  },
  lambert: {
    uniforms: Ie([qe.common, qe.specularmap, qe.envmap, qe.aomap, qe.lightmap, qe.emissivemap, qe.fog, qe.lights, {
      emissive: {
        value: new Ot(0)
      }
    }]),
    vertexShader: Qe.meshlambert_vert,
    fragmentShader: Qe.meshlambert_frag
  },
  phong: {
    uniforms: Ie([qe.common, qe.specularmap, qe.envmap, qe.aomap, qe.lightmap, qe.emissivemap, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.fog, qe.lights, {
      emissive: {
        value: new Ot(0)
      },
      specular: {
        value: new Ot(1118481)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: Qe.meshphong_vert,
    fragmentShader: Qe.meshphong_frag
  },
  standard: {
    uniforms: Ie([qe.common, qe.envmap, qe.aomap, qe.lightmap, qe.emissivemap, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.roughnessmap, qe.metalnessmap, qe.fog, qe.lights, {
      emissive: {
        value: new Ot(0)
      },
      roughness: {
        value: 1
      },
      metalness: {
        value: 0
      },
      envMapIntensity: {
        value: 1
      }
    }]),
    vertexShader: Qe.meshphysical_vert,
    fragmentShader: Qe.meshphysical_frag
  },
  toon: {
    uniforms: Ie([qe.common, qe.aomap, qe.lightmap, qe.emissivemap, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.gradientmap, qe.fog, qe.lights, {
      emissive: {
        value: new Ot(0)
      }
    }]),
    vertexShader: Qe.meshtoon_vert,
    fragmentShader: Qe.meshtoon_frag
  },
  matcap: {
    uniforms: Ie([qe.common, qe.bumpmap, qe.normalmap, qe.displacementmap, qe.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: Qe.meshmatcap_vert,
    fragmentShader: Qe.meshmatcap_frag
  },
  points: {
    uniforms: Ie([qe.points, qe.fog]),
    vertexShader: Qe.points_vert,
    fragmentShader: Qe.points_frag
  },
  dashed: {
    uniforms: Ie([qe.common, qe.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: Qe.linedashed_vert,
    fragmentShader: Qe.linedashed_frag
  },
  depth: {
    uniforms: Ie([qe.common, qe.displacementmap]),
    vertexShader: Qe.depth_vert,
    fragmentShader: Qe.depth_frag
  },
  normal: {
    uniforms: Ie([qe.common, qe.bumpmap, qe.normalmap, qe.displacementmap, {
      opacity: {
        value: 1
      }
    }]),
    vertexShader: Qe.normal_vert,
    fragmentShader: Qe.normal_frag
  },
  sprite: {
    uniforms: Ie([qe.sprite, qe.fog]),
    vertexShader: Qe.sprite_vert,
    fragmentShader: Qe.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new r()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: Qe.background_vert,
    fragmentShader: Qe.background_frag
  },
  cube: {
    uniforms: Ie([qe.envmap, {
      opacity: {
        value: 1
      }
    }]),
    vertexShader: Qe.cube_vert,
    fragmentShader: Qe.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: Qe.equirect_vert,
    fragmentShader: Qe.equirect_frag
  },
  distanceRGBA: {
    uniforms: Ie([qe.common, qe.displacementmap, {
      referencePosition: {
        value: new m()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1e3
      }
    }]),
    vertexShader: Qe.distanceRGBA_vert,
    fragmentShader: Qe.distanceRGBA_frag
  },
  shadow: {
    uniforms: Ie([qe.lights, qe.fog, {
      color: {
        value: new Ot(0)
      },
      opacity: {
        value: 1
      }
    }]),
    vertexShader: Qe.shadow_vert,
    fragmentShader: Qe.shadow_frag
  }
};

function $e(t, e, n, i) {
  const r = new Ot(0);
  let o,
      s,
      a = 0,
      c = null,
      l = 0,
      u = null;

  function h(t, n) {
    e.buffers.color.setClear(t.r, t.g, t.b, n, i);
  }

  return {
    getClearColor: function () {
      return r;
    },
    setClearColor: function (t, e) {
      r.set(t), a = void 0 !== e ? e : 1, h(r, a);
    },
    getClearAlpha: function () {
      return a;
    },
    setClearAlpha: function (t) {
      a = t, h(r, a);
    },
    render: function (e, i, d, p) {
      let f = !0 === i.isScene ? i.background : null;
      const m = t.xr,
            g = m.getSession && m.getSession();

      if (g && "additive" === g.environmentBlendMode && (f = null), null === f ? h(r, a) : f && f.isColor && (h(f, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.isWebGLCubeRenderTarget || 306 === f.mapping)) {
        void 0 === s && (s = new Ee(new Ne(1, 1, 1), new Be({
          name: "BackgroundCubeMaterial",
          uniforms: De(Ke.cube.uniforms),
          vertexShader: Ke.cube.vertexShader,
          fragmentShader: Ke.cube.fragmentShader,
          side: 1,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        })), s.geometry.deleteAttribute("normal"), s.geometry.deleteAttribute("uv"), s.onBeforeRender = function (t, e, n) {
          this.matrixWorld.copyPosition(n.matrixWorld);
        }, Object.defineProperty(s.material, "envMap", {
          get: function () {
            return this.uniforms.envMap.value;
          }
        }), n.update(s));
        const i = f.isWebGLCubeRenderTarget ? f.texture : f;
        s.material.uniforms.envMap.value = i, s.material.uniforms.flipEnvMap.value = i.isCubeTexture ? -1 : 1, c === f && l === i.version && u === t.toneMapping || (s.material.needsUpdate = !0, c = f, l = i.version, u = t.toneMapping), e.unshift(s, s.geometry, s.material, 0, 0, null);
      } else f && f.isTexture && (void 0 === o && (o = new Ee(new Je(2, 2), new Be({
        name: "BackgroundMaterial",
        uniforms: De(Ke.background.uniforms),
        vertexShader: Ke.background.vertexShader,
        fragmentShader: Ke.background.fragmentShader,
        side: 0,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
        get: function () {
          return this.uniforms.t2D.value;
        }
      }), n.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), c === f && l === f.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = f, l = f.version, u = t.toneMapping), e.unshift(o, o.geometry, o.material, 0, 0, null));
    }
  };
}

function tn(t, e, n, i) {
  const r = t.getParameter(34921),
        o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        s = i.isWebGL2 || null !== o,
        a = {},
        c = d(null);
  let l = c;

  function u(e) {
    return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e);
  }

  function h(e) {
    return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e);
  }

  function d(t) {
    const e = [],
          n = [],
          i = [];

    for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;

    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: e,
      enabledAttributes: n,
      attributeDivisors: i,
      object: t,
      attributes: {}
    };
  }

  function p() {
    const t = l.newAttributes;

    for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
  }

  function f(t) {
    m(t, 0);
  }

  function m(n, r) {
    const o = l.newAttributes,
          s = l.enabledAttributes,
          a = l.attributeDivisors;
    o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r);
  }

  function g() {
    const e = l.newAttributes,
          n = l.enabledAttributes;

    for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0);
  }

  function v(e, n, r, o, s, a) {
    !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, o, s, a);
  }

  function y() {
    x(), l !== c && (l = c, u(l.object));
  }

  function x() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }

  return {
    setup: function (r, c, h, y, x) {
      let _ = !1;

      if (s) {
        const e = function (e, n, r) {
          const s = !0 === r.wireframe;
          let c = a[e.id];
          void 0 === c && (c = {}, a[e.id] = c);
          let l = c[n.id];
          void 0 === l && (l = {}, c[n.id] = l);
          let u = l[s];
          return void 0 === u && (u = d(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), l[s] = u), u;
        }(y, h, c);

        l !== e && (l = e, u(l.object)), _ = function (t) {
          const e = l.attributes,
                n = t.attributes;
          if (Object.keys(e).length !== Object.keys(n).length) return !0;

          for (const t in n) {
            const i = e[t],
                  r = n[t];
            if (i.attribute !== r) return !0;
            if (i.data !== r.data) return !0;
          }

          return !1;
        }(y), _ && function (t) {
          const e = {},
                n = t.attributes;

          for (const t in n) {
            const i = n[t],
                  r = {};
            r.attribute = i, i.data && (r.data = i.data), e[t] = r;
          }

          l.attributes = e;
        }(y);
      } else {
        const t = !0 === c.wireframe;
        l.geometry === y.id && l.program === h.id && l.wireframe === t || (l.geometry = y.id, l.program = h.id, l.wireframe = t, _ = !0);
      }

      !0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (function (r, o, s, a) {
        if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
        p();
        const c = a.attributes,
              l = s.getAttributes(),
              u = o.defaultAttributeValues;

        for (const e in l) {
          const i = l[e];

          if (i >= 0) {
            const o = c[e];

            if (void 0 !== o) {
              const e = o.normalized,
                    r = o.itemSize,
                    s = n.get(o);
              if (void 0 === s) continue;
              const c = s.buffer,
                    l = s.type,
                    u = s.bytesPerElement;

              if (o.isInterleavedBufferAttribute) {
                const n = o.data,
                      s = n.stride,
                      h = o.offset;
                n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, s * u, h * u);
              } else o.isInstancedBufferAttribute ? (m(i, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, 0, 0);
            } else if ("instanceMatrix" === e) {
              const e = n.get(r.instanceMatrix);
              if (void 0 === e) continue;
              const o = e.buffer,
                    s = e.type;
              m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48);
            } else if (void 0 !== u) {
              const n = u[e];
              if (void 0 !== n) switch (n.length) {
                case 2:
                  t.vertexAttrib2fv(i, n);
                  break;

                case 3:
                  t.vertexAttrib3fv(i, n);
                  break;

                case 4:
                  t.vertexAttrib4fv(i, n);
                  break;

                default:
                  t.vertexAttrib1fv(i, n);
              }
            }
          }
        }

        g();
      }(r, c, h, y), null !== x && t.bindBuffer(34963, n.get(x).buffer));
    },
    reset: y,
    resetDefaultState: x,
    dispose: function () {
      y();

      for (const t in a) {
        const e = a[t];

        for (const t in e) {
          const n = e[t];

          for (const t in n) h(n[t].object), delete n[t];

          delete e[t];
        }

        delete a[t];
      }
    },
    releaseStatesOfGeometry: function (t) {
      if (void 0 === a[t.id]) return;
      const e = a[t.id];

      for (const t in e) {
        const n = e[t];

        for (const t in n) h(n[t].object), delete n[t];

        delete e[t];
      }

      delete a[t.id];
    },
    releaseStatesOfProgram: function (t) {
      for (const e in a) {
        const n = a[e];
        if (void 0 === n[t.id]) continue;
        const i = n[t.id];

        for (const t in i) h(i[t].object), delete i[t];

        delete n[t.id];
      }
    },
    initAttributes: p,
    enableAttribute: f,
    disableUnusedAttributes: g
  };
}

function en(t, e, n, i) {
  const r = i.isWebGL2;
  let o;
  this.setMode = function (t) {
    o = t;
  }, this.render = function (e, i) {
    t.drawArrays(o, e, i), n.update(i, o);
  }, this.renderInstances = function (i, s, a, c) {
    if (0 === c) return;
    let l, u;
    if (r) l = t, u = "drawArraysInstanced";else if (l = e.get("ANGLE_instanced_arrays"), u = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l[u](o, s, a, c), n.update(a, o, c);
  };
}

function nn(t, e, n) {
  let i;

  function r(e) {
    if ("highp" === e) {
      if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
      e = "mediump";
    }

    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }

  const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
  let s = void 0 !== n.precision ? n.precision : "highp";
  const a = r(s);
  a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
  const c = !0 === n.logarithmicDepthBuffer,
        l = t.getParameter(34930),
        u = t.getParameter(35660),
        h = t.getParameter(3379),
        d = t.getParameter(34076),
        p = t.getParameter(34921),
        f = t.getParameter(36347),
        m = t.getParameter(36348),
        g = t.getParameter(36349),
        v = u > 0,
        y = o || !!e.get("OES_texture_float");
  return {
    isWebGL2: o,
    getMaxAnisotropy: function () {
      if (void 0 !== i) return i;
      const n = e.get("EXT_texture_filter_anisotropic");
      return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, i;
    },
    getMaxPrecision: r,
    precision: s,
    logarithmicDepthBuffer: c,
    maxTextures: l,
    maxVertexTextures: u,
    maxTextureSize: h,
    maxCubemapSize: d,
    maxAttributes: p,
    maxVertexUniforms: f,
    maxVaryings: m,
    maxFragmentUniforms: g,
    vertexTextures: v,
    floatFragmentTextures: y,
    floatVertexTextures: v && y,
    maxSamples: o ? t.getParameter(36183) : 0
  };
}

function rn() {
  const t = this;
  let e = null,
      n = 0,
      i = !1,
      o = !1;
  const s = new vt(),
        a = new r(),
        c = {
    value: null,
    needsUpdate: !1
  };

  function l() {
    c.value !== e && (c.value = e, c.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
  }

  function u(e, n, i, r) {
    let o = null !== e ? e.length : 0,
        l = null;

    if (0 !== o) {
      if (l = c.value, !0 !== r || null === l) {
        const t = i + 4 * o,
              r = n.matrixWorldInverse;
        a.getNormalMatrix(r), (null === l || l.length < t) && (l = new Float32Array(t));

        for (let t = 0, n = i; t !== o; ++t, n += 4) s.copy(e[t]).applyMatrix4(r, a), s.normal.toArray(l, n), l[n + 3] = s.constant;
      }

      c.value = l, c.needsUpdate = !0;
    }

    return t.numPlanes = o, t.numIntersection = 0, l;
  }

  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, r, o) {
    const s = 0 !== t.length || r || 0 !== n || i;
    return i = r, e = u(t, o, 0), n = t.length, s;
  }, this.beginShadows = function () {
    o = !0, u(null);
  }, this.endShadows = function () {
    o = !1, l();
  }, this.setState = function (t, r, s, a, h, d) {
    if (!i || null === t || 0 === t.length || o && !s) o ? u(null) : l();else {
      const i = o ? 0 : n,
            s = 4 * i;
      let l = h.clippingState || null;
      c.value = l, l = u(t, a, s, d);

      for (let t = 0; t !== s; ++t) l[t] = e[t];

      h.clippingState = l, this.numIntersection = r ? this.numPlanes : 0, this.numPlanes += i;
    }
  };
}

function on(t) {
  const e = {};
  return {
    get: function (n) {
      if (void 0 !== e[n]) return e[n];
      let i;

      switch (n) {
        case "WEBGL_depth_texture":
          i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;

        case "EXT_texture_filter_anisotropic":
          i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;

        case "WEBGL_compressed_texture_s3tc":
          i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;

        case "WEBGL_compressed_texture_pvrtc":
          i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;

        default:
          i = t.getExtension(n);
      }

      return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i;
    }
  };
}

function sn(t, e, n, i) {
  const r = new WeakMap(),
        o = new WeakMap();

  function s(t) {
    const a = t.target,
          c = r.get(a);
    null !== c.index && e.remove(c.index);

    for (const t in c.attributes) e.remove(c.attributes[t]);

    a.removeEventListener("dispose", s), r.delete(a);
    const l = o.get(c);
    l && (e.remove(l), o.delete(c)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--;
  }

  function a(t) {
    const n = [],
          i = t.index,
          r = t.attributes.position;
    let s = 0;

    if (null !== i) {
      const t = i.array;
      s = i.version;

      for (let e = 0, i = t.length; e < i; e += 3) {
        const i = t[e + 0],
              r = t[e + 1],
              o = t[e + 2];
        n.push(i, r, r, o, o, i);
      }
    } else {
      const t = r.array;
      s = r.version;

      for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
        const t = e + 0,
              i = e + 1,
              r = e + 2;
        n.push(t, i, i, r, r, t);
      }
    }

    const a = new ($t(n) > 65535 ? Zt : Xt)(n, 1);
    a.version = s;
    const c = o.get(t);
    c && e.remove(c), o.set(t, a);
  }

  return {
    get: function (t, e) {
      let i = r.get(e);
      return i || (e.addEventListener("dispose", s), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = new ae().setFromObject(t)), i = e._bufferGeometry), r.set(e, i), n.memory.geometries++, i);
    },
    update: function (t) {
      const n = t.attributes;

      for (const t in n) e.update(n[t], 34962);

      const i = t.morphAttributes;

      for (const t in i) {
        const n = i[t];

        for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
      }
    },
    getWireframeAttribute: function (t) {
      const e = o.get(t);

      if (e) {
        const n = t.index;
        null !== n && e.version < n.version && a(t);
      } else a(t);

      return o.get(t);
    }
  };
}

function an(t, e, n, i) {
  const r = i.isWebGL2;
  let o, s, a;
  this.setMode = function (t) {
    o = t;
  }, this.setIndex = function (t) {
    s = t.type, a = t.bytesPerElement;
  }, this.render = function (e, i) {
    t.drawElements(o, i, s, e * a), n.update(i, o);
  }, this.renderInstances = function (i, c, l, u) {
    if (0 === u) return;
    let h, d;
    if (r) h = t, d = "drawElementsInstanced";else if (h = e.get("ANGLE_instanced_arrays"), d = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h[d](o, l, s, c * a, u), n.update(l, o, u);
  };
}

function cn(t) {
  const e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  return {
    memory: {
      geometries: 0,
      textures: 0
    },
    render: e,
    programs: null,
    autoReset: !0,
    reset: function () {
      e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
    },
    update: function (t, n, i) {
      switch (i = i || 1, e.calls++, n) {
        case 4:
          e.triangles += i * (t / 3);
          break;

        case 1:
          e.lines += i * (t / 2);
          break;

        case 3:
          e.lines += i * (t - 1);
          break;

        case 2:
          e.lines += i * t;
          break;

        case 0:
          e.points += i * t;
          break;

        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", n);
      }
    }
  };
}

function ln(t, e) {
  return t[0] - e[0];
}

function un(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}

function hn(t) {
  const e = {},
        n = new Float32Array(8),
        i = [];

  for (let t = 0; t < 8; t++) i[t] = [t, 0];

  return {
    update: function (r, o, s, a) {
      const c = r.morphTargetInfluences,
            l = void 0 === c ? 0 : c.length;
      let u = e[o.id];

      if (void 0 === u) {
        u = [];

        for (let t = 0; t < l; t++) u[t] = [t, 0];

        e[o.id] = u;
      }

      for (let t = 0; t < l; t++) {
        const e = u[t];
        e[0] = t, e[1] = c[t];
      }

      u.sort(un);

      for (let t = 0; t < 8; t++) t < l && u[t][1] ? (i[t][0] = u[t][0], i[t][1] = u[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);

      i.sort(ln);
      const h = s.morphTargets && o.morphAttributes.position,
            d = s.morphNormals && o.morphAttributes.normal;
      let p = 0;

      for (let t = 0; t < 8; t++) {
        const e = i[t],
              r = e[0],
              s = e[1];
        r !== Number.MAX_SAFE_INTEGER && s ? (h && o.getAttribute("morphTarget" + t) !== h[r] && o.setAttribute("morphTarget" + t, h[r]), d && o.getAttribute("morphNormal" + t) !== d[r] && o.setAttribute("morphNormal" + t, d[r]), n[t] = s, p += s) : (h && void 0 !== o.getAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), d && void 0 !== o.getAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0);
      }

      const f = o.morphTargetsRelative ? 1 : 1 - p;
      a.getUniforms().setValue(t, "morphTargetBaseInfluence", f), a.getUniforms().setValue(t, "morphTargetInfluences", n);
    }
  };
}

function dn(t, e, n, i) {
  let r = new WeakMap();
  return {
    update: function (t) {
      const o = i.render.frame,
            s = t.geometry,
            a = e.get(t, s);
      return r.get(a) !== o && (s.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, o)), t.isInstancedMesh && n.update(t.instanceMatrix, 34962), a;
    },
    dispose: function () {
      r = new WeakMap();
    }
  };
}

function pn(t, e, n, i, r, o, s, a, l, u) {
  t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, s = void 0 !== s ? s : 1022, c.call(this, t, e, n, i, r, o, s, a, l, u), this.flipY = !1;
}

function fn(t, e, n, i) {
  c.call(this, null), this.image = {
    data: t || null,
    width: e || 1,
    height: n || 1,
    depth: i || 1
  }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}

function mn(t, e, n, i) {
  c.call(this, null), this.image = {
    data: t || null,
    width: e || 1,
    height: n || 1,
    depth: i || 1
  }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0;
}

Ke.physical = {
  uniforms: Ie([Ke.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatNormalScale: {
      value: new i(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    },
    sheen: {
      value: new Ot(0)
    },
    transparency: {
      value: 0
    }
  }]),
  vertexShader: Qe.meshphysical_vert,
  fragmentShader: Qe.meshphysical_frag
}, pn.prototype = Object.create(c.prototype), pn.prototype.constructor = pn, pn.prototype.isCubeTexture = !0, Object.defineProperty(pn.prototype, "images", {
  get: function () {
    return this.image;
  },
  set: function (t) {
    this.image = t;
  }
}), fn.prototype = Object.create(c.prototype), fn.prototype.constructor = fn, fn.prototype.isDataTexture2DArray = !0, mn.prototype = Object.create(c.prototype), mn.prototype.constructor = mn, mn.prototype.isDataTexture3D = !0;
const gn = new c(),
      vn = new fn(),
      yn = new mn(),
      xn = new pn(),
      _n = [],
      bn = [],
      wn = new Float32Array(16),
      Mn = new Float32Array(9),
      Sn = new Float32Array(4);

function En(t, e, n) {
  const i = t[0];
  if (i <= 0 || i > 0) return t;
  let r = e * n,
      o = _n[r];

  if (void 0 === o && (o = new Float32Array(r), _n[r] = o), 0 !== e) {
    i.toArray(o, 0);

    for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(o, r);
  }

  return o;
}

function Tn(t, e) {
  if (t.length !== e.length) return !1;

  for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;

  return !0;
}

function An(t, e) {
  for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
}

function Ln(t, e) {
  let n = bn[e];
  void 0 === n && (n = new Int32Array(e), bn[e] = n);

  for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();

  return n;
}

function Cn(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
}

function Rn(t, e) {
  const n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);else {
    if (Tn(n, e)) return;
    t.uniform2fv(this.addr, e), An(n, e);
  }
}

function Pn(t, e) {
  const n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);else {
    if (Tn(n, e)) return;
    t.uniform3fv(this.addr, e), An(n, e);
  }
}

function On(t, e) {
  const n = this.cache;
  if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);else {
    if (Tn(n, e)) return;
    t.uniform4fv(this.addr, e), An(n, e);
  }
}

function Nn(t, e) {
  const n = this.cache,
        i = e.elements;

  if (void 0 === i) {
    if (Tn(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), An(n, e);
  } else {
    if (Tn(n, i)) return;
    Sn.set(i), t.uniformMatrix2fv(this.addr, !1, Sn), An(n, i);
  }
}

function Dn(t, e) {
  const n = this.cache,
        i = e.elements;

  if (void 0 === i) {
    if (Tn(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), An(n, e);
  } else {
    if (Tn(n, i)) return;
    Mn.set(i), t.uniformMatrix3fv(this.addr, !1, Mn), An(n, i);
  }
}

function In(t, e) {
  const n = this.cache,
        i = e.elements;

  if (void 0 === i) {
    if (Tn(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), An(n, e);
  } else {
    if (Tn(n, i)) return;
    wn.set(i), t.uniformMatrix4fv(this.addr, !1, wn), An(n, i);
  }
}

function zn(t, e, n) {
  const i = this.cache,
        r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || gn, r);
}

function Bn(t, e, n) {
  const i = this.cache,
        r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || vn, r);
}

function kn(t, e, n) {
  const i = this.cache,
        r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || yn, r);
}

function Hn(t, e, n) {
  const i = this.cache,
        r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || xn, r);
}

function Fn(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
}

function Un(t, e) {
  const n = this.cache;
  Tn(n, e) || (t.uniform2iv(this.addr, e), An(n, e));
}

function Gn(t, e) {
  const n = this.cache;
  Tn(n, e) || (t.uniform3iv(this.addr, e), An(n, e));
}

function jn(t, e) {
  const n = this.cache;
  Tn(n, e) || (t.uniform4iv(this.addr, e), An(n, e));
}

function Vn(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
}

function Wn(t, e) {
  t.uniform1fv(this.addr, e);
}

function qn(t, e) {
  t.uniform1iv(this.addr, e);
}

function Xn(t, e) {
  t.uniform2iv(this.addr, e);
}

function Yn(t, e) {
  t.uniform3iv(this.addr, e);
}

function Zn(t, e) {
  t.uniform4iv(this.addr, e);
}

function Jn(t, e) {
  const n = En(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}

function Qn(t, e) {
  const n = En(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}

function Kn(t, e) {
  const n = En(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}

function $n(t, e) {
  const n = En(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}

function ti(t, e) {
  const n = En(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}

function ei(t, e) {
  const n = En(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}

function ni(t, e, n) {
  const i = e.length,
        r = Ln(n, i);
  t.uniform1iv(this.addr, r);

  for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || gn, r[t]);
}

function ii(t, e, n) {
  const i = e.length,
        r = Ln(n, i);
  t.uniform1iv(this.addr, r);

  for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || xn, r[t]);
}

function ri(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
    switch (t) {
      case 5126:
        return Cn;

      case 35664:
        return Rn;

      case 35665:
        return Pn;

      case 35666:
        return On;

      case 35674:
        return Nn;

      case 35675:
        return Dn;

      case 35676:
        return In;

      case 5124:
      case 35670:
        return Fn;

      case 35667:
      case 35671:
        return Un;

      case 35668:
      case 35672:
        return Gn;

      case 35669:
      case 35673:
        return jn;

      case 5125:
        return Vn;

      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return zn;

      case 35679:
      case 36299:
      case 36307:
        return kn;

      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Hn;

      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Bn;
    }
  }(e.type);
}

function oi(t, e, n) {
  this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
    switch (t) {
      case 5126:
        return Wn;

      case 35664:
        return Jn;

      case 35665:
        return Qn;

      case 35666:
        return Kn;

      case 35674:
        return $n;

      case 35675:
        return ti;

      case 35676:
        return ei;

      case 5124:
      case 35670:
        return qn;

      case 35667:
      case 35671:
        return Xn;

      case 35668:
      case 35672:
        return Yn;

      case 35669:
      case 35673:
        return Zn;

      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return ni;

      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return ii;
    }
  }(e.type);
}

function si(t) {
  this.id = t, this.seq = [], this.map = {};
}

oi.prototype.updateCache = function (t) {
  let e = this.cache;
  t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), An(e, t);
}, si.prototype.setValue = function (t, e, n) {
  const i = this.seq;

  for (let r = 0, o = i.length; r !== o; ++r) {
    const o = i[r];
    o.setValue(t, e[o.id], n);
  }
};
const ai = /([\w\d_]+)(\])?(\[|\.)?/g;

function ci(t, e) {
  t.seq.push(e), t.map[e.id] = e;
}

function li(t, e, n) {
  const i = t.name,
        r = i.length;

  for (ai.lastIndex = 0;;) {
    const o = ai.exec(i),
          s = ai.lastIndex;
    let a = o[1],
        c = "]" === o[2],
        l = o[3];

    if (c && (a |= 0), void 0 === l || "[" === l && s + 2 === r) {
      ci(n, void 0 === l ? new ri(a, t, e) : new oi(a, t, e));
      break;
    }

    {
      let t = n.map[a];
      void 0 === t && (t = new si(a), ci(n, t)), n = t;
    }
  }
}

function ui(t, e) {
  this.seq = [], this.map = {};
  const n = t.getProgramParameter(e, 35718);

  for (let i = 0; i < n; ++i) {
    const n = t.getActiveUniform(e, i);
    li(n, t.getUniformLocation(e, n.name), this);
  }
}

function hi(t, e, n) {
  const i = t.createShader(e);
  return t.shaderSource(i, n), t.compileShader(i), i;
}

ui.prototype.setValue = function (t, e, n, i) {
  const r = this.map[e];
  void 0 !== r && r.setValue(t, n, i);
}, ui.prototype.setOptional = function (t, e, n) {
  const i = e[n];
  void 0 !== i && this.setValue(t, n, i);
}, ui.upload = function (t, e, n, i) {
  for (let r = 0, o = e.length; r !== o; ++r) {
    const o = e[r],
          s = n[o.id];
    !1 !== s.needsUpdate && o.setValue(t, s.value, i);
  }
}, ui.seqWithValue = function (t, e) {
  const n = [];

  for (let i = 0, r = t.length; i !== r; ++i) {
    const r = t[i];
    r.id in e && n.push(r);
  }

  return n;
};
let di = 0;

function pi(t) {
  switch (t) {
    case 3e3:
      return ["Linear", "( value )"];

    case 3001:
      return ["sRGB", "( value )"];

    case 3002:
      return ["RGBE", "( value )"];

    case 3004:
      return ["RGBM", "( value, 7.0 )"];

    case 3005:
      return ["RGBM", "( value, 16.0 )"];

    case 3006:
      return ["RGBD", "( value, 256.0 )"];

    case 3007:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];

    case 3003:
      return ["LogLuv", "( value )"];

    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"];
  }
}

function fi(t, e, n) {
  const i = t.getShaderParameter(e, 35713),
        r = t.getShaderInfoLog(e).trim();
  return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (t) {
    const e = t.split("\n");

    for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];

    return e.join("\n");
  }(t.getShaderSource(e));
}

function mi(t, e) {
  const n = pi(e);
  return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }";
}

function gi(t, e) {
  const n = pi(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}

function vi(t, e) {
  let n;

  switch (e) {
    case 1:
      n = "Linear";
      break;

    case 2:
      n = "Reinhard";
      break;

    case 3:
      n = "OptimizedCineon";
      break;

    case 4:
      n = "ACESFilmic";
      break;

    case 5:
      n = "Custom";
      break;

    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }

  return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}

function yi(t) {
  return "" !== t;
}

function xi(t, e) {
  return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}

function _i(t, e) {
  return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}

const bi = /^[ \t]*#include +<([\w\d./]+)>/gm;

function wi(t) {
  return t.replace(bi, Mi);
}

function Mi(t, e) {
  const n = Qe[e];
  if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
  return wi(n);
}

const Si = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      Ei = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

function Ti(t) {
  return t.replace(Ei, Li).replace(Si, Ai);
}

function Ai(t, e, n, i) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Li(t, e, n, i);
}

function Li(t, e, n, i) {
  let r = "";

  for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[ i \]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);

  return r;
}

function Ci(t) {
  let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
  return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
}

function Ri(t, e, n, i) {
  const r = t.getContext(),
        o = n.defines;
  let s = n.vertexShader,
      a = n.fragmentShader;

  const c = function (t) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e;
  }(n),
        l = function (t) {
    let e = "ENVMAP_TYPE_CUBE";
    if (t.envMap) switch (t.envMapMode) {
      case 301:
      case 302:
        e = "ENVMAP_TYPE_CUBE";
        break;

      case 306:
      case 307:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;

      case 303:
      case 304:
        e = "ENVMAP_TYPE_EQUIREC";
    }
    return e;
  }(n),
        u = function (t) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (t.envMap) switch (t.envMapMode) {
      case 302:
      case 304:
        e = "ENVMAP_MODE_REFRACTION";
    }
    return e;
  }(n),
        h = function (t) {
    let e = "ENVMAP_BLENDING_NONE";
    if (t.envMap) switch (t.combine) {
      case 0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;

      case 1:
        e = "ENVMAP_BLENDING_MIX";
        break;

      case 2:
        e = "ENVMAP_BLENDING_ADD";
    }
    return e;
  }(n),
        d = t.gammaFactor > 0 ? t.gammaFactor : 1,
        p = n.isWebGL2 ? "" : function (t) {
    return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(yi).join("\n");
  }(n),
        f = function (t) {
    const e = [];

    for (const n in t) {
      const i = t[n];
      !1 !== i && e.push("#define " + n + " " + i);
    }

    return e.join("\n");
  }(o),
        m = r.createProgram();

  let g, v;

  if (n.isRawShaderMaterial ? (g = [f].filter(yi).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(yi).join("\n"), v.length > 0 && (v += "\n")) : (g = [Ci(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(yi).join("\n"), v = [p, Ci(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Qe.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? vi("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Qe.encodings_pars_fragment, n.map ? mi("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? mi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? mi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? mi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? mi("lightMapTexelToLinear", n.lightMapEncoding) : "", gi("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(yi).join("\n")), s = wi(s), s = xi(s, n), s = _i(s, n), a = wi(a), a = xi(a, n), a = _i(a, n), s = Ti(s), a = Ti(a), n.isWebGL2 && !n.isRawShaderMaterial) {
    let t = !1;
    const e = /^\s*#version\s+300\s+es\s*\n/;
    n.isShaderMaterial && null !== s.match(e) && null !== a.match(e) && (t = !0, s = s.replace(e, ""), a = a.replace(e, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#version 300 es\n", "#define varying in", t ? "" : "out highp vec4 pc_fragColor;", t ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v;
  }

  const y = v + a,
        x = hi(r, 35633, g + s),
        _ = hi(r, 35632, y);

  if (r.attachShader(m, x), r.attachShader(m, _), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
    const t = r.getProgramInfoLog(m).trim(),
          e = r.getShaderInfoLog(x).trim(),
          n = r.getShaderInfoLog(_).trim();
    let i = !0,
        o = !0;

    if (!1 === r.getProgramParameter(m, 35714)) {
      i = !1;
      const e = fi(r, x, "vertex"),
            n = fi(r, _, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n);
    } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1);

    o && (this.diagnostics = {
      runnable: i,
      programLog: t,
      vertexShader: {
        log: e,
        prefix: g
      },
      fragmentShader: {
        log: n,
        prefix: v
      }
    });
  }

  let b, w;
  return r.deleteShader(x), r.deleteShader(_), this.getUniforms = function () {
    return void 0 === b && (b = new ui(r, m)), b;
  }, this.getAttributes = function () {
    return void 0 === w && (w = function (t, e) {
      const n = {},
            i = t.getProgramParameter(e, 35721);

      for (let r = 0; r < i; r++) {
        const i = t.getActiveAttrib(e, r).name;
        n[i] = t.getAttribLocation(e, i);
      }

      return n;
    }(r, m)), w;
  }, this.destroy = function () {
    i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0;
  }, this.name = n.shaderName, this.id = di++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = x, this.fragmentShader = _, this;
}

function Pi(t, e, n, i) {
  const r = [],
        o = n.isWebGL2,
        s = n.logarithmicDepthBuffer,
        a = n.floatVertexTextures,
        c = n.maxVertexUniforms,
        l = n.vertexTextures;
  let u = n.precision;
  const h = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  },
        d = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

  function p(t) {
    let e;
    return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = 3e3, e;
  }

  return {
    getParameters: function (i, r, d, f, m, g, v) {
      const y = f.fog,
            x = i.isMeshStandardMaterial ? f.environment : null,
            _ = i.envMap || x,
            b = h[i.type],
            w = v.isSkinnedMesh ? function (t) {
        const e = t.skeleton.bones;
        if (a) return 1024;
        {
          const t = c,
                n = Math.floor((t - 20) / 4),
                i = Math.min(n, e.length);
          return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i;
        }
      }(v) : 0;

      null !== i.precision && (u = n.getMaxPrecision(i.precision), u !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", u, "instead."));

      const M = function (t, e) {
        let n;

        if (e) {
          const i = Ke[e];
          n = {
            name: t.name || t.type,
            uniforms: ze.clone(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader
          };
        } else n = {
          name: t.name || t.type,
          uniforms: t.uniforms,
          vertexShader: t.vertexShader,
          fragmentShader: t.fragmentShader
        };

        return n;
      }(i, b);

      i.onBeforeCompile(M, t);
      const S = t.getRenderTarget();
      return {
        isWebGL2: o,
        shaderID: b,
        shaderName: M.name,
        uniforms: M.uniforms,
        vertexShader: M.vertexShader,
        fragmentShader: M.fragmentShader,
        defines: i.defines,
        isRawShaderMaterial: i.isRawShaderMaterial,
        isShaderMaterial: i.isShaderMaterial,
        precision: u,
        instancing: !0 === v.isInstancedMesh,
        supportsVertexTextures: l,
        outputEncoding: null !== S ? p(S.texture) : t.outputEncoding,
        map: !!i.map,
        mapEncoding: p(i.map),
        matcap: !!i.matcap,
        matcapEncoding: p(i.matcap),
        envMap: !!_,
        envMapMode: _ && _.mapping,
        envMapEncoding: p(_),
        envMapCubeUV: !!_ && (306 === _.mapping || 307 === _.mapping),
        lightMap: !!i.lightMap,
        lightMapEncoding: p(i.lightMap),
        aoMap: !!i.aoMap,
        emissiveMap: !!i.emissiveMap,
        emissiveMapEncoding: p(i.emissiveMap),
        bumpMap: !!i.bumpMap,
        normalMap: !!i.normalMap,
        objectSpaceNormalMap: 1 === i.normalMapType,
        tangentSpaceNormalMap: 0 === i.normalMapType,
        clearcoatMap: !!i.clearcoatMap,
        clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
        clearcoatNormalMap: !!i.clearcoatNormalMap,
        displacementMap: !!i.displacementMap,
        roughnessMap: !!i.roughnessMap,
        metalnessMap: !!i.metalnessMap,
        specularMap: !!i.specularMap,
        alphaMap: !!i.alphaMap,
        gradientMap: !!i.gradientMap,
        sheen: !!i.sheen,
        combine: i.combine,
        vertexTangents: i.normalMap && i.vertexTangents,
        vertexColors: i.vertexColors,
        vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap),
        uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || !i.displacementMap),
        fog: !!y,
        useFog: i.fog,
        fogExp2: y && y.isFogExp2,
        flatShading: i.flatShading,
        sizeAttenuation: i.sizeAttenuation,
        logarithmicDepthBuffer: s,
        skinning: i.skinning && w > 0,
        maxBones: w,
        useVertexTexture: a,
        morphTargets: i.morphTargets,
        morphNormals: i.morphNormals,
        maxMorphTargets: t.maxMorphTargets,
        maxMorphNormals: t.maxMorphNormals,
        numDirLights: r.directional.length,
        numPointLights: r.point.length,
        numSpotLights: r.spot.length,
        numRectAreaLights: r.rectArea.length,
        numHemiLights: r.hemi.length,
        numDirLightShadows: r.directionalShadowMap.length,
        numPointLightShadows: r.pointShadowMap.length,
        numSpotLightShadows: r.spotShadowMap.length,
        numClippingPlanes: m,
        numClipIntersection: g,
        dithering: i.dithering,
        shadowMapEnabled: t.shadowMap.enabled && d.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: i.toneMapped ? t.toneMapping : 0,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: i.premultipliedAlpha,
        alphaTest: i.alphaTest,
        doubleSided: 2 === i.side,
        flipSided: 1 === i.side,
        depthPacking: void 0 !== i.depthPacking && i.depthPacking,
        index0AttributeName: i.index0AttributeName,
        extensionDerivatives: i.extensions && i.extensions.derivatives,
        extensionFragDepth: i.extensions && i.extensions.fragDepth,
        extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
        extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: o || null !== e.get("EXT_frag_depth"),
        rendererExtensionDrawBuffers: o || null !== e.get("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: o || null !== e.get("EXT_shader_texture_lod"),
        customProgramCacheKey: i.customProgramCacheKey()
      };
    },
    getProgramCacheKey: function (e) {
      const n = [];
      if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]);

      if (void 0 === e.isRawShaderMaterial) {
        for (let t = 0; t < d.length; t++) n.push(e[d[t]]);

        n.push(t.outputEncoding), n.push(t.gammaFactor);
      }

      return n.push(e.customProgramCacheKey), n.join();
    },
    acquireProgram: function (e, n) {
      let o;

      for (let t = 0, e = r.length; t < e; t++) {
        const e = r[t];

        if (e.cacheKey === n) {
          o = e, ++o.usedTimes;
          break;
        }
      }

      return void 0 === o && (o = new Ri(t, n, e, i), r.push(o)), o;
    },
    releaseProgram: function (t) {
      if (0 == --t.usedTimes) {
        const e = r.indexOf(t);
        r[e] = r[r.length - 1], r.pop(), t.destroy();
      }
    },
    programs: r
  };
}

function Oi() {
  let t = new WeakMap();
  return {
    get: function (e) {
      let n = t.get(e);
      return void 0 === n && (n = {}, t.set(e, n)), n;
    },
    remove: function (e) {
      t.delete(e);
    },
    update: function (e, n, i) {
      t.get(e)[n] = i;
    },
    dispose: function () {
      t = new WeakMap();
    }
  };
}

function Ni(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
}

function Di(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
}

function Ii() {
  const t = [];
  let e = 0;
  const n = [],
        i = [],
        r = {
    id: -1
  };

  function o(n, i, o, s, a, c) {
    let l = t[e];
    return void 0 === l ? (l = {
      id: n.id,
      object: n,
      geometry: i,
      material: o,
      program: o.program || r,
      groupOrder: s,
      renderOrder: n.renderOrder,
      z: a,
      group: c
    }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = o, l.program = o.program || r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = c), e++, l;
  }

  return {
    opaque: n,
    transparent: i,
    init: function () {
      e = 0, n.length = 0, i.length = 0;
    },
    push: function (t, e, r, s, a, c) {
      const l = o(t, e, r, s, a, c);
      (!0 === r.transparent ? i : n).push(l);
    },
    unshift: function (t, e, r, s, a, c) {
      const l = o(t, e, r, s, a, c);
      (!0 === r.transparent ? i : n).unshift(l);
    },
    finish: function () {
      for (let n = e, i = t.length; n < i; n++) {
        const e = t[n];
        if (null === e.id) break;
        e.id = null, e.object = null, e.geometry = null, e.material = null, e.program = null, e.group = null;
      }
    },
    sort: function (t, e) {
      n.length > 1 && n.sort(t || Ni), i.length > 1 && i.sort(e || Di);
    }
  };
}

function zi() {
  let t = new WeakMap();

  function e(n) {
    const i = n.target;
    i.removeEventListener("dispose", e), t.delete(i);
  }

  return {
    get: function (n, i) {
      const r = t.get(n);
      let o;
      return void 0 === r ? (o = new Ii(), t.set(n, new WeakMap()), t.get(n).set(i, o), n.addEventListener("dispose", e)) : (o = r.get(i), void 0 === o && (o = new Ii(), r.set(i, o))), o;
    },
    dispose: function () {
      t = new WeakMap();
    }
  };
}

function Bi() {
  const t = {};
  return {
    get: function (e) {
      if (void 0 !== t[e.id]) return t[e.id];
      let n;

      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new m(),
            color: new Ot()
          };
          break;

        case "SpotLight":
          n = {
            position: new m(),
            direction: new m(),
            color: new Ot(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;

        case "PointLight":
          n = {
            position: new m(),
            color: new Ot(),
            distance: 0,
            decay: 0
          };
          break;

        case "HemisphereLight":
          n = {
            direction: new m(),
            skyColor: new Ot(),
            groundColor: new Ot()
          };
          break;

        case "RectAreaLight":
          n = {
            color: new Ot(),
            position: new m(),
            halfWidth: new m(),
            halfHeight: new m()
          };
      }

      return t[e.id] = n, n;
    }
  };
}

let ki = 0;

function Hi(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}

function Fi() {
  const t = new Bi(),
        e = function () {
    const t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let n;

        switch (e.type) {
          case "DirectionalLight":
          case "SpotLight":
            n = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new i()
            };
            break;

          case "PointLight":
            n = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new i(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
        }

        return t[e.id] = n, n;
      }
    };
  }(),
        n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };

  for (let t = 0; t < 9; t++) n.probe.push(new m());

  const r = new m(),
        o = new M(),
        s = new M();
  return {
    setup: function (i, a, c) {
      let l = 0,
          u = 0,
          h = 0;

      for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);

      let d = 0,
          p = 0,
          f = 0,
          m = 0,
          g = 0,
          v = 0,
          y = 0,
          x = 0;
      const _ = c.matrixWorldInverse;
      i.sort(Hi);

      for (let a = 0, c = i.length; a < c; a++) {
        const c = i[a],
              b = c.color,
              w = c.intensity,
              M = c.distance,
              S = c.shadow && c.shadow.map ? c.shadow.map.texture : null;
        if (c.isAmbientLight) l += b.r * w, u += b.g * w, h += b.b * w;else if (c.isLightProbe) for (let t = 0; t < 9; t++) n.probe[t].addScaledVector(c.sh.coefficients[t], w);else if (c.isDirectionalLight) {
          const i = t.get(c);

          if (i.color.copy(c.color).multiplyScalar(c.intensity), i.direction.setFromMatrixPosition(c.matrixWorld), r.setFromMatrixPosition(c.target.matrixWorld), i.direction.sub(r), i.direction.transformDirection(_), c.castShadow) {
            const t = c.shadow,
                  i = e.get(c);
            i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.directionalShadow[d] = i, n.directionalShadowMap[d] = S, n.directionalShadowMatrix[d] = c.shadow.matrix, v++;
          }

          n.directional[d] = i, d++;
        } else if (c.isSpotLight) {
          const i = t.get(c);

          if (i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(_), i.color.copy(b).multiplyScalar(w), i.distance = M, i.direction.setFromMatrixPosition(c.matrixWorld), r.setFromMatrixPosition(c.target.matrixWorld), i.direction.sub(r), i.direction.transformDirection(_), i.coneCos = Math.cos(c.angle), i.penumbraCos = Math.cos(c.angle * (1 - c.penumbra)), i.decay = c.decay, c.castShadow) {
            const t = c.shadow,
                  i = e.get(c);
            i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.spotShadow[f] = i, n.spotShadowMap[f] = S, n.spotShadowMatrix[f] = c.shadow.matrix, x++;
          }

          n.spot[f] = i, f++;
        } else if (c.isRectAreaLight) {
          const e = t.get(c);
          e.color.copy(b).multiplyScalar(w), e.position.setFromMatrixPosition(c.matrixWorld), e.position.applyMatrix4(_), s.identity(), o.copy(c.matrixWorld), o.premultiply(_), s.extractRotation(o), e.halfWidth.set(.5 * c.width, 0, 0), e.halfHeight.set(0, .5 * c.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), n.rectArea[m] = e, m++;
        } else if (c.isPointLight) {
          const i = t.get(c);

          if (i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(_), i.color.copy(c.color).multiplyScalar(c.intensity), i.distance = c.distance, i.decay = c.decay, c.castShadow) {
            const t = c.shadow,
                  i = e.get(c);
            i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, n.pointShadow[p] = i, n.pointShadowMap[p] = S, n.pointShadowMatrix[p] = c.shadow.matrix, y++;
          }

          n.point[p] = i, p++;
        } else if (c.isHemisphereLight) {
          const e = t.get(c);
          e.direction.setFromMatrixPosition(c.matrixWorld), e.direction.transformDirection(_), e.direction.normalize(), e.skyColor.copy(c.color).multiplyScalar(w), e.groundColor.copy(c.groundColor).multiplyScalar(w), n.hemi[g] = e, g++;
        }
      }

      n.ambient[0] = l, n.ambient[1] = u, n.ambient[2] = h;
      const b = n.hash;
      b.directionalLength === d && b.pointLength === p && b.spotLength === f && b.rectAreaLength === m && b.hemiLength === g && b.numDirectionalShadows === v && b.numPointShadows === y && b.numSpotShadows === x || (n.directional.length = d, n.spot.length = f, n.rectArea.length = m, n.point.length = p, n.hemi.length = g, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = x, n.spotShadowMap.length = x, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = y, n.spotShadowMatrix.length = x, b.directionalLength = d, b.pointLength = p, b.spotLength = f, b.rectAreaLength = m, b.hemiLength = g, b.numDirectionalShadows = v, b.numPointShadows = y, b.numSpotShadows = x, n.version = ki++);
    },
    state: n
  };
}

function Ui() {
  const t = new Fi(),
        e = [],
        n = [];
  return {
    init: function () {
      e.length = 0, n.length = 0;
    },
    state: {
      lightsArray: e,
      shadowsArray: n,
      lights: t
    },
    setupLights: function (i) {
      t.setup(e, n, i);
    },
    pushLight: function (t) {
      e.push(t);
    },
    pushShadow: function (t) {
      n.push(t);
    }
  };
}

function Gi() {
  let t = new WeakMap();

  function e(n) {
    const i = n.target;
    i.removeEventListener("dispose", e), t.delete(i);
  }

  return {
    get: function (n, i) {
      let r;
      return !1 === t.has(n) ? (r = new Ui(), t.set(n, new WeakMap()), t.get(n).set(i, r), n.addEventListener("dispose", e)) : !1 === t.get(n).has(i) ? (r = new Ui(), t.get(n).set(i, r)) : r = t.get(n).get(i), r;
    },
    dispose: function () {
      t = new WeakMap();
    }
  };
}

function ji(t) {
  kt.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t);
}

function Vi(t) {
  kt.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new m(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t);
}

function Wi(t, e, n) {
  let r = new We();
  const o = new i(),
        s = new i(),
        a = new l(),
        c = [],
        h = [],
        d = {},
        p = {
    0: 1,
    1: 0,
    2: 2
  },
        f = new Be({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new i()
      },
      radius: {
        value: 4
      }
    },
    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
  }),
        m = f.clone();
  m.defines.HORIZONAL_PASS = 1;
  const g = new ae();
  g.setAttribute("position", new Gt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
  const v = new Ee(g, f),
        y = this;

  function x(n, i) {
    const r = e.update(v);
    f.uniforms.shadow_pass.value = n.map.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, f, v, null), m.uniforms.shadow_pass.value = n.mapPass.texture, m.uniforms.resolution.value = n.mapSize, m.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, m, v, null);
  }

  function _(t, e, n) {
    const i = t << 0 | e << 1 | n << 2;
    let r = c[i];
    return void 0 === r && (r = new ji({
      depthPacking: 3201,
      morphTargets: t,
      skinning: e
    }), c[i] = r), r;
  }

  function b(t, e, n) {
    const i = t << 0 | e << 1 | n << 2;
    let r = h[i];
    return void 0 === r && (r = new Vi({
      morphTargets: t,
      skinning: e
    }), h[i] = r), r;
  }

  function w(e, n, i, r, o, s, a) {
    let c = null,
        l = _,
        u = e.customDepthMaterial;

    if (!0 === r.isPointLight && (l = b, u = e.customDistanceMaterial), void 0 === u) {
      let t = !1;
      !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
      let r = !1;
      !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), c = l(t, r, !0 === e.isInstancedMesh);
    } else c = u;

    if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
      const t = c.uuid,
            e = i.uuid;
      let n = d[t];
      void 0 === n && (n = {}, d[t] = n);
      let r = n[e];
      void 0 === r && (r = c.clone(), n[e] = r), c = r;
    }

    return c.visible = i.visible, c.wireframe = i.wireframe, c.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : p[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, !0 === r.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(r.matrixWorld), c.nearDistance = o, c.farDistance = s), c;
  }

  function M(n, i, o, s, a) {
    if (!1 === n.visible) return;

    if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || r.intersectsObject(n))) {
      n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
      const i = e.update(n),
            r = n.material;

      if (Array.isArray(r)) {
        const e = i.groups;

        for (let c = 0, l = e.length; c < l; c++) {
          const l = e[c],
                u = r[l.materialIndex];

          if (u && u.visible) {
            const e = w(n, i, u, s, o.near, o.far, a);
            t.renderBufferDirect(o, null, i, e, n, l);
          }
        }
      } else if (r.visible) {
        const e = w(n, i, r, s, o.near, o.far, a);
        t.renderBufferDirect(o, null, i, e, n, null);
      }
    }

    const c = n.children;

    for (let t = 0, e = c.length; t < e; t++) M(c[t], i, o, s, a);
  }

  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, i, c) {
    if (!1 === y.enabled) return;
    if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
    if (0 === e.length) return;
    const l = t.getRenderTarget(),
          h = t.getActiveCubeFace(),
          d = t.getActiveMipmapLevel(),
          p = t.state;
    p.setBlending(0), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);

    for (let l = 0, h = e.length; l < h; l++) {
      const h = e[l],
            d = h.shadow;
      if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue;

      if (void 0 === d) {
        console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
        continue;
      }

      o.copy(d.mapSize);
      const f = d.getFrameExtents();

      if (o.multiply(f), s.copy(d.mapSize), (o.x > n || o.y > n) && (o.x > n && (s.x = Math.floor(n / f.x), o.x = s.x * f.x, d.mapSize.x = s.x), o.y > n && (s.y = Math.floor(n / f.y), o.y = s.y * f.y, d.mapSize.y = s.y)), null === d.map && !d.isPointLightShadow && 3 === this.type) {
        const t = {
          minFilter: 1006,
          magFilter: 1006,
          format: 1023
        };
        d.map = new u(o.x, o.y, t), d.map.texture.name = h.name + ".shadowMap", d.mapPass = new u(o.x, o.y, t), d.camera.updateProjectionMatrix();
      }

      if (null === d.map) {
        const t = {
          minFilter: 1003,
          magFilter: 1003,
          format: 1023
        };
        d.map = new u(o.x, o.y, t), d.map.texture.name = h.name + ".shadowMap", d.camera.updateProjectionMatrix();
      }

      t.setRenderTarget(d.map), t.clear();
      const m = d.getViewportCount();

      for (let t = 0; t < m; t++) {
        const e = d.getViewport(t);
        a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), p.viewport(a), d.updateMatrices(h, t), r = d.getFrustum(), M(i, c, d.camera, h, this.type);
      }

      d.isPointLightShadow || 3 !== this.type || x(d, c), d.needsUpdate = !1;
    }

    y.needsUpdate = !1, t.setRenderTarget(l, h, d);
  };
}

function qi(t, e, n) {
  const i = n.isWebGL2,
        r = new function () {
    let e = !1;
    const n = new l();
    let i = null;
    const r = new l(0, 0, 0, 0);
    return {
      setMask: function (n) {
        i === n || e || (t.colorMask(n, n, n, n), i = n);
      },
      setLocked: function (t) {
        e = t;
      },
      setClear: function (e, i, o, s, a) {
        !0 === a && (e *= s, i *= s, o *= s), n.set(e, i, o, s), !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n));
      },
      reset: function () {
        e = !1, i = null, r.set(-1, 0, 0, 0);
      }
    };
  }(),
        o = new function () {
    let e = !1,
        n = null,
        i = null,
        r = null;
    return {
      setTest: function (t) {
        t ? D(2929) : I(2929);
      },
      setMask: function (i) {
        n === i || e || (t.depthMask(i), n = i);
      },
      setFunc: function (e) {
        if (i !== e) {
          if (e) switch (e) {
            case 0:
              t.depthFunc(512);
              break;

            case 1:
              t.depthFunc(519);
              break;

            case 2:
              t.depthFunc(513);
              break;

            case 3:
              t.depthFunc(515);
              break;

            case 4:
              t.depthFunc(514);
              break;

            case 5:
              t.depthFunc(518);
              break;

            case 6:
              t.depthFunc(516);
              break;

            case 7:
              t.depthFunc(517);
              break;

            default:
              t.depthFunc(515);
          } else t.depthFunc(515);
          i = e;
        }
      },
      setLocked: function (t) {
        e = t;
      },
      setClear: function (e) {
        r !== e && (t.clearDepth(e), r = e);
      },
      reset: function () {
        e = !1, n = null, i = null, r = null;
      }
    };
  }(),
        s = new function () {
    let e = !1,
        n = null,
        i = null,
        r = null,
        o = null,
        s = null,
        a = null,
        c = null,
        l = null;
    return {
      setTest: function (t) {
        e || (t ? D(2960) : I(2960));
      },
      setMask: function (i) {
        n === i || e || (t.stencilMask(i), n = i);
      },
      setFunc: function (e, n, s) {
        i === e && r === n && o === s || (t.stencilFunc(e, n, s), i = e, r = n, o = s);
      },
      setOp: function (e, n, i) {
        s === e && a === n && c === i || (t.stencilOp(e, n, i), s = e, a = n, c = i);
      },
      setLocked: function (t) {
        e = t;
      },
      setClear: function (e) {
        l !== e && (t.clearStencil(e), l = e);
      },
      reset: function () {
        e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null;
      }
    };
  }();
  let a = {},
      c = null,
      u = null,
      h = null,
      d = null,
      p = null,
      f = null,
      m = null,
      g = null,
      v = null,
      y = !1,
      x = null,
      _ = null,
      b = null,
      w = null,
      M = null;
  const S = t.getParameter(35661);
  let E = !1,
      T = 0;
  const A = t.getParameter(7938);
  -1 !== A.indexOf("WebGL") ? (T = parseFloat(/^WebGL\ ([0-9])/.exec(A)[1]), E = T >= 1) : -1 !== A.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(A)[1]), E = T >= 2);
  let L = null,
      C = {};
  const R = new l(),
        P = new l();

  function O(e, n, i) {
    const r = new Uint8Array(4),
          o = t.createTexture();
    t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);

    for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);

    return o;
  }

  const N = {};

  function D(e) {
    !0 !== a[e] && (t.enable(e), a[e] = !0);
  }

  function I(e) {
    !1 !== a[e] && (t.disable(e), a[e] = !1);
  }

  N[3553] = O(3553, 3553, 1), N[34067] = O(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), s.setClear(0), D(2929), o.setFunc(3), H(!1), F(1), D(2884), k(0);
  const z = {
    100: 32774,
    101: 32778,
    102: 32779
  };
  if (i) z[103] = 32775, z[104] = 32776;else {
    const t = e.get("EXT_blend_minmax");
    null !== t && (z[103] = t.MIN_EXT, z[104] = t.MAX_EXT);
  }
  const B = {
    200: 0,
    201: 1,
    202: 768,
    204: 770,
    210: 776,
    208: 774,
    206: 772,
    203: 769,
    205: 771,
    209: 775,
    207: 773
  };

  function k(e, n, i, r, o, s, a, c) {
    if (0 !== e) {
      if (u || (D(3042), u = !0), 5 === e) o = o || n, s = s || i, a = a || r, n === d && o === m || (t.blendEquationSeparate(z[n], z[o]), d = n, m = o), i === p && r === f && s === g && a === v || (t.blendFuncSeparate(B[i], B[r], B[s], B[a]), p = i, f = r, g = s, v = a), h = e, y = null;else if (e !== h || c !== y) {
        if (100 === d && 100 === m || (t.blendEquation(32774), d = 100, m = 100), c) switch (e) {
          case 1:
            t.blendFuncSeparate(1, 771, 1, 771);
            break;

          case 2:
            t.blendFunc(1, 1);
            break;

          case 3:
            t.blendFuncSeparate(0, 0, 769, 771);
            break;

          case 4:
            t.blendFuncSeparate(0, 768, 0, 770);
            break;

          default:
            console.error("THREE.WebGLState: Invalid blending: ", e);
        } else switch (e) {
          case 1:
            t.blendFuncSeparate(770, 771, 1, 771);
            break;

          case 2:
            t.blendFunc(770, 1);
            break;

          case 3:
            t.blendFunc(0, 769);
            break;

          case 4:
            t.blendFunc(0, 768);
            break;

          default:
            console.error("THREE.WebGLState: Invalid blending: ", e);
        }
        p = null, f = null, g = null, v = null, h = e, y = c;
      }
    } else u && (I(3042), u = !1);
  }

  function H(e) {
    x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), x = e);
  }

  function F(e) {
    0 !== e ? (D(2884), e !== _ && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : I(2884), _ = e;
  }

  function U(e, n, i) {
    e ? (D(32823), w === n && M === i || (t.polygonOffset(n, i), w = n, M = i)) : I(32823);
  }

  function G(e) {
    void 0 === e && (e = 33984 + S - 1), L !== e && (t.activeTexture(e), L = e);
  }

  return {
    buffers: {
      color: r,
      depth: o,
      stencil: s
    },
    enable: D,
    disable: I,
    useProgram: function (e) {
      return c !== e && (t.useProgram(e), c = e, !0);
    },
    setBlending: k,
    setMaterial: function (t, e) {
      2 === t.side ? I(2884) : D(2884);
      let n = 1 === t.side;
      e && (n = !n), H(n), 1 === t.blending && !1 === t.transparent ? k(0) : k(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite);
      const i = t.stencilWrite;
      s.setTest(i), i && (s.setMask(t.stencilWriteMask), s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), U(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
    },
    setFlipSided: H,
    setCullFace: F,
    setLineWidth: function (e) {
      e !== b && (E && t.lineWidth(e), b = e);
    },
    setPolygonOffset: U,
    setScissorTest: function (t) {
      t ? D(3089) : I(3089);
    },
    activeTexture: G,
    bindTexture: function (e, n) {
      null === L && G();
      let i = C[L];
      void 0 === i && (i = {
        type: void 0,
        texture: void 0
      }, C[L] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || N[e]), i.type = e, i.texture = n);
    },
    unbindTexture: function () {
      const e = C[L];
      void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0);
    },
    compressedTexImage2D: function () {
      try {
        t.compressedTexImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage2D: function () {
      try {
        t.texImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage3D: function () {
      try {
        t.texImage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    scissor: function (e) {
      !1 === R.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), R.copy(e));
    },
    viewport: function (e) {
      !1 === P.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), P.copy(e));
    },
    reset: function () {
      a = {}, L = null, C = {}, c = null, h = null, x = null, _ = null, r.reset(), o.reset(), s.reset();
    }
  };
}

function Xi(t, e, i, r, o, s, a) {
  const c = o.isWebGL2,
        l = o.maxTextures,
        u = o.maxCubemapSize,
        h = o.maxTextureSize,
        d = o.maxSamples,
        p = new WeakMap();
  let f,
      m = !1;

  try {
    m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (t) {}

  function g(t, e) {
    return m ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }

  function v(t, e, i, r) {
    let o = 1;

    if ((t.width > r || t.height > r) && (o = r / Math.max(t.width, t.height)), o < 1 || !0 === e) {
      if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
        const r = e ? n.floorPowerOfTwo : Math.floor,
              s = r(o * t.width),
              a = r(o * t.height);
        void 0 === f && (f = g(s, a));
        const c = i ? g(s, a) : f;
        return c.width = s, c.height = a, c.getContext("2d").drawImage(t, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."), c;
      }

      return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
    }

    return t;
  }

  function y(t) {
    return n.isPowerOfTwo(t.width) && n.isPowerOfTwo(t.height);
  }

  function x(t, e) {
    return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter;
  }

  function _(e, n, i, o) {
    t.generateMipmap(e), r.get(n).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E;
  }

  function b(n, i, r) {
    if (!1 === c) return i;

    if (null !== n) {
      if (void 0 !== t[n]) return t[n];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'");
    }

    let o = i;
    return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o;
  }

  function w(t) {
    return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
  }

  function M(e) {
    const n = e.target;
    n.removeEventListener("dispose", M), function (e) {
      const n = r.get(e);
      void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), r.remove(e));
    }(n), n.isVideoTexture && p.delete(n), a.memory.textures--;
  }

  function S(e) {
    const n = e.target;
    n.removeEventListener("dispose", S), function (e) {
      const n = r.get(e),
            i = r.get(e.texture);

      if (e) {
        if (void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++) t.deleteFramebuffer(n.__webglFramebuffer[e]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e]);else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
        r.remove(e.texture), r.remove(e);
      }
    }(n), a.memory.textures--;
  }

  let E = 0;

  function T(t, e) {
    const n = r.get(t);

    if (t.isVideoTexture && function (t) {
      const e = a.render.frame;
      p.get(t) !== e && (p.set(t, e), t.update());
    }(t), t.version > 0 && n.__version !== t.version) {
      const i = t.image;
      if (void 0 === i) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else {
        if (!1 !== i.complete) return void N(n, t, e);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }

    i.activeTexture(33984 + e), i.bindTexture(3553, n.__webglTexture);
  }

  function A(e, n) {
    if (6 !== e.image.length) return;
    const o = r.get(e);

    if (e.version > 0 && o.__version !== e.version) {
      O(o, e), i.activeTexture(33984 + n), i.bindTexture(34067, o.__webglTexture), t.pixelStorei(37440, e.flipY);
      const r = e && (e.isCompressedTexture || e.image[0].isCompressedTexture),
            a = e.image[0] && e.image[0].isDataTexture,
            l = [];

      for (let t = 0; t < 6; t++) l[t] = r || a ? a ? e.image[t].image : e.image[t] : v(e.image[t], !1, !0, u);

      const h = l[0],
            d = y(h) || c,
            p = s.convert(e.format),
            f = s.convert(e.type),
            m = b(e.internalFormat, p, f);
      let g;

      if (P(34067, e, d), r) {
        for (let t = 0; t < 6; t++) {
          g = l[t].mipmaps;

          for (let n = 0; n < g.length; n++) {
            const r = g[n];
            1023 !== e.format && 1022 !== e.format ? null !== p ? i.compressedTexImage2D(34069 + t, n, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + t, n, m, r.width, r.height, 0, p, f, r.data);
          }
        }

        o.__maxMipLevel = g.length - 1;
      } else {
        g = e.mipmaps;

        for (let t = 0; t < 6; t++) if (a) {
          i.texImage2D(34069 + t, 0, m, l[t].width, l[t].height, 0, p, f, l[t].data);

          for (let e = 0; e < g.length; e++) {
            const n = g[e].image[t].image;
            i.texImage2D(34069 + t, e + 1, m, n.width, n.height, 0, p, f, n.data);
          }
        } else {
          i.texImage2D(34069 + t, 0, m, p, f, l[t]);

          for (let e = 0; e < g.length; e++) {
            const n = g[e];
            i.texImage2D(34069 + t, e + 1, m, p, f, n.image[t]);
          }
        }

        o.__maxMipLevel = g.length;
      }

      x(e, d) && _(34067, e, h.width, h.height), o.__version = e.version, e.onUpdate && e.onUpdate(e);
    } else i.activeTexture(33984 + n), i.bindTexture(34067, o.__webglTexture);
  }

  function L(t, e) {
    i.activeTexture(33984 + e), i.bindTexture(34067, r.get(t).__webglTexture);
  }

  const C = {
    1e3: 10497,
    1001: 33071,
    1002: 33648
  },
        R = {
    1003: 9728,
    1004: 9984,
    1005: 9986,
    1006: 9729,
    1007: 9985,
    1008: 9987
  };

  function P(n, i, s) {
    s ? (t.texParameteri(n, 10242, C[i.wrapS]), t.texParameteri(n, 10243, C[i.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, C[i.wrapR]), t.texParameteri(n, 10240, R[i.magFilter]), t.texParameteri(n, 10241, R[i.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), 1001 === i.wrapS && 1001 === i.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(i.magFilter)), t.texParameteri(n, 10241, w(i.minFilter)), 1003 !== i.minFilter && 1006 !== i.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
    const a = e.get("EXT_texture_filter_anisotropic");

    if (a) {
      if (1015 === i.type && null === e.get("OES_texture_float_linear")) return;
      if (1016 === i.type && null === (c || e.get("OES_texture_half_float_linear"))) return;
      (i.anisotropy > 1 || r.get(i).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i.anisotropy, o.getMaxAnisotropy())), r.get(i).__currentAnisotropy = i.anisotropy);
    }
  }

  function O(e, n) {
    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", M), e.__webglTexture = t.createTexture(), a.memory.textures++);
  }

  function N(e, n, r) {
    let o = 3553;
    n.isDataTexture2DArray && (o = 35866), n.isDataTexture3D && (o = 32879), O(e, n), i.activeTexture(33984 + r), i.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment);

    const a = function (t) {
      return !c && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter);
    }(n) && !1 === y(n.image),
          l = v(n.image, a, !1, h),
          u = y(l) || c,
          d = s.convert(n.format);

    let p,
        f = s.convert(n.type),
        m = b(n.internalFormat, d, f);
    P(o, n, u);
    const g = n.mipmaps;
    if (n.isDepthTexture) m = 6402, c ? m = 1015 === n.type ? 36012 : 1014 === n.type ? 33190 : 1020 === n.type ? 35056 : 33189 : 1015 === n.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === n.format && 6402 === m && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, f = s.convert(n.type)), 1027 === n.format && 6402 === m && (m = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, f = s.convert(n.type))), i.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);else if (n.isDataTexture) {
      if (g.length > 0 && u) {
        for (let t = 0, e = g.length; t < e; t++) p = g[t], i.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);

        n.generateMipmaps = !1, e.__maxMipLevel = g.length - 1;
      } else i.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data), e.__maxMipLevel = 0;
    } else if (n.isCompressedTexture) {
      for (let t = 0, e = g.length; t < e; t++) p = g[t], 1023 !== n.format && 1022 !== n.format ? null !== d ? i.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);

      e.__maxMipLevel = g.length - 1;
    } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0;else if (n.isDataTexture3D) i.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0;else if (g.length > 0 && u) {
      for (let t = 0, e = g.length; t < e; t++) p = g[t], i.texImage2D(3553, t, m, d, f, p);

      n.generateMipmaps = !1, e.__maxMipLevel = g.length - 1;
    } else i.texImage2D(3553, 0, m, d, f, l), e.__maxMipLevel = 0;
    x(n, u) && _(o, n, l.width, l.height), e.__version = n.version, n.onUpdate && n.onUpdate(n);
  }

  function D(e, n, o, a) {
    const c = s.convert(n.texture.format),
          l = s.convert(n.texture.type),
          u = b(n.texture.internalFormat, c, l);
    i.texImage2D(a, 0, u, n.width, n.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, a, r.get(n.texture).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }

  function I(e, n, i) {
    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
      let r = 33189;

      if (i) {
        const e = n.depthTexture;
        e && e.isDepthTexture && (1015 === e.type ? r = 36012 : 1014 === e.type && (r = 33190));
        const i = z(n);
        t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
      } else t.renderbufferStorage(36161, r, n.width, n.height);

      t.framebufferRenderbuffer(36160, 36096, 36161, e);
    } else if (n.depthBuffer && n.stencilBuffer) {
      if (i) {
        const e = z(n);
        t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height);
      } else t.renderbufferStorage(36161, 34041, n.width, n.height);

      t.framebufferRenderbuffer(36160, 33306, 36161, e);
    } else {
      const e = s.convert(n.texture.format),
            r = s.convert(n.texture.type),
            o = b(n.texture.internalFormat, e, r);

      if (i) {
        const e = z(n);
        t.renderbufferStorageMultisample(36161, e, o, n.width, n.height);
      } else t.renderbufferStorage(36161, o, n.width, n.height);
    }

    t.bindRenderbuffer(36161, null);
  }

  function z(t) {
    return c && t.isWebGLMultisampleRenderTarget ? Math.min(d, t.samples) : 0;
  }

  let B = !1,
      k = !1;
  this.allocateTextureUnit = function () {
    const t = E;
    return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), E += 1, t;
  }, this.resetTextureUnits = function () {
    E = 0;
  }, this.setTexture2D = T, this.setTexture2DArray = function (t, e) {
    const n = r.get(t);
    t.version > 0 && n.__version !== t.version ? N(n, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, n.__webglTexture));
  }, this.setTexture3D = function (t, e) {
    const n = r.get(t);
    t.version > 0 && n.__version !== t.version ? N(n, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, n.__webglTexture));
  }, this.setTextureCube = A, this.setTextureCubeDynamic = L, this.setupRenderTarget = function (e) {
    const n = r.get(e),
          o = r.get(e.texture);
    e.addEventListener("dispose", S), o.__webglTexture = t.createTexture(), a.memory.textures++;
    const l = !0 === e.isWebGLCubeRenderTarget,
          u = !0 === e.isWebGLMultisampleRenderTarget,
          h = y(e) || c;

    if (!c || 1022 !== e.texture.format || 1015 !== e.texture.type && 1016 !== e.texture.type || (e.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), l) {
      n.__webglFramebuffer = [];

      for (let e = 0; e < 6; e++) n.__webglFramebuffer[e] = t.createFramebuffer();
    } else if (n.__webglFramebuffer = t.createFramebuffer(), u) if (c) {
      n.__webglMultisampledFramebuffer = t.createFramebuffer(), n.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, n.__webglColorRenderbuffer);
      const i = s.convert(e.texture.format),
            r = s.convert(e.texture.type),
            o = b(e.texture.internalFormat, i, r),
            a = z(e);
      t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, n.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (n.__webglDepthRenderbuffer = t.createRenderbuffer(), I(n.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null);
    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");

    if (l) {
      i.bindTexture(34067, o.__webglTexture), P(34067, e.texture, h);

      for (let t = 0; t < 6; t++) D(n.__webglFramebuffer[t], e, 36064, 34069 + t);

      x(e.texture, h) && _(34067, e.texture, e.width, e.height), i.bindTexture(34067, null);
    } else i.bindTexture(3553, o.__webglTexture), P(3553, e.texture, h), D(n.__webglFramebuffer, e, 36064, 3553), x(e.texture, h) && _(3553, e.texture, e.width, e.height), i.bindTexture(3553, null);

    e.depthBuffer && function (e) {
      const n = r.get(e),
            i = !0 === e.isWebGLCubeRenderTarget;

      if (e.depthTexture) {
        if (i) throw new Error("target.depthTexture not supported in Cube render targets");
        !function (e, n) {
          if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), T(n.depthTexture, 0);

          const i = r.get(n.depthTexture).__webglTexture;

          if (1026 === n.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, i, 0);else {
            if (1027 !== n.depthTexture.format) throw new Error("Unknown depthTexture format");
            t.framebufferTexture2D(36160, 33306, 3553, i, 0);
          }
        }(n.__webglFramebuffer, e);
      } else if (i) {
        n.__webglDepthbuffer = [];

        for (let i = 0; i < 6; i++) t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), I(n.__webglDepthbuffer[i], e, !1);
      } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), I(n.__webglDepthbuffer, e, !1);

      t.bindFramebuffer(36160, null);
    }(e);
  }, this.updateRenderTargetMipmap = function (t) {
    const e = t.texture;

    if (x(e, y(t) || c)) {
      const n = t.isWebGLCubeRenderTarget ? 34067 : 3553,
            o = r.get(e).__webglTexture;

      i.bindTexture(n, o), _(n, e, t.width, t.height), i.bindTexture(n, null);
    }
  }, this.updateMultisampleRenderTarget = function (e) {
    if (e.isWebGLMultisampleRenderTarget) if (c) {
      const n = r.get(e);
      t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
      const i = e.width,
            o = e.height;
      let s = 16384;
      e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, s, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }, this.safeSetTexture2D = function (t, e) {
    t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), T(t, e);
  }, this.safeSetTextureCube = function (t, e) {
    t && t.isWebGLCubeRenderTarget && (!1 === k && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), k = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? A(t, e) : L(t, e);
  };
}

function Yi(t, e, n) {
  const i = n.isWebGL2;
  return {
    convert: function (t) {
      let n;
      if (1009 === t) return 5121;
      if (1017 === t) return 32819;
      if (1018 === t) return 32820;
      if (1019 === t) return 33635;
      if (1010 === t) return 5120;
      if (1011 === t) return 5122;
      if (1012 === t) return 5123;
      if (1013 === t) return 5124;
      if (1014 === t) return 5125;
      if (1015 === t) return 5126;
      if (1016 === t) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
      if (1021 === t) return 6406;
      if (1022 === t) return 6407;
      if (1023 === t) return 6408;
      if (1024 === t) return 6409;
      if (1025 === t) return 6410;
      if (1026 === t) return 6402;
      if (1027 === t) return 34041;
      if (1028 === t) return 6403;
      if (1029 === t) return 36244;
      if (1030 === t) return 33319;
      if (1031 === t) return 33320;
      if (1032 === t) return 36248;
      if (1033 === t) return 36249;

      if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
        if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
        if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }

      if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
        if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
        if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }

      if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;

      if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
        if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
        if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
      }

      return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : 1020 === t ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
    }
  };
}

function Zi(t) {
  He.call(this), this.cameras = t || [];
}

function Ji() {
  U.call(this), this.type = "Group";
}

function Qi() {
  this._targetRay = null, this._grip = null;
}

function Ki(t, e) {
  const n = this;
  let i = null,
      r = 1,
      o = null,
      s = "local-floor",
      a = null;
  const c = [],
        u = new Map(),
        h = new He();
  h.layers.enable(1), h.viewport = new l();
  const d = new He();
  d.layers.enable(2), d.viewport = new l();
  const p = [h, d],
        f = new Zi();
  f.layers.enable(1), f.layers.enable(2);
  let g = null,
      v = null;

  function y(t) {
    const e = u.get(t.inputSource);
    e && e.dispatchEvent({
      type: t.type
    });
  }

  function x() {
    u.forEach(function (t, e) {
      t.disconnect(e);
    }), u.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), T.stop(), n.isPresenting = !1, n.dispatchEvent({
      type: "sessionend"
    });
  }

  function _(t) {
    o = t, T.setContext(i), T.start(), n.isPresenting = !0, n.dispatchEvent({
      type: "sessionstart"
    });
  }

  function b(t) {
    const e = i.inputSources;

    for (let t = 0; t < c.length; t++) u.set(e[t], c[t]);

    for (let e = 0; e < t.removed.length; e++) {
      const n = t.removed[e],
            i = u.get(n);
      i && (i.dispatchEvent({
        type: "disconnected",
        data: n
      }), u.delete(n));
    }

    for (let e = 0; e < t.added.length; e++) {
      const n = t.added[e],
            i = u.get(n);
      i && i.dispatchEvent({
        type: "connected",
        data: n
      });
    }
  }

  this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
    let e = c[t];
    return void 0 === e && (e = new Qi(), c[t] = e), e.getTargetRaySpace();
  }, this.getControllerGrip = function (t) {
    let e = c[t];
    return void 0 === e && (e = new Qi(), c[t] = e), e.getGripSpace();
  }, this.setFramebufferScaleFactor = function (t) {
    r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
  }, this.setReferenceSpaceType = function (t) {
    s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
  }, this.getReferenceSpace = function () {
    return o;
  }, this.getSession = function () {
    return i;
  }, this.setSession = function (t) {
    if (i = t, null !== i) {
      i.addEventListener("select", y), i.addEventListener("selectstart", y), i.addEventListener("selectend", y), i.addEventListener("squeeze", y), i.addEventListener("squeezestart", y), i.addEventListener("squeezeend", y), i.addEventListener("end", x);
      const t = e.getContextAttributes();
      !0 !== t.xrCompatible && e.makeXRCompatible();
      const n = {
        antialias: t.antialias,
        alpha: t.alpha,
        depth: t.depth,
        stencil: t.stencil,
        framebufferScaleFactor: r
      },
            o = new XRWebGLLayer(i, e, n);
      i.updateRenderState({
        baseLayer: o
      }), i.requestReferenceSpace(s).then(_), i.addEventListener("inputsourceschange", b);
    }
  };
  const w = new m(),
        M = new m();

  function S(t, e) {
    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld);
  }

  this.getCamera = function (t) {
    f.near = d.near = h.near = t.near, f.far = d.far = h.far = t.far, g === f.near && v === f.far || (i.updateRenderState({
      depthNear: f.near,
      depthFar: f.far
    }), g = f.near, v = f.far);
    const e = t.parent,
          n = f.cameras;
    S(f, e);

    for (let t = 0; t < n.length; t++) S(n[t], e);

    t.matrixWorld.copy(f.matrixWorld);
    const r = t.children;

    for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);

    return 2 === n.length ? function (t, e, n) {
      w.setFromMatrixPosition(e.matrixWorld), M.setFromMatrixPosition(n.matrixWorld);
      const i = w.distanceTo(M),
            r = e.projectionMatrix.elements,
            o = n.projectionMatrix.elements,
            s = r[14] / (r[10] - 1),
            a = r[14] / (r[10] + 1),
            c = (r[9] + 1) / r[5],
            l = (r[9] - 1) / r[5],
            u = (r[8] - 1) / r[0],
            h = (o[8] + 1) / o[0],
            d = s * u,
            p = s * h,
            f = i / (-u + h),
            m = f * -u;
      e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);

      const g = s + f,
            v = a + f,
            y = d - m,
            x = p + (i - m),
            _ = c * a / v * g,
            b = l * a / v * g;

      t.projectionMatrix.makePerspective(y, x, _, b, g, v);
    }(f, h, d) : f.projectionMatrix.copy(h.projectionMatrix), f;
  };

  let E = null;
  const T = new Xe();
  T.setAnimationLoop(function (e, n) {
    if (a = n.getViewerPose(o), null !== a) {
      const e = a.views,
            n = i.renderState.baseLayer;
      t.setFramebuffer(n.framebuffer);
      let r = !1;
      e.length !== f.cameras.length && (f.cameras.length = 0, r = !0);

      for (let t = 0; t < e.length; t++) {
        const i = e[t],
              o = n.getViewport(i),
              s = p[t];
        s.matrix.fromArray(i.transform.matrix), s.projectionMatrix.fromArray(i.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === t && f.matrix.copy(s.matrix), !0 === r && f.cameras.push(s);
      }
    }

    const r = i.inputSources;

    for (let t = 0; t < c.length; t++) {
      const e = c[t],
            i = r[t];
      e.update(i, n, o);
    }

    E && E(e, n);
  }), this.setAnimationLoop = function (t) {
    E = t;
  }, this.dispose = function () {};
}

function $i(t) {
  function e(e, n, i) {
    e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
    const r = n.envMap || i;
    let o, s;
    r && (e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio, e.maxMipLevel.value = t.get(r).__maxMipLevel), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? o = n.map : n.specularMap ? o = n.specularMap : n.displacementMap ? o = n.displacementMap : n.normalMap ? o = n.normalMap : n.bumpMap ? o = n.bumpMap : n.roughnessMap ? o = n.roughnessMap : n.metalnessMap ? o = n.metalnessMap : n.alphaMap ? o = n.alphaMap : n.emissiveMap && (o = n.emissiveMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uvTransform.value.copy(o.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix));
  }

  function n(t, e, n) {
    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity);
  }

  return {
    refreshFogUniforms: function (t, e) {
      t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density);
    },
    refreshMaterialUniforms: function (t, i, r, o, s) {
      i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function (t, e) {
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
      }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function (t, e) {
        e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function (t, e) {
        t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshStandardMaterial ? (e(t, i, r), i.isMeshPhysicalMaterial ? function (t, e, i) {
        n(t, e, i), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()), t.transparency.value = e.transparency;
      }(t, i, r) : n(t, i, r)) : i.isMeshMatcapMaterial ? (e(t, i), function (t, e) {
        e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function (t, e) {
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function (t, e) {
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance;
      }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function (t, e) {
        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
      }(t, i)) : i.isLineBasicMaterial ? (function (t, e) {
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity;
      }(t, i), i.isLineDashedMaterial && function (t, e) {
        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale;
      }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) {
        let r;
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? r = e.map : e.alphaMap && (r = e.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix));
      }(t, i, o, s) : i.isSpriteMaterial ? function (t, e) {
        let n;
        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix));
      }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
    }
  };
}

function tr(t) {
  const e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
        r = void 0 !== t.context ? t.context : null,
        o = void 0 !== t.alpha && t.alpha,
        s = void 0 === t.depth || t.depth,
        a = void 0 === t.stencil || t.stencil,
        c = void 0 !== t.antialias && t.antialias,
        u = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        h = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        d = void 0 !== t.powerPreference ? t.powerPreference : "default",
        p = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
  let f = null,
      g = null;
  this.domElement = e, this.debug = {
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
  const v = this;
  let y = !1,
      x = null,
      _ = 0,
      b = 0,
      w = null,
      S = null,
      E = -1,
      T = null,
      A = null;
  const L = new l(),
        C = new l();
  let R = null,
      P = e.width,
      O = e.height,
      N = 1,
      D = null,
      I = null;
  const z = new l(0, 0, P, O),
        B = new l(0, 0, P, O);
  let k = !1;
  const H = new We(),
        F = new rn();
  let U = !1,
      G = !1;
  const j = new M(),
        V = new m(),
        W = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: !0
  };

  function q() {
    return null === w ? N : 1;
  }

  let X,
      Y,
      Z,
      J,
      Q,
      K,
      $,
      tt,
      et,
      nt,
      it,
      rt,
      ot,
      st,
      at,
      ct,
      lt,
      ut,
      ht,
      dt = r;

  function pt(t, n) {
    for (let i = 0; i < t.length; i++) {
      const r = t[i],
            o = e.getContext(r, n);
      if (null !== o) return o;
    }

    return null;
  }

  try {
    const t = {
      alpha: o,
      depth: s,
      stencil: a,
      antialias: c,
      premultipliedAlpha: u,
      preserveDrawingBuffer: h,
      powerPreference: d,
      failIfMajorPerformanceCaveat: p
    };

    if (e.addEventListener("webglcontextlost", vt, !1), e.addEventListener("webglcontextrestored", yt, !1), null === dt) {
      const e = ["webgl2", "webgl", "experimental-webgl"];
      if (!0 === v.isWebGL1Renderer && e.shift(), dt = pt(e, t), null === dt) throw pt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }

    void 0 === dt.getShaderPrecisionFormat && (dt.getShaderPrecisionFormat = function () {
      return {
        rangeMin: 1,
        rangeMax: 1,
        precision: 1
      };
    });
  } catch (t) {
    throw console.error("THREE.WebGLRenderer: " + t.message), t;
  }

  function ft() {
    X = new on(dt), Y = new nn(dt, X, t), !1 === Y.isWebGL2 && (X.get("WEBGL_depth_texture"), X.get("OES_texture_float"), X.get("OES_texture_half_float"), X.get("OES_texture_half_float_linear"), X.get("OES_standard_derivatives"), X.get("OES_element_index_uint"), X.get("OES_vertex_array_object"), X.get("ANGLE_instanced_arrays")), X.get("OES_texture_float_linear"), ut = new Yi(dt, X, Y), Z = new qi(dt, X, Y), Z.scissor(C.copy(B).multiplyScalar(N).floor()), Z.viewport(L.copy(z).multiplyScalar(N).floor()), J = new cn(dt), Q = new Oi(), K = new Xi(dt, X, Z, Q, Y, ut, J), $ = new Ye(dt, Y), ht = new tn(dt, X, $, Y), tt = new sn(dt, $, J, ht), et = new dn(dt, tt, $, J), at = new hn(dt), nt = new Pi(v, X, Y, ht), it = new $i(Q), rt = new zi(), ot = new Gi(), st = new $e(v, Z, et, u), ct = new en(dt, X, J, Y), lt = new an(dt, X, J, Y), J.programs = nt.programs, v.capabilities = Y, v.extensions = X, v.properties = Q, v.renderLists = rt, v.state = Z, v.info = J;
  }

  ft();
  const mt = new Ki(v, dt);
  this.xr = mt;
  const gt = new Wi(v, et, Y.maxTextureSize);

  function vt(t) {
    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0;
  }

  function yt() {
    console.log("THREE.WebGLRenderer: Context Restored."), y = !1, ft();
  }

  function xt(t) {
    const e = t.target;
    e.removeEventListener("dispose", xt), function (t) {
      _t(t), Q.remove(t);
    }(e);
  }

  function _t(t) {
    const e = Q.get(t).program;
    t.program = void 0, void 0 !== e && nt.releaseProgram(e);
  }

  this.shadowMap = gt, this.getContext = function () {
    return dt;
  }, this.getContextAttributes = function () {
    return dt.getContextAttributes();
  }, this.forceContextLoss = function () {
    const t = X.get("WEBGL_lose_context");
    t && t.loseContext();
  }, this.forceContextRestore = function () {
    const t = X.get("WEBGL_lose_context");
    t && t.restoreContext();
  }, this.getPixelRatio = function () {
    return N;
  }, this.setPixelRatio = function (t) {
    void 0 !== t && (N = t, this.setSize(P, O, !1));
  }, this.getSize = function (t) {
    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new i()), t.set(P, O);
  }, this.setSize = function (t, n, i) {
    mt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = t, O = n, e.width = Math.floor(t * N), e.height = Math.floor(n * N), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n));
  }, this.getDrawingBufferSize = function (t) {
    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new i()), t.set(P * N, O * N).floor();
  }, this.setDrawingBufferSize = function (t, n, i) {
    P = t, O = n, N = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n);
  }, this.getCurrentViewport = function (t) {
    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new l()), t.copy(L);
  }, this.getViewport = function (t) {
    return t.copy(z);
  }, this.setViewport = function (t, e, n, i) {
    t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, n, i), Z.viewport(L.copy(z).multiplyScalar(N).floor());
  }, this.getScissor = function (t) {
    return t.copy(B);
  }, this.setScissor = function (t, e, n, i) {
    t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i), Z.scissor(C.copy(B).multiplyScalar(N).floor());
  }, this.getScissorTest = function () {
    return k;
  }, this.setScissorTest = function (t) {
    Z.setScissorTest(k = t);
  }, this.setOpaqueSort = function (t) {
    D = t;
  }, this.setTransparentSort = function (t) {
    I = t;
  }, this.getClearColor = function () {
    return st.getClearColor();
  }, this.setClearColor = function () {
    st.setClearColor.apply(st, arguments);
  }, this.getClearAlpha = function () {
    return st.getClearAlpha();
  }, this.setClearAlpha = function () {
    st.setClearAlpha.apply(st, arguments);
  }, this.clear = function (t, e, n) {
    let i = 0;
    (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), dt.clear(i);
  }, this.clearColor = function () {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function () {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function () {
    this.clear(!1, !1, !0);
  }, this.dispose = function () {
    e.removeEventListener("webglcontextlost", vt, !1), e.removeEventListener("webglcontextrestored", yt, !1), rt.dispose(), ot.dispose(), Q.dispose(), et.dispose(), ht.dispose(), mt.dispose(), wt.stop();
  }, this.renderBufferImmediate = function (t, e) {
    ht.initAttributes();
    const n = Q.get(t);
    t.hasPositions && !n.position && (n.position = dt.createBuffer()), t.hasNormals && !n.normal && (n.normal = dt.createBuffer()), t.hasUvs && !n.uv && (n.uv = dt.createBuffer()), t.hasColors && !n.color && (n.color = dt.createBuffer());
    const i = e.getAttributes();
    t.hasPositions && (dt.bindBuffer(34962, n.position), dt.bufferData(34962, t.positionArray, 35048), ht.enableAttribute(i.position), dt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (dt.bindBuffer(34962, n.normal), dt.bufferData(34962, t.normalArray, 35048), ht.enableAttribute(i.normal), dt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (dt.bindBuffer(34962, n.uv), dt.bufferData(34962, t.uvArray, 35048), ht.enableAttribute(i.uv), dt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (dt.bindBuffer(34962, n.color), dt.bufferData(34962, t.colorArray, 35048), ht.enableAttribute(i.color), dt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), ht.disableUnusedAttributes(), dt.drawArrays(4, 0, t.count), t.count = 0;
  }, this.renderBufferDirect = function (t, e, n, i, r, o) {
    null === e && (e = W);
    const s = r.isMesh && r.matrixWorld.determinant() < 0,
          a = At(t, e, i, r);
    Z.setMaterial(i, s);
    let c = n.index;
    const l = n.attributes.position;

    if (null === c) {
      if (void 0 === l || 0 === l.count) return;
    } else if (0 === c.count) return;

    let u,
        h = 1;
    !0 === i.wireframe && (c = tt.getWireframeAttribute(n), h = 2), (i.morphTargets || i.morphNormals) && at.update(r, n, i, a), ht.setup(r, i, a, n, c);
    let d = ct;
    null !== c && (u = $.get(c), d = lt, d.setIndex(u));

    const p = null !== c ? c.count : l.count,
          f = n.drawRange.start * h,
          m = n.drawRange.count * h,
          g = null !== o ? o.start * h : 0,
          v = null !== o ? o.count * h : 1 / 0,
          y = Math.max(f, g),
          x = Math.min(p, f + m, g + v) - 1,
          _ = Math.max(0, x - y + 1);

    if (0 !== _) {
      if (r.isMesh) !0 === i.wireframe ? (Z.setLineWidth(i.wireframeLinewidth * q()), d.setMode(1)) : d.setMode(4);else if (r.isLine) {
        let t = i.linewidth;
        void 0 === t && (t = 1), Z.setLineWidth(t * q()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3);
      } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
      if (r.isInstancedMesh) d.renderInstances(n, y, _, r.count);else if (n.isInstancedBufferGeometry) {
        const t = Math.min(n.instanceCount, n._maxInstanceCount);
        d.renderInstances(n, y, _, t);
      } else d.render(y, _);
    }
  }, this.compile = function (t, e) {
    g = ot.get(t, e), g.init(), t.traverse(function (t) {
      t.isLight && (g.pushLight(t), t.castShadow && g.pushShadow(t));
    }), g.setupLights(e);
    const n = new WeakMap();
    t.traverse(function (e) {
      let i = e.material;
      if (i) if (Array.isArray(i)) for (let r = 0; r < i.length; r++) {
        let o = i[r];
        !1 === n.has(o) && (Tt(o, t, e), n.set(o));
      } else !1 === n.has(i) && (Tt(i, t, e), n.set(i));
    });
  };
  let bt = null;
  const wt = new Xe();

  function Mt(t, e, n, i) {
    if (!1 === t.visible) return;
    if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder;else if (t.isLOD) !0 === t.autoUpdate && t.update(e);else if (t.isLight) g.pushLight(t), t.castShadow && g.pushShadow(t);else if (t.isSprite) {
      if (!t.frustumCulled || H.intersectsSprite(t)) {
        i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
        const e = et.update(t),
              r = t.material;
        r.visible && f.push(t, e, r, n, V.z, null);
      }
    } else if (t.isImmediateRenderObject) i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j), f.push(t, null, t.material, n, V.z, null);else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== J.render.frame && (t.skeleton.update(), t.skeleton.frame = J.render.frame), !t.frustumCulled || H.intersectsObject(t))) {
      i && V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(j);
      const e = et.update(t),
            r = t.material;

      if (Array.isArray(r)) {
        const i = e.groups;

        for (let o = 0, s = i.length; o < s; o++) {
          const s = i[o],
                a = r[s.materialIndex];
          a && a.visible && f.push(t, e, a, n, V.z, s);
        }
      } else r.visible && f.push(t, e, r, n, V.z, null);
    }
    const r = t.children;

    for (let t = 0, o = r.length; t < o; t++) Mt(r[t], e, n, i);
  }

  function St(t, e, n) {
    const i = !0 === e.isScene ? e.overrideMaterial : null;

    for (let r = 0, o = t.length; r < o; r++) {
      const o = t[r],
            s = o.object,
            a = o.geometry,
            c = null === i ? o.material : i,
            l = o.group;

      if (n.isArrayCamera) {
        A = n;
        const t = n.cameras;

        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          s.layers.test(i.layers) && (Z.viewport(L.copy(i.viewport)), g.setupLights(i), Et(s, e, i, a, c, l));
        }
      } else A = null, Et(s, e, n, a, c, l);
    }
  }

  function Et(t, e, n, i, r, o) {
    if (t.onBeforeRender(v, e, n, i, r, o), g = ot.get(e, A || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
      const i = At(n, e, r, t);
      Z.setMaterial(r), ht.reset(), function (t, e) {
        t.render(function (t) {
          v.renderBufferImmediate(t, e);
        });
      }(t, i);
    } else v.renderBufferDirect(n, e, i, r, t, o);

    t.onAfterRender(v, e, n, i, r, o), g = ot.get(e, A || n);
  }

  function Tt(t, e, n) {
    !0 !== e.isScene && (e = W);
    const i = Q.get(t),
          r = g.state.lights,
          o = g.state.shadowsArray,
          s = r.state.version,
          a = nt.getParameters(t, r.state, o, e, F.numPlanes, F.numIntersection, n),
          c = nt.getProgramCacheKey(a);
    let l = i.program,
        u = !0;
    if (void 0 === l) t.addEventListener("dispose", xt);else if (l.cacheKey !== c) _t(t);else if (i.lightsStateVersion !== s) i.lightsStateVersion = s, u = !1;else {
      if (void 0 !== a.shaderID) return;
      u = !1;
    }
    u && (l = nt.acquireProgram(a, c), i.program = l, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding, t.program = l);
    const h = l.getAttributes();

    if (t.morphTargets) {
      t.numSupportedMorphTargets = 0;

      for (let e = 0; e < v.maxMorphTargets; e++) h["morphTarget" + e] >= 0 && t.numSupportedMorphTargets++;
    }

    if (t.morphNormals) {
      t.numSupportedMorphNormals = 0;

      for (let e = 0; e < v.maxMorphNormals; e++) h["morphNormal" + e] >= 0 && t.numSupportedMorphNormals++;
    }

    const d = i.uniforms;
    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = F.numPlanes, i.numIntersection = F.numIntersection, d.clippingPlanes = F.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.needsLights = function (t) {
      return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights;
    }(t), i.lightsStateVersion = s, i.needsLights && (d.ambientLightColor.value = r.state.ambient, d.lightProbe.value = r.state.probe, d.directionalLights.value = r.state.directional, d.directionalLightShadows.value = r.state.directionalShadow, d.spotLights.value = r.state.spot, d.spotLightShadows.value = r.state.spotShadow, d.rectAreaLights.value = r.state.rectArea, d.pointLights.value = r.state.point, d.pointLightShadows.value = r.state.pointShadow, d.hemisphereLights.value = r.state.hemi, d.directionalShadowMap.value = r.state.directionalShadowMap, d.directionalShadowMatrix.value = r.state.directionalShadowMatrix, d.spotShadowMap.value = r.state.spotShadowMap, d.spotShadowMatrix.value = r.state.spotShadowMatrix, d.pointShadowMap.value = r.state.pointShadowMap, d.pointShadowMatrix.value = r.state.pointShadowMatrix);
    const p = i.program.getUniforms(),
          f = ui.seqWithValue(p.seq, d);
    i.uniformsList = f;
  }

  function At(t, e, i, r) {
    !0 !== e.isScene && (e = W), K.resetTextureUnits();
    const o = e.fog,
          s = i.isMeshStandardMaterial ? e.environment : null,
          a = null === w ? v.outputEncoding : w.texture.encoding,
          c = Q.get(i),
          l = g.state.lights;

    if (!0 === U && (!0 === G || t !== T)) {
      const e = t === T && i.id === E;
      F.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, c, e);
    }

    i.version === c.__version ? void 0 === c.program || i.fog && c.fog !== o || c.environment !== s || c.needsLights && c.lightsStateVersion !== l.state.version ? Tt(i, e, r) : void 0 === c.numClippingPlanes || c.numClippingPlanes === F.numPlanes && c.numIntersection === F.numIntersection ? c.outputEncoding !== a && Tt(i, e, r) : Tt(i, e, r) : (Tt(i, e, r), c.__version = i.version);
    let u = !1,
        h = !1,
        d = !1;
    const p = c.program,
          f = p.getUniforms(),
          m = c.uniforms;

    if (Z.useProgram(p.program) && (u = !0, h = !0, d = !0), i.id !== E && (E = i.id, h = !0), u || T !== t) {
      if (f.setValue(dt, "projectionMatrix", t.projectionMatrix), Y.logarithmicDepthBuffer && f.setValue(dt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), T !== t && (T = t, h = !0, d = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
        const e = f.map.cameraPosition;
        void 0 !== e && e.setValue(dt, V.setFromMatrixPosition(t.matrixWorld));
      }

      (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && f.setValue(dt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || i.skinning) && f.setValue(dt, "viewMatrix", t.matrixWorldInverse);
    }

    if (i.skinning) {
      f.setOptional(dt, r, "bindMatrix"), f.setOptional(dt, r, "bindMatrixInverse");
      const t = r.skeleton;

      if (t) {
        const e = t.bones;

        if (Y.floatVertexTextures) {
          if (void 0 === t.boneTexture) {
            let i = Math.sqrt(4 * e.length);
            i = n.ceilPowerOfTwo(i), i = Math.max(i, 4);
            const r = new Float32Array(i * i * 4);
            r.set(t.boneMatrices);
            const o = new Ge(r, i, i, 1023, 1015);
            t.boneMatrices = r, t.boneTexture = o, t.boneTextureSize = i;
          }

          f.setValue(dt, "boneTexture", t.boneTexture, K), f.setValue(dt, "boneTextureSize", t.boneTextureSize);
        } else f.setOptional(dt, t, "boneMatrices");
      }
    }

    var y, x;
    return (h || c.receiveShadow !== r.receiveShadow) && (c.receiveShadow = r.receiveShadow, f.setValue(dt, "receiveShadow", r.receiveShadow)), h && (f.setValue(dt, "toneMappingExposure", v.toneMappingExposure), c.needsLights && (x = d, (y = m).ambientLightColor.needsUpdate = x, y.lightProbe.needsUpdate = x, y.directionalLights.needsUpdate = x, y.directionalLightShadows.needsUpdate = x, y.pointLights.needsUpdate = x, y.pointLightShadows.needsUpdate = x, y.spotLights.needsUpdate = x, y.spotLightShadows.needsUpdate = x, y.rectAreaLights.needsUpdate = x, y.hemisphereLights.needsUpdate = x), o && i.fog && it.refreshFogUniforms(m, o), it.refreshMaterialUniforms(m, i, s, N, O), void 0 !== m.ltc_1 && (m.ltc_1.value = qe.LTC_1), void 0 !== m.ltc_2 && (m.ltc_2.value = qe.LTC_2), ui.upload(dt, c.uniformsList, m, K)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ui.upload(dt, c.uniformsList, m, K), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && f.setValue(dt, "center", r.center), f.setValue(dt, "modelViewMatrix", r.modelViewMatrix), f.setValue(dt, "normalMatrix", r.normalMatrix), f.setValue(dt, "modelMatrix", r.matrixWorld), p;
  }

  wt.setAnimationLoop(function (t) {
    mt.isPresenting || bt && bt(t);
  }), "undefined" != typeof window && wt.setContext(window), this.setAnimationLoop = function (t) {
    bt = t, mt.setAnimationLoop(t), null === t ? wt.stop() : wt.start();
  }, this.render = function (t, e) {
    let n, i;
    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    if (!0 === y) return;
    ht.resetDefaultState(), E = -1, T = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === mt.enabled && !0 === mt.isPresenting && (e = mt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(v, t, e, n || w), g = ot.get(t, e), g.init(), j.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), H.setFromProjectionMatrix(j), G = this.localClippingEnabled, U = F.init(this.clippingPlanes, G, e), f = rt.get(t, e), f.init(), Mt(t, e, 0, v.sortObjects), f.finish(), !0 === v.sortObjects && f.sort(D, I), !0 === U && F.beginShadows();
    const r = g.state.shadowsArray;
    gt.render(r, t, e), g.setupLights(e), !0 === U && F.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), st.render(f, t, e, i);
    const o = f.opaque,
          s = f.transparent;
    o.length > 0 && St(o, t, e), s.length > 0 && St(s, t, e), !0 === t.isScene && t.onAfterRender(v, t, e), null !== w && (K.updateRenderTargetMipmap(w), K.updateMultisampleRenderTarget(w)), Z.buffers.depth.setTest(!0), Z.buffers.depth.setMask(!0), Z.buffers.color.setMask(!0), Z.setPolygonOffset(!1), f = null, g = null;
  }, this.setFramebuffer = function (t) {
    x !== t && null === w && dt.bindFramebuffer(36160, t), x = t;
  }, this.getActiveCubeFace = function () {
    return _;
  }, this.getActiveMipmapLevel = function () {
    return b;
  }, this.getRenderTarget = function () {
    return w;
  }, this.setRenderTarget = function (t, e, n) {
    w = t, _ = e, b = n, t && void 0 === Q.get(t).__webglFramebuffer && K.setupRenderTarget(t);
    let i = x,
        r = !1;

    if (t) {
      const n = Q.get(t).__webglFramebuffer;

      t.isWebGLCubeRenderTarget ? (i = n[e || 0], r = !0) : i = t.isWebGLMultisampleRenderTarget ? Q.get(t).__webglMultisampledFramebuffer : n, L.copy(t.viewport), C.copy(t.scissor), R = t.scissorTest;
    } else L.copy(z).multiplyScalar(N).floor(), C.copy(B).multiplyScalar(N).floor(), R = k;

    if (S !== i && (dt.bindFramebuffer(36160, i), S = i), Z.viewport(L), Z.scissor(C), Z.setScissorTest(R), r) {
      const i = Q.get(t.texture);
      dt.framebufferTexture2D(36160, 36064, 34069 + (e || 0), i.__webglTexture, n || 0);
    }
  }, this.readRenderTargetPixels = function (t, e, n, i, r, o, s) {
    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");

    let a = Q.get(t).__webglFramebuffer;

    if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
      let s = !1;
      a !== S && (dt.bindFramebuffer(36160, a), s = !0);

      try {
        const a = t.texture,
              c = a.format,
              l = a.type;
        if (1023 !== c && ut.convert(c) !== dt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
        if (!(1009 === l || ut.convert(l) === dt.getParameter(35738) || 1015 === l && (Y.isWebGL2 || X.get("OES_texture_float") || X.get("WEBGL_color_buffer_float")) || 1016 === l && (Y.isWebGL2 ? X.get("EXT_color_buffer_float") : X.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
        36053 === dt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && dt.readPixels(e, n, i, r, ut.convert(c), ut.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        s && dt.bindFramebuffer(36160, S);
      }
    }
  }, this.copyFramebufferToTexture = function (t, e, n) {
    void 0 === n && (n = 0);
    const i = Math.pow(2, -n),
          r = Math.floor(e.image.width * i),
          o = Math.floor(e.image.height * i),
          s = ut.convert(e.format);
    K.setTexture2D(e, 0), dt.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0), Z.unbindTexture();
  }, this.copyTextureToTexture = function (t, e, n, i) {
    void 0 === i && (i = 0);
    const r = e.image.width,
          o = e.image.height,
          s = ut.convert(n.format),
          a = ut.convert(n.type);
    K.setTexture2D(n, 0), dt.pixelStorei(37440, n.flipY), dt.pixelStorei(37441, n.premultiplyAlpha), dt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? dt.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? dt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : dt.texSubImage2D(3553, i, t.x, t.y, s, a, e.image), 0 === i && n.generateMipmaps && dt.generateMipmap(3553), Z.unbindTexture();
  }, this.initTexture = function (t) {
    K.setTexture2D(t, 0), Z.unbindTexture();
  }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
    detail: this
  }));
}

function er(t) {
  tr.call(this, t);
}

function nr(t, e) {
  this.name = "", this.color = new Ot(t), this.density = void 0 !== e ? e : 25e-5;
}

function ir(t, e, n) {
  this.name = "", this.color = new Ot(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3;
}

function rr(t, e) {
  this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = {
    offset: 0,
    count: -1
  }, this.version = 0, this.uuid = n.generateUUID();
}

ji.prototype = Object.create(kt.prototype), ji.prototype.constructor = ji, ji.prototype.isMeshDepthMaterial = !0, ji.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
}, Vi.prototype = Object.create(kt.prototype), Vi.prototype.constructor = Vi, Vi.prototype.isMeshDistanceMaterial = !0, Vi.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
}, Zi.prototype = Object.assign(Object.create(He.prototype), {
  constructor: Zi,
  isArrayCamera: !0
}), Ji.prototype = Object.assign(Object.create(U.prototype), {
  constructor: Ji,
  isGroup: !0
}), Object.assign(Qi.prototype, {
  constructor: Qi,
  getTargetRaySpace: function () {
    return null === this._targetRay && (this._targetRay = new Ji(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay;
  },
  getGripSpace: function () {
    return null === this._grip && (this._grip = new Ji(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip;
  },
  dispatchEvent: function (t) {
    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), this;
  },
  disconnect: function (t) {
    return this.dispatchEvent({
      type: "disconnected",
      data: t
    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), this;
  },
  update: function (t, e, n) {
    let i = null,
        r = null;
    const o = this._targetRay,
          s = this._grip;
    return t && (null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), null !== s && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)))), null !== o && (o.visible = null !== i), null !== s && (s.visible = null !== r), this;
  }
}), Object.assign(Ki.prototype, t.prototype), er.prototype = Object.assign(Object.create(tr.prototype), {
  constructor: er,
  isWebGL1Renderer: !0
}), Object.assign(nr.prototype, {
  isFogExp2: !0,
  clone: function () {
    return new nr(this.color, this.density);
  },
  toJSON: function () {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}), Object.assign(ir.prototype, {
  isFog: !0,
  clone: function () {
    return new ir(this.color, this.near, this.far);
  },
  toJSON: function () {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}), Object.defineProperty(rr.prototype, "needsUpdate", {
  set: function (t) {
    !0 === t && this.version++;
  }
}), Object.assign(rr.prototype, {
  isInterleavedBuffer: !0,
  onUploadCallback: function () {},
  setUsage: function (t) {
    return this.usage = t, this;
  },
  copy: function (t) {
    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
  },
  copyAt: function (t, e, n) {
    t *= this.stride, n *= e.stride;

    for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];

    return this;
  },
  set: function (t, e) {
    return void 0 === e && (e = 0), this.array.set(t, e), this;
  },
  clone: function (t) {
    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = n.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new rr(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
    return e.setUsage(this.usage), e;
  },
  onUpload: function (t) {
    return this.onUploadCallback = t, this;
  },
  toJSON: function (t) {
    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = n.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
const or = new m();

function sr(t, e, n, i) {
  this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i;
}

function ar(t) {
  kt.call(this), this.type = "SpriteMaterial", this.color = new Ot(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t);
}

let cr;
Object.defineProperties(sr.prototype, {
  count: {
    get: function () {
      return this.data.count;
    }
  },
  array: {
    get: function () {
      return this.data.array;
    }
  }
}), Object.assign(sr.prototype, {
  isInterleavedBufferAttribute: !0,
  applyMatrix4: function (t) {
    for (let e = 0, n = this.data.count; e < n; e++) or.x = this.getX(e), or.y = this.getY(e), or.z = this.getZ(e), or.applyMatrix4(t), this.setXYZ(e, or.x, or.y, or.z);

    return this;
  },
  setX: function (t, e) {
    return this.data.array[t * this.data.stride + this.offset] = e, this;
  },
  setY: function (t, e) {
    return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
  },
  setZ: function (t, e) {
    return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
  },
  setW: function (t, e) {
    return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
  },
  getX: function (t) {
    return this.data.array[t * this.data.stride + this.offset];
  },
  getY: function (t) {
    return this.data.array[t * this.data.stride + this.offset + 1];
  },
  getZ: function (t) {
    return this.data.array[t * this.data.stride + this.offset + 2];
  },
  getW: function (t) {
    return this.data.array[t * this.data.stride + this.offset + 3];
  },
  setXY: function (t, e, n) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
  },
  setXYZ: function (t, e, n, i) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this;
  },
  setXYZW: function (t, e, n, i, r) {
    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this;
  },
  clone: function (t) {
    if (void 0 === t) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const t = [];

      for (let e = 0; e < this.count; e++) {
        const n = e * this.data.stride + this.offset;

        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
      }

      return new Gt(new this.array.constructor(t), this.itemSize, this.normalized);
    }

    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new sr(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  },
  toJSON: function (t) {
    if (void 0 === t) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const t = [];

      for (let e = 0; e < this.count; e++) {
        const n = e * this.data.stride + this.offset;

        for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e]);
      }

      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    }

    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
      isInterleavedBufferAttribute: !0,
      itemSize: this.itemSize,
      data: this.data.uuid,
      offset: this.offset,
      normalized: this.normalized
    };
  }
}), ar.prototype = Object.create(kt.prototype), ar.prototype.constructor = ar, ar.prototype.isSpriteMaterial = !0, ar.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
};

const lr = new m(),
      ur = new m(),
      hr = new m(),
      dr = new i(),
      pr = new i(),
      fr = new M(),
      mr = new m(),
      gr = new m(),
      vr = new m(),
      yr = new i(),
      xr = new i(),
      _r = new i();

function br(t) {
  if (U.call(this), this.type = "Sprite", void 0 === cr) {
    cr = new ae();
    const t = new rr(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
    cr.setIndex([0, 1, 2, 0, 2, 3]), cr.setAttribute("position", new sr(t, 3, 0, !1)), cr.setAttribute("uv", new sr(t, 2, 3, !1));
  }

  this.geometry = cr, this.material = void 0 !== t ? t : new ar(), this.center = new i(.5, .5);
}

function wr(t, e, n, i, r, o) {
  dr.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (pr.x = o * dr.x - r * dr.y, pr.y = r * dr.x + o * dr.y) : pr.copy(dr), t.copy(e), t.x += pr.x, t.y += pr.y, t.applyMatrix4(fr);
}

br.prototype = Object.assign(Object.create(U.prototype), {
  constructor: br,
  isSprite: !0,
  raycast: function (t, e) {
    null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ur.setFromMatrixScale(this.matrixWorld), fr.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), hr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ur.multiplyScalar(-hr.z);
    const n = this.material.rotation;
    let r, o;
    0 !== n && (o = Math.cos(n), r = Math.sin(n));
    const s = this.center;
    wr(mr.set(-.5, -.5, 0), hr, s, ur, r, o), wr(gr.set(.5, -.5, 0), hr, s, ur, r, o), wr(vr.set(.5, .5, 0), hr, s, ur, r, o), yr.set(0, 0), xr.set(1, 0), _r.set(1, 1);
    let a = t.ray.intersectTriangle(mr, gr, vr, !1, lr);
    if (null === a && (wr(gr.set(-.5, .5, 0), hr, s, ur, r, o), xr.set(0, 1), a = t.ray.intersectTriangle(mr, vr, gr, !1, lr), null === a)) return;
    const c = t.ray.origin.distanceTo(lr);
    c < t.near || c > t.far || e.push({
      distance: c,
      point: lr.clone(),
      uv: Lt.getUV(lr, mr, gr, vr, yr, xr, _r, new i()),
      face: null,
      object: this
    });
  },
  copy: function (t) {
    return U.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this;
  }
});
const Mr = new m(),
      Sr = new m();

function Er() {
  U.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
    levels: {
      enumerable: !0,
      value: []
    }
  }), this.autoUpdate = !0;
}

function Tr(t, e) {
  t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Ee.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new M(), this.bindMatrixInverse = new M();
}

Er.prototype = Object.assign(Object.create(U.prototype), {
  constructor: Er,
  isLOD: !0,
  copy: function (t) {
    U.prototype.copy.call(this, t, !1);
    const e = t.levels;

    for (let t = 0, n = e.length; t < n; t++) {
      const n = e[t];
      this.addLevel(n.object.clone(), n.distance);
    }

    return this.autoUpdate = t.autoUpdate, this;
  },
  addLevel: function (t, e) {
    void 0 === e && (e = 0), e = Math.abs(e);
    const n = this.levels;
    let i;

    for (i = 0; i < n.length && !(e < n[i].distance); i++);

    return n.splice(i, 0, {
      distance: e,
      object: t
    }), this.add(t), this;
  },
  getCurrentLevel: function () {
    return this._currentLevel;
  },
  getObjectForDistance: function (t) {
    const e = this.levels;

    if (e.length > 0) {
      let n, i;

      for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);

      return e[n - 1].object;
    }

    return null;
  },
  raycast: function (t, e) {
    if (this.levels.length > 0) {
      Mr.setFromMatrixPosition(this.matrixWorld);
      const n = t.ray.origin.distanceTo(Mr);
      this.getObjectForDistance(n).raycast(t, e);
    }
  },
  update: function (t) {
    const e = this.levels;

    if (e.length > 1) {
      Mr.setFromMatrixPosition(t.matrixWorld), Sr.setFromMatrixPosition(this.matrixWorld);
      const n = Mr.distanceTo(Sr) / t.zoom;
      let i, r;

      for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;

      for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
    }
  },
  toJSON: function (t) {
    const e = U.prototype.toJSON.call(this, t);
    !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
    const n = this.levels;

    for (let t = 0, i = n.length; t < i; t++) {
      const i = n[t];
      e.object.levels.push({
        object: i.object.uuid,
        distance: i.distance
      });
    }

    return e;
  }
}), Tr.prototype = Object.assign(Object.create(Ee.prototype), {
  constructor: Tr,
  isSkinnedMesh: !0,
  copy: function (t) {
    return Ee.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
  },
  bind: function (t, e) {
    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e);
  },
  pose: function () {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function () {
    const t = new l(),
          e = this.geometry.attributes.skinWeight;

    for (let n = 0, i = e.count; n < i; n++) {
      t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
      const i = 1 / t.manhattanLength();
      i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  },
  updateMatrixWorld: function (t) {
    Ee.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  },
  boneTransform: function () {
    const t = new m(),
          e = new l(),
          n = new l(),
          i = new m(),
          r = new M();
    return function (o, s) {
      const a = this.skeleton,
            c = this.geometry;
      e.fromBufferAttribute(c.attributes.skinIndex, o), n.fromBufferAttribute(c.attributes.skinWeight, o), t.fromBufferAttribute(c.attributes.position, o).applyMatrix4(this.bindMatrix), s.set(0, 0, 0);

      for (let o = 0; o < 4; o++) {
        const c = n.getComponent(o);

        if (0 !== c) {
          const n = e.getComponent(o);
          r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]), s.addScaledVector(i.copy(t).applyMatrix4(r), c);
        }
      }

      return s.applyMatrix4(this.bindMatrixInverse);
    };
  }()
});
const Ar = new M(),
      Lr = new M();

function Cr(t, e) {
  if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();else if (this.bones.length === e.length) this.boneInverses = e.slice(0);else {
    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];

    for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new M());
  }
}

function Rr() {
  U.call(this), this.type = "Bone";
}

Object.assign(Cr.prototype, {
  calculateInverses: function () {
    this.boneInverses = [];

    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = new M();
      this.bones[t] && e.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(e);
    }
  },
  pose: function () {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t];
      e && e.matrixWorld.getInverse(this.boneInverses[t]);
    }

    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t];
      e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale));
    }
  },
  update: function () {
    const t = this.bones,
          e = this.boneInverses,
          n = this.boneMatrices,
          i = this.boneTexture;

    for (let i = 0, r = t.length; i < r; i++) {
      const r = t[i] ? t[i].matrixWorld : Lr;
      Ar.multiplyMatrices(r, e[i]), Ar.toArray(n, 16 * i);
    }

    void 0 !== i && (i.needsUpdate = !0);
  },
  clone: function () {
    return new Cr(this.bones, this.boneInverses);
  },
  getBoneByName: function (t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const n = this.bones[e];
      if (n.name === t) return n;
    }
  },
  dispose: function () {
    this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0);
  }
}), Rr.prototype = Object.assign(Object.create(U.prototype), {
  constructor: Rr,
  isBone: !0
});
const Pr = new M(),
      Or = new M(),
      Nr = [],
      Dr = new Ee();

function Ir(t, e, n) {
  Ee.call(this, t, e), this.instanceMatrix = new Gt(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1;
}

function zr(t) {
  kt.call(this), this.type = "LineBasicMaterial", this.color = new Ot(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t);
}

Ir.prototype = Object.assign(Object.create(Ee.prototype), {
  constructor: Ir,
  isInstancedMesh: !0,
  copy: function (t) {
    return Ee.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this;
  },
  getMatrixAt: function (t, e) {
    e.fromArray(this.instanceMatrix.array, 16 * t);
  },
  raycast: function (t, e) {
    const n = this.matrixWorld,
          i = this.count;
    if (Dr.geometry = this.geometry, Dr.material = this.material, void 0 !== Dr.material) for (let r = 0; r < i; r++) {
      this.getMatrixAt(r, Pr), Or.multiplyMatrices(n, Pr), Dr.matrixWorld = Or, Dr.raycast(t, Nr);

      for (let t = 0, n = Nr.length; t < n; t++) {
        const n = Nr[t];
        n.instanceId = r, n.object = this, e.push(n);
      }

      Nr.length = 0;
    }
  },
  setMatrixAt: function (t, e) {
    e.toArray(this.instanceMatrix.array, 16 * t);
  },
  updateMorphTargets: function () {}
}), zr.prototype = Object.create(kt.prototype), zr.prototype.constructor = zr, zr.prototype.isLineBasicMaterial = !0, zr.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this;
};
const Br = new m(),
      kr = new m(),
      Hr = new M(),
      Fr = new pt(),
      Ur = new ot();

function Gr(t, e, n) {
  1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), U.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new ae(), this.material = void 0 !== e ? e : new zr(), this.updateMorphTargets();
}

Gr.prototype = Object.assign(Object.create(U.prototype), {
  constructor: Gr,
  isLine: !0,
  copy: function (t) {
    return U.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  computeLineDistances: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      if (null === t.index) {
        const e = t.attributes.position,
              n = [0];

        for (let t = 1, i = e.count; t < i; t++) Br.fromBufferAttribute(e, t - 1), kr.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Br.distanceTo(kr);

        t.setAttribute("lineDistance", new Jt(n, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    } else if (t.isGeometry) {
      const e = t.vertices,
            n = t.lineDistances;
      n[0] = 0;

      for (let t = 1, i = e.length; t < i; t++) n[t] = n[t - 1], n[t] += e[t - 1].distanceTo(e[t]);
    }
    return this;
  },
  raycast: function (t, e) {
    const n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Line.threshold;
    if (null === n.boundingSphere && n.computeBoundingSphere(), Ur.copy(n.boundingSphere), Ur.applyMatrix4(i), Ur.radius += r, !1 === t.ray.intersectsSphere(Ur)) return;
    Hr.getInverse(i), Fr.copy(t.ray).applyMatrix4(Hr);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = o * o,
          a = new m(),
          c = new m(),
          l = new m(),
          u = new m(),
          h = this && this.isLineSegments ? 2 : 1;

    if (n.isBufferGeometry) {
      const i = n.index,
            r = n.attributes.position.array;

      if (null !== i) {
        const n = i.array;

        for (let i = 0, o = n.length - 1; i < o; i += h) {
          const o = n[i],
                h = n[i + 1];
          if (a.fromArray(r, 3 * o), c.fromArray(r, 3 * h), Fr.distanceSqToSegment(a, c, u, l) > s) continue;
          u.applyMatrix4(this.matrixWorld);
          const d = t.ray.origin.distanceTo(u);
          d < t.near || d > t.far || e.push({
            distance: d,
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else for (let n = 0, i = r.length / 3 - 1; n < i; n += h) {
        if (a.fromArray(r, 3 * n), c.fromArray(r, 3 * n + 3), Fr.distanceSqToSegment(a, c, u, l) > s) continue;
        u.applyMatrix4(this.matrixWorld);
        const i = t.ray.origin.distanceTo(u);
        i < t.near || i > t.far || e.push({
          distance: i,
          point: l.clone().applyMatrix4(this.matrixWorld),
          index: n,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else if (n.isGeometry) {
      const i = n.vertices,
            r = i.length;

      for (let n = 0; n < r - 1; n += h) {
        if (Fr.distanceSqToSegment(i[n], i[n + 1], u, l) > s) continue;
        u.applyMatrix4(this.matrixWorld);
        const r = t.ray.origin.distanceTo(u);
        r < t.near || r > t.far || e.push({
          distance: r,
          point: l.clone().applyMatrix4(this.matrixWorld),
          index: n,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  },
  updateMorphTargets: function () {
    const t = this.geometry;

    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
            n = Object.keys(e);

      if (n.length > 0) {
        const t = e[n[0]];

        if (void 0 !== t) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};

          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
const jr = new m(),
      Vr = new m();

function Wr(t, e) {
  Gr.call(this, t, e), this.type = "LineSegments";
}

function qr(t, e) {
  Gr.call(this, t, e), this.type = "LineLoop";
}

function Xr(t) {
  kt.call(this), this.type = "PointsMaterial", this.color = new Ot(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t);
}

Wr.prototype = Object.assign(Object.create(Gr.prototype), {
  constructor: Wr,
  isLineSegments: !0,
  computeLineDistances: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      if (null === t.index) {
        const e = t.attributes.position,
              n = [];

        for (let t = 0, i = e.count; t < i; t += 2) jr.fromBufferAttribute(e, t), Vr.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + jr.distanceTo(Vr);

        t.setAttribute("lineDistance", new Jt(n, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    } else if (t.isGeometry) {
      const e = t.vertices,
            n = t.lineDistances;

      for (let t = 0, i = e.length; t < i; t += 2) jr.copy(e[t]), Vr.copy(e[t + 1]), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + jr.distanceTo(Vr);
    }
    return this;
  }
}), qr.prototype = Object.assign(Object.create(Gr.prototype), {
  constructor: qr,
  isLineLoop: !0
}), Xr.prototype = Object.create(kt.prototype), Xr.prototype.constructor = Xr, Xr.prototype.isPointsMaterial = !0, Xr.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this;
};
const Yr = new M(),
      Zr = new pt(),
      Jr = new ot(),
      Qr = new m();

function Kr(t, e) {
  U.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new ae(), this.material = void 0 !== e ? e : new Xr(), this.updateMorphTargets();
}

function $r(t, e, n, i, r, o, s) {
  const a = Zr.distanceSqToPoint(t);

  if (a < n) {
    const n = new m();
    Zr.closestPointToPoint(t, n), n.applyMatrix4(i);
    const c = r.ray.origin.distanceTo(n);
    if (c < r.near || c > r.far) return;
    o.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: n,
      index: e,
      face: null,
      object: s
    });
  }
}

function to(t, e, n, i, r, o, s, a, l) {
  c.call(this, t, e, n, i, r, o, s, a, l), this.format = void 0 !== s ? s : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1;
}

function eo(t, e, n, i, r, o, s, a, l, u, h, d) {
  c.call(this, null, o, s, a, l, u, i, r, h, d), this.image = {
    width: e,
    height: n
  }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
}

function no(t, e, n, i, r, o, s, a, l) {
  c.call(this, t, e, n, i, r, o, s, a, l), this.needsUpdate = !0;
}

function io(t, e, n, i, r, o, s, a, l, u) {
  if (1026 !== (u = void 0 !== u ? u : 1026) && 1027 !== u) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  void 0 === n && 1026 === u && (n = 1012), void 0 === n && 1027 === u && (n = 1020), c.call(this, null, i, r, o, s, a, u, n, l), this.image = {
    width: t,
    height: e
  }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== a ? a : 1003, this.flipY = !1, this.generateMipmaps = !1;
}

function ro(t) {
  ae.call(this), this.type = "WireframeGeometry";
  const e = [],
        n = [0, 0],
        i = {},
        r = ["a", "b", "c"];

  if (t && t.isGeometry) {
    const o = t.faces;

    for (let t = 0, e = o.length; t < e; t++) {
      const e = o[t];

      for (let t = 0; t < 3; t++) {
        const o = e[r[t]],
              s = e[r[(t + 1) % 3]];
        n[0] = Math.min(o, s), n[1] = Math.max(o, s);
        const a = n[0] + "," + n[1];
        void 0 === i[a] && (i[a] = {
          index1: n[0],
          index2: n[1]
        });
      }
    }

    for (const n in i) {
      const r = i[n];
      let o = t.vertices[r.index1];
      e.push(o.x, o.y, o.z), o = t.vertices[r.index2], e.push(o.x, o.y, o.z);
    }
  } else if (t && t.isBufferGeometry) {
    let r = new m();

    if (null !== t.index) {
      const o = t.attributes.position,
            s = t.index;
      let a = t.groups;
      0 === a.length && (a = [{
        start: 0,
        count: s.count,
        materialIndex: 0
      }]);

      for (let t = 0, e = a.length; t < e; ++t) {
        const e = a[t],
              r = e.start;

        for (let t = r, o = r + e.count; t < o; t += 3) for (let e = 0; e < 3; e++) {
          const r = s.getX(t + e),
                o = s.getX(t + (e + 1) % 3);
          n[0] = Math.min(r, o), n[1] = Math.max(r, o);
          const a = n[0] + "," + n[1];
          void 0 === i[a] && (i[a] = {
            index1: n[0],
            index2: n[1]
          });
        }
      }

      for (const t in i) {
        const n = i[t];
        r.fromBufferAttribute(o, n.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(o, n.index2), e.push(r.x, r.y, r.z);
      }
    } else {
      const n = t.attributes.position;

      for (let t = 0, i = n.count / 3; t < i; t++) for (let i = 0; i < 3; i++) {
        const o = 3 * t + i;
        r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z);
        const s = 3 * t + (i + 1) % 3;
        r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z);
      }
    }
  }

  this.setAttribute("position", new Jt(e, 3));
}

function oo(t, e, n) {
  Oe.call(this), this.type = "ParametricGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  }, this.fromBufferGeometry(new so(t, e, n)), this.mergeVertices();
}

function so(t, e, n) {
  ae.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
    func: t,
    slices: e,
    stacks: n
  };
  const i = [],
        r = [],
        o = [],
        s = [],
        a = 1e-5,
        c = new m(),
        l = new m(),
        u = new m(),
        h = new m(),
        d = new m();
  t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  const p = e + 1;

  for (let i = 0; i <= n; i++) {
    const p = i / n;

    for (let n = 0; n <= e; n++) {
      const i = n / e;
      t(i, p, l), r.push(l.x, l.y, l.z), i - a >= 0 ? (t(i - a, p, u), h.subVectors(l, u)) : (t(i + a, p, u), h.subVectors(u, l)), p - a >= 0 ? (t(i, p - a, u), d.subVectors(l, u)) : (t(i, p + a, u), d.subVectors(u, l)), c.crossVectors(h, d).normalize(), o.push(c.x, c.y, c.z), s.push(i, p);
    }
  }

  for (let t = 0; t < n; t++) for (let n = 0; n < e; n++) {
    const e = t * p + n,
          r = t * p + n + 1,
          o = (t + 1) * p + n + 1,
          s = (t + 1) * p + n;
    i.push(e, r, s), i.push(r, o, s);
  }

  this.setIndex(i), this.setAttribute("position", new Jt(r, 3)), this.setAttribute("normal", new Jt(o, 3)), this.setAttribute("uv", new Jt(s, 2));
}

function ao(t, e, n, i) {
  Oe.call(this), this.type = "PolyhedronGeometry", this.parameters = {
    vertices: t,
    indices: e,
    radius: n,
    detail: i
  }, this.fromBufferGeometry(new co(t, e, n, i)), this.mergeVertices();
}

function co(t, e, n, r) {
  ae.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
    vertices: t,
    indices: e,
    radius: n,
    detail: r
  }, n = n || 1;
  const o = [],
        s = [];

  function a(t, e, n, i) {
    const r = Math.pow(2, i),
          o = [];

    for (let i = 0; i <= r; i++) {
      o[i] = [];
      const s = t.clone().lerp(n, i / r),
            a = e.clone().lerp(n, i / r),
            c = r - i;

      for (let t = 0; t <= c; t++) o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / c);
    }

    for (let t = 0; t < r; t++) for (let e = 0; e < 2 * (r - t) - 1; e++) {
      const n = Math.floor(e / 2);
      e % 2 == 0 ? (c(o[t][n + 1]), c(o[t + 1][n]), c(o[t][n])) : (c(o[t][n + 1]), c(o[t + 1][n + 1]), c(o[t + 1][n]));
    }
  }

  function c(t) {
    o.push(t.x, t.y, t.z);
  }

  function l(e, n) {
    const i = 3 * e;
    n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2];
  }

  function u(t, e, n, i) {
    i < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + .5);
  }

  function h(t) {
    return Math.atan2(t.z, -t.x);
  }

  !function (t) {
    const n = new m(),
          i = new m(),
          r = new m();

    for (let o = 0; o < e.length; o += 3) l(e[o + 0], n), l(e[o + 1], i), l(e[o + 2], r), a(n, i, r, t);
  }(r = r || 0), function (t) {
    const e = new m();

    for (let n = 0; n < o.length; n += 3) e.x = o[n + 0], e.y = o[n + 1], e.z = o[n + 2], e.normalize().multiplyScalar(t), o[n + 0] = e.x, o[n + 1] = e.y, o[n + 2] = e.z;
  }(n), function () {
    const t = new m();

    for (let n = 0; n < o.length; n += 3) {
      t.x = o[n + 0], t.y = o[n + 1], t.z = o[n + 2];
      const i = h(t) / 2 / Math.PI + .5,
            r = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
      s.push(i, 1 - r);
    }

    var e;
    (function () {
      const t = new m(),
            e = new m(),
            n = new m(),
            r = new m(),
            a = new i(),
            c = new i(),
            l = new i();

      for (let i = 0, d = 0; i < o.length; i += 9, d += 6) {
        t.set(o[i + 0], o[i + 1], o[i + 2]), e.set(o[i + 3], o[i + 4], o[i + 5]), n.set(o[i + 6], o[i + 7], o[i + 8]), a.set(s[d + 0], s[d + 1]), c.set(s[d + 2], s[d + 3]), l.set(s[d + 4], s[d + 5]), r.copy(t).add(e).add(n).divideScalar(3);
        const p = h(r);
        u(a, d + 0, t, p), u(c, d + 2, e, p), u(l, d + 4, n, p);
      }
    })(), function () {
      for (let t = 0; t < s.length; t += 6) {
        const e = s[t + 0],
              n = s[t + 2],
              i = s[t + 4],
              r = Math.max(e, n, i),
              o = Math.min(e, n, i);
        r > .9 && o < .1 && (e < .2 && (s[t + 0] += 1), n < .2 && (s[t + 2] += 1), i < .2 && (s[t + 4] += 1));
      }
    }();
  }(), this.setAttribute("position", new Jt(o, 3)), this.setAttribute("normal", new Jt(o.slice(), 3)), this.setAttribute("uv", new Jt(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals();
}

function lo(t, e) {
  Oe.call(this), this.type = "TetrahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new uo(t, e)), this.mergeVertices();
}

function uo(t, e) {
  co.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}

function ho(t, e) {
  Oe.call(this), this.type = "OctahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new po(t, e)), this.mergeVertices();
}

function po(t, e) {
  co.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}

function fo(t, e) {
  Oe.call(this), this.type = "IcosahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new mo(t, e)), this.mergeVertices();
}

function mo(t, e) {
  const n = (1 + Math.sqrt(5)) / 2,
        i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
  co.call(this, i, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}

function go(t, e) {
  Oe.call(this), this.type = "DodecahedronGeometry", this.parameters = {
    radius: t,
    detail: e
  }, this.fromBufferGeometry(new vo(t, e)), this.mergeVertices();
}

function vo(t, e) {
  const n = (1 + Math.sqrt(5)) / 2,
        i = 1 / n,
        r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i];
  co.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
    radius: t,
    detail: e
  };
}

function yo(t, e, n, i, r, o) {
  Oe.call(this), this.type = "TubeGeometry", this.parameters = {
    path: t,
    tubularSegments: e,
    radius: n,
    radialSegments: i,
    closed: r
  }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
  const s = new xo(t, e, n, i, r);
  this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices();
}

function xo(t, e, n, r, o) {
  ae.call(this), this.type = "TubeBufferGeometry", this.parameters = {
    path: t,
    tubularSegments: e,
    radius: n,
    radialSegments: r,
    closed: o
  }, e = e || 64, n = n || 1, r = r || 8, o = o || !1;
  const s = t.computeFrenetFrames(e, o);
  this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
  const a = new m(),
        c = new m(),
        l = new i();
  let u = new m();
  const h = [],
        d = [],
        p = [],
        f = [];

  function g(i) {
    u = t.getPointAt(i / e, u);
    const o = s.normals[i],
          l = s.binormals[i];

    for (let t = 0; t <= r; t++) {
      const e = t / r * Math.PI * 2,
            i = Math.sin(e),
            s = -Math.cos(e);
      c.x = s * o.x + i * l.x, c.y = s * o.y + i * l.y, c.z = s * o.z + i * l.z, c.normalize(), d.push(c.x, c.y, c.z), a.x = u.x + n * c.x, a.y = u.y + n * c.y, a.z = u.z + n * c.z, h.push(a.x, a.y, a.z);
    }
  }

  !function () {
    for (let t = 0; t < e; t++) g(t);

    g(!1 === o ? e : 0), function () {
      for (let t = 0; t <= e; t++) for (let n = 0; n <= r; n++) l.x = t / e, l.y = n / r, p.push(l.x, l.y);
    }(), function () {
      for (let t = 1; t <= e; t++) for (let e = 1; e <= r; e++) {
        const n = (r + 1) * (t - 1) + (e - 1),
              i = (r + 1) * t + (e - 1),
              o = (r + 1) * t + e,
              s = (r + 1) * (t - 1) + e;
        f.push(n, i, s), f.push(i, o, s);
      }
    }();
  }(), this.setIndex(f), this.setAttribute("position", new Jt(h, 3)), this.setAttribute("normal", new Jt(d, 3)), this.setAttribute("uv", new Jt(p, 2));
}

function _o(t, e, n, i, r, o, s) {
  Oe.call(this), this.type = "TorusKnotGeometry", this.parameters = {
    radius: t,
    tube: e,
    tubularSegments: n,
    radialSegments: i,
    p: r,
    q: o
  }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new bo(t, e, n, i, r, o)), this.mergeVertices();
}

function bo(t, e, n, i, r, o) {
  ae.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
    radius: t,
    tube: e,
    tubularSegments: n,
    radialSegments: i,
    p: r,
    q: o
  }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
  const s = [],
        a = [],
        c = [],
        l = [],
        u = new m(),
        h = new m(),
        d = new m(),
        p = new m(),
        f = new m(),
        g = new m(),
        v = new m();

  for (let s = 0; s <= n; ++s) {
    const m = s / n * r * Math.PI * 2;
    y(m, r, o, t, d), y(m + .01, r, o, t, p), g.subVectors(p, d), v.addVectors(p, d), f.crossVectors(g, v), v.crossVectors(f, g), f.normalize(), v.normalize();

    for (let t = 0; t <= i; ++t) {
      const r = t / i * Math.PI * 2,
            o = -e * Math.cos(r),
            p = e * Math.sin(r);
      u.x = d.x + (o * v.x + p * f.x), u.y = d.y + (o * v.y + p * f.y), u.z = d.z + (o * v.z + p * f.z), a.push(u.x, u.y, u.z), h.subVectors(u, d).normalize(), c.push(h.x, h.y, h.z), l.push(s / n), l.push(t / i);
    }
  }

  for (let t = 1; t <= n; t++) for (let e = 1; e <= i; e++) {
    const n = (i + 1) * (t - 1) + (e - 1),
          r = (i + 1) * t + (e - 1),
          o = (i + 1) * t + e,
          a = (i + 1) * (t - 1) + e;
    s.push(n, r, a), s.push(r, o, a);
  }

  function y(t, e, n, i, r) {
    const o = Math.cos(t),
          s = Math.sin(t),
          a = n / e * t,
          c = Math.cos(a);
    r.x = i * (2 + c) * .5 * o, r.y = i * (2 + c) * s * .5, r.z = i * Math.sin(a) * .5;
  }

  this.setIndex(s), this.setAttribute("position", new Jt(a, 3)), this.setAttribute("normal", new Jt(c, 3)), this.setAttribute("uv", new Jt(l, 2));
}

function wo(t, e, n, i, r) {
  Oe.call(this), this.type = "TorusGeometry", this.parameters = {
    radius: t,
    tube: e,
    radialSegments: n,
    tubularSegments: i,
    arc: r
  }, this.fromBufferGeometry(new Mo(t, e, n, i, r)), this.mergeVertices();
}

function Mo(t, e, n, i, r) {
  ae.call(this), this.type = "TorusBufferGeometry", this.parameters = {
    radius: t,
    tube: e,
    radialSegments: n,
    tubularSegments: i,
    arc: r
  }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
  const o = [],
        s = [],
        a = [],
        c = [],
        l = new m(),
        u = new m(),
        h = new m();

  for (let o = 0; o <= n; o++) for (let d = 0; d <= i; d++) {
    const p = d / i * r,
          f = o / n * Math.PI * 2;
    u.x = (t + e * Math.cos(f)) * Math.cos(p), u.y = (t + e * Math.cos(f)) * Math.sin(p), u.z = e * Math.sin(f), s.push(u.x, u.y, u.z), l.x = t * Math.cos(p), l.y = t * Math.sin(p), h.subVectors(u, l).normalize(), a.push(h.x, h.y, h.z), c.push(d / i), c.push(o / n);
  }

  for (let t = 1; t <= n; t++) for (let e = 1; e <= i; e++) {
    const n = (i + 1) * t + e - 1,
          r = (i + 1) * (t - 1) + e - 1,
          s = (i + 1) * (t - 1) + e,
          a = (i + 1) * t + e;
    o.push(n, r, a), o.push(r, s, a);
  }

  this.setIndex(o), this.setAttribute("position", new Jt(s, 3)), this.setAttribute("normal", new Jt(a, 3)), this.setAttribute("uv", new Jt(c, 2));
}

Kr.prototype = Object.assign(Object.create(U.prototype), {
  constructor: Kr,
  isPoints: !0,
  copy: function (t) {
    return U.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this;
  },
  raycast: function (t, e) {
    const n = this.geometry,
          i = this.matrixWorld,
          r = t.params.Points.threshold;
    if (null === n.boundingSphere && n.computeBoundingSphere(), Jr.copy(n.boundingSphere), Jr.applyMatrix4(i), Jr.radius += r, !1 === t.ray.intersectsSphere(Jr)) return;
    Yr.getInverse(i), Zr.copy(t.ray).applyMatrix4(Yr);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = o * o;

    if (n.isBufferGeometry) {
      const r = n.index,
            o = n.attributes.position.array;

      if (null !== r) {
        const n = r.array;

        for (let r = 0, a = n.length; r < a; r++) {
          const a = n[r];
          Qr.fromArray(o, 3 * a), $r(Qr, a, s, i, t, e, this);
        }
      } else for (let n = 0, r = o.length / 3; n < r; n++) Qr.fromArray(o, 3 * n), $r(Qr, n, s, i, t, e, this);
    } else {
      const r = n.vertices;

      for (let n = 0, o = r.length; n < o; n++) $r(r[n], n, s, i, t, e, this);
    }
  },
  updateMorphTargets: function () {
    const t = this.geometry;

    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
            n = Object.keys(e);

      if (n.length > 0) {
        const t = e[n[0]];

        if (void 0 !== t) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};

          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e;
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}), to.prototype = Object.assign(Object.create(c.prototype), {
  constructor: to,
  isVideoTexture: !0,
  update: function () {
    const t = this.image;
    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}), eo.prototype = Object.create(c.prototype), eo.prototype.constructor = eo, eo.prototype.isCompressedTexture = !0, no.prototype = Object.create(c.prototype), no.prototype.constructor = no, no.prototype.isCanvasTexture = !0, io.prototype = Object.create(c.prototype), io.prototype.constructor = io, io.prototype.isDepthTexture = !0, ro.prototype = Object.create(ae.prototype), ro.prototype.constructor = ro, oo.prototype = Object.create(Oe.prototype), oo.prototype.constructor = oo, so.prototype = Object.create(ae.prototype), so.prototype.constructor = so, ao.prototype = Object.create(Oe.prototype), ao.prototype.constructor = ao, co.prototype = Object.create(ae.prototype), co.prototype.constructor = co, lo.prototype = Object.create(Oe.prototype), lo.prototype.constructor = lo, uo.prototype = Object.create(co.prototype), uo.prototype.constructor = uo, ho.prototype = Object.create(Oe.prototype), ho.prototype.constructor = ho, po.prototype = Object.create(co.prototype), po.prototype.constructor = po, fo.prototype = Object.create(Oe.prototype), fo.prototype.constructor = fo, mo.prototype = Object.create(co.prototype), mo.prototype.constructor = mo, go.prototype = Object.create(Oe.prototype), go.prototype.constructor = go, vo.prototype = Object.create(co.prototype), vo.prototype.constructor = vo, yo.prototype = Object.create(Oe.prototype), yo.prototype.constructor = yo, xo.prototype = Object.create(ae.prototype), xo.prototype.constructor = xo, xo.prototype.toJSON = function () {
  const t = ae.prototype.toJSON.call(this);
  return t.path = this.parameters.path.toJSON(), t;
}, _o.prototype = Object.create(Oe.prototype), _o.prototype.constructor = _o, bo.prototype = Object.create(ae.prototype), bo.prototype.constructor = bo, wo.prototype = Object.create(Oe.prototype), wo.prototype.constructor = wo, Mo.prototype = Object.create(ae.prototype), Mo.prototype.constructor = Mo;

function So(t, e, n, i, r) {
  let o, s;
  if (r === function (t, e, n, i) {
    let r = 0;

    for (let o = e, s = n - i; o < n; o += i) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;

    return r;
  }(t, e, n, i) > 0) for (o = e; o < n; o += i) s = Wo(o, t[o], t[o + 1], s);else for (o = n - i; o >= e; o -= i) s = Wo(o, t[o], t[o + 1], s);
  return s && Ho(s, s.next) && (qo(s), s = s.next), s;
}

function Eo(t, e) {
  if (!t) return t;
  e || (e = t);
  let n,
      i = t;

  do {
    if (n = !1, i.steiner || !Ho(i, i.next) && 0 !== ko(i.prev, i, i.next)) i = i.next;else {
      if (qo(i), i = e = i.prev, i === i.next) break;
      n = !0;
    }
  } while (n || i !== e);

  return e;
}

function To(t, e, n, i, r, o, s) {
  if (!t) return;
  !s && o && function (t, e, n, i) {
    let r = t;

    do {
      null === r.z && (r.z = Do(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
    } while (r !== t);

    r.prevZ.nextZ = null, r.prevZ = null, function (t) {
      let e,
          n,
          i,
          r,
          o,
          s,
          a,
          c,
          l = 1;

      do {
        for (n = t, t = null, o = null, s = 0; n;) {
          for (s++, i = n, a = 0, e = 0; e < l && (a++, i = i.nextZ, i); e++);

          for (c = l; a > 0 || c > 0 && i;) 0 !== a && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;

          n = i;
        }

        o.nextZ = null, l *= 2;
      } while (s > 1);
    }(r);
  }(t, i, r, o);
  let a,
      c,
      l = t;

  for (; t.prev !== t.next;) if (a = t.prev, c = t.next, o ? Lo(t, i, r, o) : Ao(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), qo(t), t = c.next, l = c.next;else if ((t = c) === l) {
    s ? 1 === s ? To(t = Co(Eo(t), e, n), e, n, i, r, o, 2) : 2 === s && Ro(t, e, n, i, r, o) : To(Eo(t), e, n, i, r, o, 1);
    break;
  }
}

function Ao(t) {
  let e = t.prev,
      n = t,
      i = t.next;
  if (ko(e, n, i) >= 0) return !1;
  let r = t.next.next;

  for (; r !== t.prev;) {
    if (zo(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && ko(r.prev, r, r.next) >= 0) return !1;
    r = r.next;
  }

  return !0;
}

function Lo(t, e, n, i) {
  let r = t.prev,
      o = t,
      s = t.next;
  if (ko(r, o, s) >= 0) return !1;
  let a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x,
      c = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y,
      l = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x,
      u = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y,
      h = Do(a, c, e, n, i),
      d = Do(l, u, e, n, i),
      p = t.prevZ,
      f = t.nextZ;

  for (; p && p.z >= h && f && f.z <= d;) {
    if (p !== t.prev && p !== t.next && zo(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && ko(p.prev, p, p.next) >= 0) return !1;
    if (p = p.prevZ, f !== t.prev && f !== t.next && zo(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && ko(f.prev, f, f.next) >= 0) return !1;
    f = f.nextZ;
  }

  for (; p && p.z >= h;) {
    if (p !== t.prev && p !== t.next && zo(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && ko(p.prev, p, p.next) >= 0) return !1;
    p = p.prevZ;
  }

  for (; f && f.z <= d;) {
    if (f !== t.prev && f !== t.next && zo(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && ko(f.prev, f, f.next) >= 0) return !1;
    f = f.nextZ;
  }

  return !0;
}

function Co(t, e, n) {
  let i = t;

  do {
    let r = i.prev,
        o = i.next.next;
    !Ho(r, o) && Fo(r, i, i.next, o) && jo(r, o) && jo(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), qo(i), qo(i.next), i = t = o), i = i.next;
  } while (i !== t);

  return Eo(i);
}

function Ro(t, e, n, i, r, o) {
  let s = t;

  do {
    let t = s.next.next;

    for (; t !== s.prev;) {
      if (s.i !== t.i && Bo(s, t)) {
        let a = Vo(s, t);
        return s = Eo(s, s.next), a = Eo(a, a.next), To(s, e, n, i, r, o), void To(a, e, n, i, r, o);
      }

      t = t.next;
    }

    s = s.next;
  } while (s !== t);
}

function Po(t, e) {
  return t.x - e.x;
}

function Oo(t, e) {
  if (e = function (t, e) {
    let n,
        i = e,
        r = t.x,
        o = t.y,
        s = -1 / 0;

    do {
      if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
        let t = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);

        if (t <= r && t > s) {
          if (s = t, t === r) {
            if (o === i.y) return i;
            if (o === i.next.y) return i.next;
          }

          n = i.x < i.next.x ? i : i.next;
        }
      }

      i = i.next;
    } while (i !== e);

    if (!n) return null;
    if (r === s) return n;
    let a,
        c = n,
        l = n.x,
        u = n.y,
        h = 1 / 0;
    i = n;

    do {
      r >= i.x && i.x >= l && r !== i.x && zo(o < u ? r : s, o, l, u, o < u ? s : r, o, i.x, i.y) && (a = Math.abs(o - i.y) / (r - i.x), jo(i, t) && (a < h || a === h && (i.x > n.x || i.x === n.x && No(n, i))) && (n = i, h = a)), i = i.next;
    } while (i !== c);

    return n;
  }(t, e)) {
    const n = Vo(e, t);
    Eo(e, e.next), Eo(n, n.next);
  }
}

function No(t, e) {
  return ko(t.prev, t, e.prev) < 0 && ko(e.next, t, t.next) < 0;
}

function Do(t, e, n, i, r) {
  return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
}

function Io(t) {
  let e = t,
      n = t;

  do {
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  } while (e !== t);

  return n;
}

function zo(t, e, n, i, r, o, s, a) {
  return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0;
}

function Bo(t, e) {
  return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
    let n = t;

    do {
      if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Fo(n, n.next, t, e)) return !0;
      n = n.next;
    } while (n !== t);

    return !1;
  }(t, e) && (jo(t, e) && jo(e, t) && function (t, e) {
    let n = t,
        i = !1,
        r = (t.x + e.x) / 2,
        o = (t.y + e.y) / 2;

    do {
      n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
    } while (n !== t);

    return i;
  }(t, e) && (ko(t.prev, t, e.prev) || ko(t, e.prev, e)) || Ho(t, e) && ko(t.prev, t, t.next) > 0 && ko(e.prev, e, e.next) > 0);
}

function ko(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}

function Ho(t, e) {
  return t.x === e.x && t.y === e.y;
}

function Fo(t, e, n, i) {
  const r = Go(ko(t, e, n)),
        o = Go(ko(t, e, i)),
        s = Go(ko(n, i, t)),
        a = Go(ko(n, i, e));
  return r !== o && s !== a || !(0 !== r || !Uo(t, n, e)) || !(0 !== o || !Uo(t, i, e)) || !(0 !== s || !Uo(n, t, i)) || !(0 !== a || !Uo(n, e, i));
}

function Uo(t, e, n) {
  return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
}

function Go(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}

function jo(t, e) {
  return ko(t.prev, t, t.next) < 0 ? ko(t, e, t.next) >= 0 && ko(t, t.prev, e) >= 0 : ko(t, e, t.prev) < 0 || ko(t, t.next, e) < 0;
}

function Vo(t, e) {
  let n = new Xo(t.i, t.x, t.y),
      i = new Xo(e.i, e.x, e.y),
      r = t.next,
      o = e.prev;
  return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
}

function Wo(t, e, n, i) {
  const r = new Xo(t, e, n);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}

function qo(t) {
  t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}

function Xo(t, e, n) {
  this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}

const Yo = {
  area: function (t) {
    const e = t.length;
    let n = 0;

    for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;

    return .5 * n;
  },
  isClockWise: function (t) {
    return Yo.area(t) < 0;
  },
  triangulateShape: function (t, e) {
    const n = [],
          i = [],
          r = [];
    Zo(t), Jo(n, t);
    let o = t.length;
    e.forEach(Zo);

    for (let t = 0; t < e.length; t++) i.push(o), o += e[t].length, Jo(n, e[t]);

    const s = function (t, e, n) {
      n = n || 2;
      let i,
          r,
          o,
          s,
          a,
          c,
          l,
          u = e && e.length,
          h = u ? e[0] * n : t.length,
          d = So(t, 0, h, n, !0),
          p = [];
      if (!d || d.next === d.prev) return p;

      if (u && (d = function (t, e, n, i) {
        let r,
            o,
            s,
            a,
            c,
            l = [];

        for (r = 0, o = e.length; r < o; r++) s = e[r] * i, a = r < o - 1 ? e[r + 1] * i : t.length, c = So(t, s, a, i, !1), c === c.next && (c.steiner = !0), l.push(Io(c));

        for (l.sort(Po), r = 0; r < l.length; r++) Oo(l[r], n), n = Eo(n, n.next);

        return n;
      }(t, e, d, n)), t.length > 80 * n) {
        i = o = t[0], r = s = t[1];

        for (let e = n; e < h; e += n) a = t[e], c = t[e + 1], a < i && (i = a), c < r && (r = c), a > o && (o = a), c > s && (s = c);

        l = Math.max(o - i, s - r), l = 0 !== l ? 1 / l : 0;
      }

      return To(d, p, n, i, r, l), p;
    }(n, i);

    for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));

    return r;
  }
};

function Zo(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}

function Jo(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
}

function Qo(t, e) {
  Oe.call(this), this.type = "ExtrudeGeometry", this.parameters = {
    shapes: t,
    options: e
  }, this.fromBufferGeometry(new Ko(t, e)), this.mergeVertices();
}

function Ko(t, e) {
  ae.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
    shapes: t,
    options: e
  }, t = Array.isArray(t) ? t : [t];
  const n = this,
        r = [],
        o = [];

  for (let e = 0, n = t.length; e < n; e++) s(t[e]);

  function s(t) {
    const s = [],
          a = void 0 !== e.curveSegments ? e.curveSegments : 12,
          c = void 0 !== e.steps ? e.steps : 1;
    let l = void 0 !== e.depth ? e.depth : 100,
        u = void 0 === e.bevelEnabled || e.bevelEnabled,
        h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
        d = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
        p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
        f = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
    const g = e.extrudePath,
          v = void 0 !== e.UVGenerator ? e.UVGenerator : $o;
    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);

    let y,
        x,
        _,
        b,
        w,
        M = !1;

    g && (y = g.getSpacedPoints(c), M = !0, u = !1, x = g.computeFrenetFrames(c, !1), _ = new m(), b = new m(), w = new m()), u || (f = 0, h = 0, d = 0, p = 0);
    const S = t.extractPoints(a);
    let E = S.shape;
    const T = S.holes;

    if (!Yo.isClockWise(E)) {
      E = E.reverse();

      for (let t = 0, e = T.length; t < e; t++) {
        const e = T[t];
        Yo.isClockWise(e) && (T[t] = e.reverse());
      }
    }

    const A = Yo.triangulateShape(E, T),
          L = E;

    for (let t = 0, e = T.length; t < e; t++) {
      const e = T[t];
      E = E.concat(e);
    }

    function C(t, e, n) {
      return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t);
    }

    const R = E.length,
          P = A.length;

    function O(t, e, n) {
      let r, o, s;
      const a = t.x - e.x,
            c = t.y - e.y,
            l = n.x - t.x,
            u = n.y - t.y,
            h = a * a + c * c,
            d = a * u - c * l;

      if (Math.abs(d) > Number.EPSILON) {
        const d = Math.sqrt(h),
              p = Math.sqrt(l * l + u * u),
              f = e.x - c / d,
              m = e.y + a / d,
              g = ((n.x - u / p - f) * u - (n.y + l / p - m) * l) / (a * u - c * l);
        r = f + a * g - t.x, o = m + c * g - t.y;
        const v = r * r + o * o;
        if (v <= 2) return new i(r, o);
        s = Math.sqrt(v / 2);
      } else {
        let t = !1;
        a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(c) === Math.sign(u) && (t = !0), t ? (r = -c, o = a, s = Math.sqrt(h)) : (r = a, o = c, s = Math.sqrt(h / 2));
      }

      return new i(r / s, o / s);
    }

    const N = [];

    for (let t = 0, e = L.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), N[t] = O(L[t], L[n], L[i]);

    const D = [];
    let I,
        z = N.concat();

    for (let t = 0, e = T.length; t < e; t++) {
      const e = T[t];
      I = [];

      for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), I[t] = O(e[t], e[i], e[r]);

      D.push(I), z = z.concat(I);
    }

    for (let t = 0; t < f; t++) {
      const e = t / f,
            n = h * Math.cos(e * Math.PI / 2),
            i = d * Math.sin(e * Math.PI / 2) + p;

      for (let t = 0, e = L.length; t < e; t++) {
        const e = C(L[t], N[t], i);
        H(e.x, e.y, -n);
      }

      for (let t = 0, e = T.length; t < e; t++) {
        const e = T[t];
        I = D[t];

        for (let t = 0, r = e.length; t < r; t++) {
          const r = C(e[t], I[t], i);
          H(r.x, r.y, -n);
        }
      }
    }

    const B = d + p;

    for (let t = 0; t < R; t++) {
      const e = u ? C(E[t], z[t], B) : E[t];
      M ? (b.copy(x.normals[0]).multiplyScalar(e.x), _.copy(x.binormals[0]).multiplyScalar(e.y), w.copy(y[0]).add(b).add(_), H(w.x, w.y, w.z)) : H(e.x, e.y, 0);
    }

    for (let t = 1; t <= c; t++) for (let e = 0; e < R; e++) {
      const n = u ? C(E[e], z[e], B) : E[e];
      M ? (b.copy(x.normals[t]).multiplyScalar(n.x), _.copy(x.binormals[t]).multiplyScalar(n.y), w.copy(y[t]).add(b).add(_), H(w.x, w.y, w.z)) : H(n.x, n.y, l / c * t);
    }

    for (let t = f - 1; t >= 0; t--) {
      const e = t / f,
            n = h * Math.cos(e * Math.PI / 2),
            i = d * Math.sin(e * Math.PI / 2) + p;

      for (let t = 0, e = L.length; t < e; t++) {
        const e = C(L[t], N[t], i);
        H(e.x, e.y, l + n);
      }

      for (let t = 0, e = T.length; t < e; t++) {
        const e = T[t];
        I = D[t];

        for (let t = 0, r = e.length; t < r; t++) {
          const r = C(e[t], I[t], i);
          M ? H(r.x, r.y + y[c - 1].y, y[c - 1].x + n) : H(r.x, r.y, l + n);
        }
      }
    }

    function k(t, e) {
      let n = t.length;

      for (; --n >= 0;) {
        const i = n;
        let r = n - 1;
        r < 0 && (r = t.length - 1);

        for (let t = 0, n = c + 2 * f; t < n; t++) {
          const n = R * t,
                o = R * (t + 1);
          U(e + i + n, e + r + n, e + r + o, e + i + o);
        }
      }
    }

    function H(t, e, n) {
      s.push(t), s.push(e), s.push(n);
    }

    function F(t, e, i) {
      G(t), G(e), G(i);
      const o = r.length / 3,
            s = v.generateTopUV(n, r, o - 3, o - 2, o - 1);
      j(s[0]), j(s[1]), j(s[2]);
    }

    function U(t, e, i, o) {
      G(t), G(e), G(o), G(e), G(i), G(o);
      const s = r.length / 3,
            a = v.generateSideWallUV(n, r, s - 6, s - 3, s - 2, s - 1);
      j(a[0]), j(a[1]), j(a[3]), j(a[1]), j(a[2]), j(a[3]);
    }

    function G(t) {
      r.push(s[3 * t + 0]), r.push(s[3 * t + 1]), r.push(s[3 * t + 2]);
    }

    function j(t) {
      o.push(t.x), o.push(t.y);
    }

    !function () {
      const t = r.length / 3;

      if (u) {
        let t = 0,
            e = R * t;

        for (let t = 0; t < P; t++) {
          const n = A[t];
          F(n[2] + e, n[1] + e, n[0] + e);
        }

        t = c + 2 * f, e = R * t;

        for (let t = 0; t < P; t++) {
          const n = A[t];
          F(n[0] + e, n[1] + e, n[2] + e);
        }
      } else {
        for (let t = 0; t < P; t++) {
          const e = A[t];
          F(e[2], e[1], e[0]);
        }

        for (let t = 0; t < P; t++) {
          const e = A[t];
          F(e[0] + R * c, e[1] + R * c, e[2] + R * c);
        }
      }

      n.addGroup(t, r.length / 3 - t, 0);
    }(), function () {
      const t = r.length / 3;
      let e = 0;
      k(L, e), e += L.length;

      for (let t = 0, n = T.length; t < n; t++) {
        const n = T[t];
        k(n, e), e += n.length;
      }

      n.addGroup(t, r.length / 3 - t, 1);
    }();
  }

  this.setAttribute("position", new Jt(r, 3)), this.setAttribute("uv", new Jt(o, 2)), this.computeVertexNormals();
}

Qo.prototype = Object.create(Oe.prototype), Qo.prototype.constructor = Qo, Qo.prototype.toJSON = function () {
  const t = Oe.prototype.toJSON.call(this);
  return ts(this.parameters.shapes, this.parameters.options, t);
}, Ko.prototype = Object.create(ae.prototype), Ko.prototype.constructor = Ko, Ko.prototype.toJSON = function () {
  const t = ae.prototype.toJSON.call(this);
  return ts(this.parameters.shapes, this.parameters.options, t);
};
const $o = {
  generateTopUV: function (t, e, n, r, o) {
    const s = e[3 * n],
          a = e[3 * n + 1],
          c = e[3 * r],
          l = e[3 * r + 1],
          u = e[3 * o],
          h = e[3 * o + 1];
    return [new i(s, a), new i(c, l), new i(u, h)];
  },
  generateSideWallUV: function (t, e, n, r, o, s) {
    const a = e[3 * n],
          c = e[3 * n + 1],
          l = e[3 * n + 2],
          u = e[3 * r],
          h = e[3 * r + 1],
          d = e[3 * r + 2],
          p = e[3 * o],
          f = e[3 * o + 1],
          m = e[3 * o + 2],
          g = e[3 * s],
          v = e[3 * s + 1],
          y = e[3 * s + 2];
    return Math.abs(c - h) < .01 ? [new i(a, 1 - l), new i(u, 1 - d), new i(p, 1 - m), new i(g, 1 - y)] : [new i(c, 1 - l), new i(h, 1 - d), new i(f, 1 - m), new i(v, 1 - y)];
  }
};

function ts(t, e, n) {
  if (n.shapes = [], Array.isArray(t)) for (let e = 0, i = t.length; e < i; e++) {
    const i = t[e];
    n.shapes.push(i.uuid);
  } else n.shapes.push(t.uuid);
  return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}

function es(t, e) {
  Oe.call(this), this.type = "TextGeometry", this.parameters = {
    text: t,
    parameters: e
  }, this.fromBufferGeometry(new ns(t, e)), this.mergeVertices();
}

function ns(t, e) {
  const n = (e = e || {}).font;
  if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Oe();
  const i = n.generateShapes(t, e.size);
  e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Ko.call(this, i, e), this.type = "TextBufferGeometry";
}

function is(t, e, n, i, r, o, s) {
  Oe.call(this), this.type = "SphereGeometry", this.parameters = {
    radius: t,
    widthSegments: e,
    heightSegments: n,
    phiStart: i,
    phiLength: r,
    thetaStart: o,
    thetaLength: s
  }, this.fromBufferGeometry(new rs(t, e, n, i, r, o, s)), this.mergeVertices();
}

function rs(t, e, n, i, r, o, s) {
  ae.call(this), this.type = "SphereBufferGeometry", this.parameters = {
    radius: t,
    widthSegments: e,
    heightSegments: n,
    phiStart: i,
    phiLength: r,
    thetaStart: o,
    thetaLength: s
  }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI;
  const a = Math.min(o + s, Math.PI);
  let c = 0;
  const l = [],
        u = new m(),
        h = new m(),
        d = [],
        p = [],
        f = [],
        g = [];

  for (let d = 0; d <= n; d++) {
    const m = [],
          v = d / n;
    let y = 0;
    0 == d && 0 == o ? y = .5 / e : d == n && a == Math.PI && (y = -.5 / e);

    for (let n = 0; n <= e; n++) {
      const a = n / e;
      u.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s), u.y = t * Math.cos(o + v * s), u.z = t * Math.sin(i + a * r) * Math.sin(o + v * s), p.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), g.push(a + y, 1 - v), m.push(c++);
    }

    l.push(m);
  }

  for (let t = 0; t < n; t++) for (let i = 0; i < e; i++) {
    const e = l[t][i + 1],
          r = l[t][i],
          s = l[t + 1][i],
          c = l[t + 1][i + 1];
    (0 !== t || o > 0) && d.push(e, r, c), (t !== n - 1 || a < Math.PI) && d.push(r, s, c);
  }

  this.setIndex(d), this.setAttribute("position", new Jt(p, 3)), this.setAttribute("normal", new Jt(f, 3)), this.setAttribute("uv", new Jt(g, 2));
}

function os(t, e, n, i, r, o) {
  Oe.call(this), this.type = "RingGeometry", this.parameters = {
    innerRadius: t,
    outerRadius: e,
    thetaSegments: n,
    phiSegments: i,
    thetaStart: r,
    thetaLength: o
  }, this.fromBufferGeometry(new ss(t, e, n, i, r, o)), this.mergeVertices();
}

function ss(t, e, n, r, o, s) {
  ae.call(this), this.type = "RingBufferGeometry", this.parameters = {
    innerRadius: t,
    outerRadius: e,
    thetaSegments: n,
    phiSegments: r,
    thetaStart: o,
    thetaLength: s
  }, t = t || .5, e = e || 1, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
  const a = [],
        c = [],
        l = [],
        u = [];
  let h = t;
  const d = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
        p = new m(),
        f = new i();

  for (let t = 0; t <= r; t++) {
    for (let t = 0; t <= n; t++) {
      const i = o + t / n * s;
      p.x = h * Math.cos(i), p.y = h * Math.sin(i), c.push(p.x, p.y, p.z), l.push(0, 0, 1), f.x = (p.x / e + 1) / 2, f.y = (p.y / e + 1) / 2, u.push(f.x, f.y);
    }

    h += d;
  }

  for (let t = 0; t < r; t++) {
    const e = t * (n + 1);

    for (let t = 0; t < n; t++) {
      const i = t + e,
            r = i,
            o = i + n + 1,
            s = i + n + 2,
            c = i + 1;
      a.push(r, o, c), a.push(o, s, c);
    }
  }

  this.setIndex(a), this.setAttribute("position", new Jt(c, 3)), this.setAttribute("normal", new Jt(l, 3)), this.setAttribute("uv", new Jt(u, 2));
}

function as(t, e, n, i) {
  Oe.call(this), this.type = "LatheGeometry", this.parameters = {
    points: t,
    segments: e,
    phiStart: n,
    phiLength: i
  }, this.fromBufferGeometry(new cs(t, e, n, i)), this.mergeVertices();
}

function cs(t, e, r, o) {
  ae.call(this), this.type = "LatheBufferGeometry", this.parameters = {
    points: t,
    segments: e,
    phiStart: r,
    phiLength: o
  }, e = Math.floor(e) || 12, r = r || 0, o = o || 2 * Math.PI, o = n.clamp(o, 0, 2 * Math.PI);
  const s = [],
        a = [],
        c = [],
        l = 1 / e,
        u = new m(),
        h = new i();

  for (let n = 0; n <= e; n++) {
    const i = r + n * l * o,
          s = Math.sin(i),
          d = Math.cos(i);

    for (let i = 0; i <= t.length - 1; i++) u.x = t[i].x * s, u.y = t[i].y, u.z = t[i].x * d, a.push(u.x, u.y, u.z), h.x = n / e, h.y = i / (t.length - 1), c.push(h.x, h.y);
  }

  for (let n = 0; n < e; n++) for (let e = 0; e < t.length - 1; e++) {
    const i = e + n * t.length,
          r = i,
          o = i + t.length,
          a = i + t.length + 1,
          c = i + 1;
    s.push(r, o, c), s.push(o, a, c);
  }

  if (this.setIndex(s), this.setAttribute("position", new Jt(a, 3)), this.setAttribute("uv", new Jt(c, 2)), this.computeVertexNormals(), o === 2 * Math.PI) {
    const n = this.attributes.normal.array,
          i = new m(),
          r = new m(),
          o = new m(),
          s = e * t.length * 3;

    for (let e = 0, a = 0; e < t.length; e++, a += 3) i.x = n[a + 0], i.y = n[a + 1], i.z = n[a + 2], r.x = n[s + a + 0], r.y = n[s + a + 1], r.z = n[s + a + 2], o.addVectors(i, r).normalize(), n[a + 0] = n[s + a + 0] = o.x, n[a + 1] = n[s + a + 1] = o.y, n[a + 2] = n[s + a + 2] = o.z;
  }
}

function ls(t, e) {
  Oe.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
    shapes: t,
    curveSegments: e
  }, this.fromBufferGeometry(new us(t, e)), this.mergeVertices();
}

function us(t, e) {
  ae.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
    shapes: t,
    curveSegments: e
  }, e = e || 12;
  const n = [],
        i = [],
        r = [],
        o = [];
  let s = 0,
      a = 0;
  if (!1 === Array.isArray(t)) c(t);else for (let e = 0; e < t.length; e++) c(t[e]), this.addGroup(s, a, e), s += a, a = 0;

  function c(t) {
    const s = i.length / 3,
          c = t.extractPoints(e);
    let l = c.shape;
    const u = c.holes;
    !1 === Yo.isClockWise(l) && (l = l.reverse());

    for (let t = 0, e = u.length; t < e; t++) {
      const e = u[t];
      !0 === Yo.isClockWise(e) && (u[t] = e.reverse());
    }

    const h = Yo.triangulateShape(l, u);

    for (let t = 0, e = u.length; t < e; t++) {
      const e = u[t];
      l = l.concat(e);
    }

    for (let t = 0, e = l.length; t < e; t++) {
      const e = l[t];
      i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
    }

    for (let t = 0, e = h.length; t < e; t++) {
      const e = h[t],
            i = e[0] + s,
            r = e[1] + s,
            o = e[2] + s;
      n.push(i, r, o), a += 3;
    }
  }

  this.setIndex(n), this.setAttribute("position", new Jt(i, 3)), this.setAttribute("normal", new Jt(r, 3)), this.setAttribute("uv", new Jt(o, 2));
}

function hs(t, e) {
  if (e.shapes = [], Array.isArray(t)) for (let n = 0, i = t.length; n < i; n++) {
    const i = t[n];
    e.shapes.push(i.uuid);
  } else e.shapes.push(t.uuid);
  return e;
}

function ds(t, e) {
  ae.call(this), this.type = "EdgesGeometry", this.parameters = {
    thresholdAngle: e
  }, e = void 0 !== e ? e : 1;
  const i = [],
        r = Math.cos(n.DEG2RAD * e),
        o = [0, 0],
        s = {};
  let a, c, l;
  const u = ["a", "b", "c"];
  let h;
  t.isBufferGeometry ? (h = new Oe(), h.fromBufferGeometry(t)) : h = t.clone(), h.mergeVertices(), h.computeFaceNormals();
  const d = h.vertices,
        p = h.faces;

  for (let t = 0, e = p.length; t < e; t++) {
    const e = p[t];

    for (let n = 0; n < 3; n++) a = e[u[n]], c = e[u[(n + 1) % 3]], o[0] = Math.min(a, c), o[1] = Math.max(a, c), l = o[0] + "," + o[1], void 0 === s[l] ? s[l] = {
      index1: o[0],
      index2: o[1],
      face1: t,
      face2: void 0
    } : s[l].face2 = t;
  }

  for (l in s) {
    const t = s[l];

    if (void 0 === t.face2 || p[t.face1].normal.dot(p[t.face2].normal) <= r) {
      let e = d[t.index1];
      i.push(e.x, e.y, e.z), e = d[t.index2], i.push(e.x, e.y, e.z);
    }
  }

  this.setAttribute("position", new Jt(i, 3));
}

function ps(t, e, n, i, r, o, s, a) {
  Oe.call(this), this.type = "CylinderGeometry", this.parameters = {
    radiusTop: t,
    radiusBottom: e,
    height: n,
    radialSegments: i,
    heightSegments: r,
    openEnded: o,
    thetaStart: s,
    thetaLength: a
  }, this.fromBufferGeometry(new fs(t, e, n, i, r, o, s, a)), this.mergeVertices();
}

function fs(t, e, n, r, o, s, a, c) {
  ae.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
    radiusTop: t,
    radiusBottom: e,
    height: n,
    radialSegments: r,
    heightSegments: o,
    openEnded: s,
    thetaStart: a,
    thetaLength: c
  };
  const l = this;
  t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, r = Math.floor(r) || 8, o = Math.floor(o) || 1, s = void 0 !== s && s, a = void 0 !== a ? a : 0, c = void 0 !== c ? c : 2 * Math.PI;
  const u = [],
        h = [],
        d = [],
        p = [];
  let f = 0;
  const g = [],
        v = n / 2;
  let y = 0;

  function x(n) {
    let o, s;
    const g = new i(),
          x = new m();
    let _ = 0;
    const b = !0 === n ? t : e,
          w = !0 === n ? 1 : -1;
    o = f;

    for (let t = 1; t <= r; t++) h.push(0, v * w, 0), d.push(0, w, 0), p.push(.5, .5), f++;

    s = f;

    for (let t = 0; t <= r; t++) {
      const e = t / r * c + a,
            n = Math.cos(e),
            i = Math.sin(e);
      x.x = b * i, x.y = v * w, x.z = b * n, h.push(x.x, x.y, x.z), d.push(0, w, 0), g.x = .5 * n + .5, g.y = .5 * i * w + .5, p.push(g.x, g.y), f++;
    }

    for (let t = 0; t < r; t++) {
      const e = o + t,
            i = s + t;
      !0 === n ? u.push(i, i + 1, e) : u.push(i + 1, i, e), _ += 3;
    }

    l.addGroup(y, _, !0 === n ? 1 : 2), y += _;
  }

  !function () {
    const i = new m(),
          s = new m();
    let x = 0;

    const _ = (e - t) / n;

    for (let l = 0; l <= o; l++) {
      const u = [],
            m = l / o,
            y = m * (e - t) + t;

      for (let t = 0; t <= r; t++) {
        const e = t / r,
              o = e * c + a,
              l = Math.sin(o),
              g = Math.cos(o);
        s.x = y * l, s.y = -m * n + v, s.z = y * g, h.push(s.x, s.y, s.z), i.set(l, _, g).normalize(), d.push(i.x, i.y, i.z), p.push(e, 1 - m), u.push(f++);
      }

      g.push(u);
    }

    for (let t = 0; t < r; t++) for (let e = 0; e < o; e++) {
      const n = g[e][t],
            i = g[e + 1][t],
            r = g[e + 1][t + 1],
            o = g[e][t + 1];
      u.push(n, i, o), u.push(i, r, o), x += 6;
    }

    l.addGroup(y, x, 0), y += x;
  }(), !1 === s && (t > 0 && x(!0), e > 0 && x(!1)), this.setIndex(u), this.setAttribute("position", new Jt(h, 3)), this.setAttribute("normal", new Jt(d, 3)), this.setAttribute("uv", new Jt(p, 2));
}

function ms(t, e, n, i, r, o, s) {
  ps.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeGeometry", this.parameters = {
    radius: t,
    height: e,
    radialSegments: n,
    heightSegments: i,
    openEnded: r,
    thetaStart: o,
    thetaLength: s
  };
}

function gs(t, e, n, i, r, o, s) {
  fs.call(this, 0, t, e, n, i, r, o, s), this.type = "ConeBufferGeometry", this.parameters = {
    radius: t,
    height: e,
    radialSegments: n,
    heightSegments: i,
    openEnded: r,
    thetaStart: o,
    thetaLength: s
  };
}

function vs(t, e, n, i) {
  Oe.call(this), this.type = "CircleGeometry", this.parameters = {
    radius: t,
    segments: e,
    thetaStart: n,
    thetaLength: i
  }, this.fromBufferGeometry(new ys(t, e, n, i)), this.mergeVertices();
}

function ys(t, e, n, r) {
  ae.call(this), this.type = "CircleBufferGeometry", this.parameters = {
    radius: t,
    segments: e,
    thetaStart: n,
    thetaLength: r
  }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
  const o = [],
        s = [],
        a = [],
        c = [],
        l = new m(),
        u = new i();
  s.push(0, 0, 0), a.push(0, 0, 1), c.push(.5, .5);

  for (let i = 0, o = 3; i <= e; i++, o += 3) {
    const h = n + i / e * r;
    l.x = t * Math.cos(h), l.y = t * Math.sin(h), s.push(l.x, l.y, l.z), a.push(0, 0, 1), u.x = (s[o] / t + 1) / 2, u.y = (s[o + 1] / t + 1) / 2, c.push(u.x, u.y);
  }

  for (let t = 1; t <= e; t++) o.push(t, t + 1, 0);

  this.setIndex(o), this.setAttribute("position", new Jt(s, 3)), this.setAttribute("normal", new Jt(a, 3)), this.setAttribute("uv", new Jt(c, 2));
}

es.prototype = Object.create(Oe.prototype), es.prototype.constructor = es, ns.prototype = Object.create(Ko.prototype), ns.prototype.constructor = ns, is.prototype = Object.create(Oe.prototype), is.prototype.constructor = is, rs.prototype = Object.create(ae.prototype), rs.prototype.constructor = rs, os.prototype = Object.create(Oe.prototype), os.prototype.constructor = os, ss.prototype = Object.create(ae.prototype), ss.prototype.constructor = ss, as.prototype = Object.create(Oe.prototype), as.prototype.constructor = as, cs.prototype = Object.create(ae.prototype), cs.prototype.constructor = cs, ls.prototype = Object.create(Oe.prototype), ls.prototype.constructor = ls, ls.prototype.toJSON = function () {
  const t = Oe.prototype.toJSON.call(this);
  return hs(this.parameters.shapes, t);
}, us.prototype = Object.create(ae.prototype), us.prototype.constructor = us, us.prototype.toJSON = function () {
  const t = ae.prototype.toJSON.call(this);
  return hs(this.parameters.shapes, t);
}, ds.prototype = Object.create(ae.prototype), ds.prototype.constructor = ds, ps.prototype = Object.create(Oe.prototype), ps.prototype.constructor = ps, fs.prototype = Object.create(ae.prototype), fs.prototype.constructor = fs, ms.prototype = Object.create(ps.prototype), ms.prototype.constructor = ms, gs.prototype = Object.create(fs.prototype), gs.prototype.constructor = gs, vs.prototype = Object.create(Oe.prototype), vs.prototype.constructor = vs, ys.prototype = Object.create(ae.prototype), ys.prototype.constructor = ys;
var xs = Object.freeze({
  __proto__: null,
  WireframeGeometry: ro,
  ParametricGeometry: oo,
  ParametricBufferGeometry: so,
  TetrahedronGeometry: lo,
  TetrahedronBufferGeometry: uo,
  OctahedronGeometry: ho,
  OctahedronBufferGeometry: po,
  IcosahedronGeometry: fo,
  IcosahedronBufferGeometry: mo,
  DodecahedronGeometry: go,
  DodecahedronBufferGeometry: vo,
  PolyhedronGeometry: ao,
  PolyhedronBufferGeometry: co,
  TubeGeometry: yo,
  TubeBufferGeometry: xo,
  TorusKnotGeometry: _o,
  TorusKnotBufferGeometry: bo,
  TorusGeometry: wo,
  TorusBufferGeometry: Mo,
  TextGeometry: es,
  TextBufferGeometry: ns,
  SphereGeometry: is,
  SphereBufferGeometry: rs,
  RingGeometry: os,
  RingBufferGeometry: ss,
  PlaneGeometry: Ze,
  PlaneBufferGeometry: Je,
  LatheGeometry: as,
  LatheBufferGeometry: cs,
  ShapeGeometry: ls,
  ShapeBufferGeometry: us,
  ExtrudeGeometry: Qo,
  ExtrudeBufferGeometry: Ko,
  EdgesGeometry: ds,
  ConeGeometry: ms,
  ConeBufferGeometry: gs,
  CylinderGeometry: ps,
  CylinderBufferGeometry: fs,
  CircleGeometry: vs,
  CircleBufferGeometry: ys,
  BoxGeometry: class extends Oe {
    constructor(t, e, n, i, r, o) {
      super(), this.type = "BoxGeometry", this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o
      }, this.fromBufferGeometry(new Ne(t, e, n, i, r, o)), this.mergeVertices();
    }

  },
  BoxBufferGeometry: Ne
});

function _s(t) {
  kt.call(this), this.type = "ShadowMaterial", this.color = new Ot(0), this.transparent = !0, this.setValues(t);
}

function bs(t) {
  Be.call(this, t), this.type = "RawShaderMaterial";
}

function ws(t) {
  kt.call(this), this.defines = {
    STANDARD: ""
  }, this.type = "MeshStandardMaterial", this.color = new Ot(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ot(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t);
}

function Ms(t) {
  ws.call(this), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new i(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transparency = 0, this.setValues(t);
}

function Ss(t) {
  kt.call(this), this.type = "MeshPhongMaterial", this.color = new Ot(16777215), this.specular = new Ot(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ot(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}

function Es(t) {
  kt.call(this), this.defines = {
    TOON: ""
  }, this.type = "MeshToonMaterial", this.color = new Ot(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ot(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}

function Ts(t) {
  kt.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}

function As(t) {
  kt.call(this), this.type = "MeshLambertMaterial", this.color = new Ot(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ot(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}

function Ls(t) {
  kt.call(this), this.defines = {
    MATCAP: ""
  }, this.type = "MeshMatcapMaterial", this.color = new Ot(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t);
}

function Cs(t) {
  zr.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
}

_s.prototype = Object.create(kt.prototype), _s.prototype.constructor = _s, _s.prototype.isShadowMaterial = !0, _s.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this;
}, bs.prototype = Object.create(Be.prototype), bs.prototype.constructor = bs, bs.prototype.isRawShaderMaterial = !0, ws.prototype = Object.create(kt.prototype), ws.prototype.constructor = ws, ws.prototype.isMeshStandardMaterial = !0, ws.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.defines = {
    STANDARD: ""
  }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this;
}, Ms.prototype = Object.create(ws.prototype), Ms.prototype.constructor = Ms, Ms.prototype.isMeshPhysicalMaterial = !0, Ms.prototype.copy = function (t) {
  return ws.prototype.copy.call(this, t), this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Ot()).copy(t.sheen) : this.sheen = null, this.transparency = t.transparency, this;
}, Ss.prototype = Object.create(kt.prototype), Ss.prototype.constructor = Ss, Ss.prototype.isMeshPhongMaterial = !0, Ss.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
}, Es.prototype = Object.create(kt.prototype), Es.prototype.constructor = Es, Es.prototype.isMeshToonMaterial = !0, Es.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
}, Ts.prototype = Object.create(kt.prototype), Ts.prototype.constructor = Ts, Ts.prototype.isMeshNormalMaterial = !0, Ts.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
}, As.prototype = Object.create(kt.prototype), As.prototype.constructor = As, As.prototype.isMeshLambertMaterial = !0, As.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
}, Ls.prototype = Object.create(kt.prototype), Ls.prototype.constructor = Ls, Ls.prototype.isMeshMatcapMaterial = !0, Ls.prototype.copy = function (t) {
  return kt.prototype.copy.call(this, t), this.defines = {
    MATCAP: ""
  }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this;
}, Cs.prototype = Object.create(zr.prototype), Cs.prototype.constructor = Cs, Cs.prototype.isLineDashedMaterial = !0, Cs.prototype.copy = function (t) {
  return zr.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
};
var Rs = Object.freeze({
  __proto__: null,
  ShadowMaterial: _s,
  SpriteMaterial: ar,
  RawShaderMaterial: bs,
  ShaderMaterial: Be,
  PointsMaterial: Xr,
  MeshPhysicalMaterial: Ms,
  MeshStandardMaterial: ws,
  MeshPhongMaterial: Ss,
  MeshToonMaterial: Es,
  MeshNormalMaterial: Ts,
  MeshLambertMaterial: As,
  MeshDepthMaterial: ji,
  MeshDistanceMaterial: Vi,
  MeshBasicMaterial: Ht,
  MeshMatcapMaterial: Ls,
  LineDashedMaterial: Cs,
  LineBasicMaterial: zr,
  Material: kt
});
const Ps = {
  arraySlice: function (t, e, n) {
    return Ps.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n);
  },
  convertArray: function (t, e, n) {
    return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
  },
  isTypedArray: function (t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  },
  getKeyframeOrder: function (t) {
    const e = t.length,
          n = new Array(e);

    for (let t = 0; t !== e; ++t) n[t] = t;

    return n.sort(function (e, n) {
      return t[e] - t[n];
    }), n;
  },
  sortedArray: function (t, e, n) {
    const i = t.length,
          r = new t.constructor(i);

    for (let o = 0, s = 0; s !== i; ++o) {
      const i = n[o] * e;

      for (let n = 0; n !== e; ++n) r[s++] = t[i + n];
    }

    return r;
  },
  flattenJSON: function (t, e, n, i) {
    let r = 1,
        o = t[0];

    for (; void 0 !== o && void 0 === o[i];) o = t[r++];

    if (void 0 === o) return;
    let s = o[i];
    if (void 0 !== s) if (Array.isArray(s)) do {
      s = o[i], void 0 !== s && (e.push(o.time), n.push.apply(n, s)), o = t[r++];
    } while (void 0 !== o);else if (void 0 !== s.toArray) do {
      s = o[i], void 0 !== s && (e.push(o.time), s.toArray(n, n.length)), o = t[r++];
    } while (void 0 !== o);else do {
      s = o[i], void 0 !== s && (e.push(o.time), n.push(s)), o = t[r++];
    } while (void 0 !== o);
  },
  subclip: function (t, e, n, i, r) {
    r = r || 30;
    const o = t.clone();
    o.name = e;
    const s = [];

    for (let t = 0; t < o.tracks.length; ++t) {
      const e = o.tracks[t],
            a = e.getValueSize(),
            c = [],
            l = [];

      for (let t = 0; t < e.times.length; ++t) {
        const o = e.times[t] * r;

        if (!(o < n || o >= i)) {
          c.push(e.times[t]);

          for (let n = 0; n < a; ++n) l.push(e.values[t * a + n]);
        }
      }

      0 !== c.length && (e.times = Ps.convertArray(c, e.times.constructor), e.values = Ps.convertArray(l, e.values.constructor), s.push(e));
    }

    o.tracks = s;
    let a = 1 / 0;

    for (let t = 0; t < o.tracks.length; ++t) a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);

    for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);

    return o.resetDuration(), o;
  },
  makeClipAdditive: function (t, e, n, i) {
    void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === i || i <= 0) && (i = 30);
    const r = t.tracks.length,
          o = e / i;

    for (let e = 0; e < r; ++e) {
      const i = n.tracks[e],
            r = i.ValueTypeName;
      if ("bool" === r || "string" === r) continue;
      const s = t.tracks.find(function (t) {
        return t.name === i.name && t.ValueTypeName === r;
      });
      if (void 0 === s) continue;
      const a = i.getValueSize(),
            c = i.times.length - 1;
      let l;
      if (o <= i.times[0]) l = Ps.arraySlice(i.values, 0, i.valueSize);else if (o >= i.times[c]) {
        const t = c * a;
        l = Ps.arraySlice(i.values, t);
      } else {
        const t = i.createInterpolant();
        t.evaluate(o), l = t.resultBuffer;
      }
      "quaternion" === r && new d(l[0], l[1], l[2], l[3]).normalize().conjugate().toArray(l);
      const u = s.times.length;

      for (let t = 0; t < u; ++t) {
        const e = t * a;
        if ("quaternion" === r) d.multiplyQuaternionsFlat(s.values, e, l, 0, s.values, e);else for (let t = 0; t < a; ++t) s.values[e + t] -= l[t];
      }
    }

    return t.blendMode = 2501, t;
  }
};

function Os(t, e, n, i) {
  this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n;
}

function Ns(t, e, n, i) {
  Os.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}

function Ds(t, e, n, i) {
  Os.call(this, t, e, n, i);
}

function Is(t, e, n, i) {
  Os.call(this, t, e, n, i);
}

function zs(t, e, n, i) {
  if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
  this.name = t, this.times = Ps.convertArray(e, this.TimeBufferType), this.values = Ps.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
}

function Bs(t, e, n) {
  zs.call(this, t, e, n);
}

function ks(t, e, n, i) {
  zs.call(this, t, e, n, i);
}

function Hs(t, e, n, i) {
  zs.call(this, t, e, n, i);
}

function Fs(t, e, n, i) {
  Os.call(this, t, e, n, i);
}

function Us(t, e, n, i) {
  zs.call(this, t, e, n, i);
}

function Gs(t, e, n, i) {
  zs.call(this, t, e, n, i);
}

function js(t, e, n, i) {
  zs.call(this, t, e, n, i);
}

function Vs(t, e, i, r) {
  this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== r ? r : 2500, this.uuid = n.generateUUID(), this.duration < 0 && this.resetDuration();
}

function Ws(t) {
  if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");

  const e = function (t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Hs;

      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return js;

      case "color":
        return ks;

      case "quaternion":
        return Us;

      case "bool":
      case "boolean":
        return Bs;

      case "string":
        return Gs;
    }

    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  }(t.type);

  if (void 0 === t.times) {
    const e = [],
          n = [];
    Ps.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n;
  }

  return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
}

Object.assign(Os.prototype, {
  evaluate: function (t) {
    let e = this.parameterPositions,
        n = this._cachedIndex,
        i = e[n],
        r = e[n - 1];

    t: {
      e: {
        let o;

        n: {
          i: if (!(t < i)) {
            for (let o = n + 2;;) {
              if (void 0 === i) {
                if (t < r) break i;
                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r);
              }

              if (n === o) break;
              if (r = i, i = e[++n], t < i) break e;
            }

            o = e.length;
            break n;
          }

          if (t >= r) break t;
          {
            const s = e[1];
            t < s && (n = 2, r = s);

            for (let o = n - 2;;) {
              if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
              if (n === o) break;
              if (i = r, r = e[--n - 1], t >= r) break e;
            }

            o = n, n = 0;
          }
        }

        for (; n < o;) {
          const i = n + o >>> 1;
          t < e[i] ? o = i : n = i + 1;
        }

        if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
        if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t);
      }

      this._cachedIndex = n, this.intervalChanged_(n, r, i);
    }

    return this.interpolate_(n, r, t, i);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (t) {
    const e = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = t * i;

    for (let t = 0; t !== i; ++t) e[t] = n[r + t];

    return e;
  },
  interpolate_: function () {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function () {}
}), Object.assign(Os.prototype, {
  beforeStart_: Os.prototype.copySampleValue_,
  afterEnd_: Os.prototype.copySampleValue_
}), Ns.prototype = Object.assign(Object.create(Os.prototype), {
  constructor: Ns,
  DefaultSettings_: {
    endingStart: 2400,
    endingEnd: 2400
  },
  intervalChanged_: function (t, e, n) {
    let i = this.parameterPositions,
        r = t - 2,
        o = t + 1,
        s = i[r],
        a = i[o];
    if (void 0 === s) switch (this.getSettings_().endingStart) {
      case 2401:
        r = t, s = 2 * e - n;
        break;

      case 2402:
        r = i.length - 2, s = e + i[r] - i[r + 1];
        break;

      default:
        r = t, s = n;
    }
    if (void 0 === a) switch (this.getSettings_().endingEnd) {
      case 2401:
        o = t, a = 2 * n - e;
        break;

      case 2402:
        o = 1, a = n + i[1] - i[0];
        break;

      default:
        o = t - 1, a = e;
    }
    const c = .5 * (n - e),
          l = this.valueSize;
    this._weightPrev = c / (e - s), this._weightNext = c / (a - n), this._offsetPrev = r * l, this._offsetNext = o * l;
  },
  interpolate_: function (t, e, n, i) {
    const r = this.resultBuffer,
          o = this.sampleValues,
          s = this.valueSize,
          a = t * s,
          c = a - s,
          l = this._offsetPrev,
          u = this._offsetNext,
          h = this._weightPrev,
          d = this._weightNext,
          p = (n - e) / (i - e),
          f = p * p,
          m = f * p,
          g = -h * m + 2 * h * f - h * p,
          v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
          y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
          x = d * m - d * f;

    for (let t = 0; t !== s; ++t) r[t] = g * o[l + t] + v * o[c + t] + y * o[a + t] + x * o[u + t];

    return r;
  }
}), Ds.prototype = Object.assign(Object.create(Os.prototype), {
  constructor: Ds,
  interpolate_: function (t, e, n, i) {
    const r = this.resultBuffer,
          o = this.sampleValues,
          s = this.valueSize,
          a = t * s,
          c = a - s,
          l = (n - e) / (i - e),
          u = 1 - l;

    for (let t = 0; t !== s; ++t) r[t] = o[c + t] * u + o[a + t] * l;

    return r;
  }
}), Is.prototype = Object.assign(Object.create(Os.prototype), {
  constructor: Is,
  interpolate_: function (t) {
    return this.copySampleValue_(t - 1);
  }
}), Object.assign(zs, {
  toJSON: function (t) {
    const e = t.constructor;
    let n;
    if (void 0 !== e.toJSON) n = e.toJSON(t);else {
      n = {
        name: t.name,
        times: Ps.convertArray(t.times, Array),
        values: Ps.convertArray(t.values, Array)
      };
      const e = t.getInterpolation();
      e !== t.DefaultInterpolation && (n.interpolation = e);
    }
    return n.type = t.ValueTypeName, n;
  }
}), Object.assign(zs.prototype, {
  constructor: zs,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: 2301,
  InterpolantFactoryMethodDiscrete: function (t) {
    return new Is(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodLinear: function (t) {
    return new Ds(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: function (t) {
    return new Ns(this.times, this.values, this.getValueSize(), t);
  },
  setInterpolation: function (t) {
    let e;

    switch (t) {
      case 2300:
        e = this.InterpolantFactoryMethodDiscrete;
        break;

      case 2301:
        e = this.InterpolantFactoryMethodLinear;
        break;

      case 2302:
        e = this.InterpolantFactoryMethodSmooth;
    }

    if (void 0 === e) {
      const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

      if (void 0 === this.createInterpolant) {
        if (t === this.DefaultInterpolation) throw new Error(e);
        this.setInterpolation(this.DefaultInterpolation);
      }

      return console.warn("THREE.KeyframeTrack:", e), this;
    }

    return this.createInterpolant = e, this;
  },
  getInterpolation: function () {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;

      case this.InterpolantFactoryMethodLinear:
        return 2301;

      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  },
  getValueSize: function () {
    return this.values.length / this.times.length;
  },
  shift: function (t) {
    if (0 !== t) {
      const e = this.times;

      for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
    }

    return this;
  },
  scale: function (t) {
    if (1 !== t) {
      const e = this.times;

      for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
    }

    return this;
  },
  trim: function (t, e) {
    const n = this.times,
          i = n.length;
    let r = 0,
        o = i - 1;

    for (; r !== i && n[r] < t;) ++r;

    for (; -1 !== o && n[o] > e;) --o;

    if (++o, 0 !== r || o !== i) {
      r >= o && (o = Math.max(o, 1), r = o - 1);
      const t = this.getValueSize();
      this.times = Ps.arraySlice(n, r, o), this.values = Ps.arraySlice(this.values, r * t, o * t);
    }

    return this;
  },
  validate: function () {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
    const n = this.times,
          i = this.values,
          r = n.length;
    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
    let o = null;

    for (let e = 0; e !== r; e++) {
      const i = n[e];

      if ("number" == typeof i && isNaN(i)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
        break;
      }

      if (null !== o && o > i) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, o), t = !1;
        break;
      }

      o = i;
    }

    if (void 0 !== i && Ps.isTypedArray(i)) for (let e = 0, n = i.length; e !== n; ++e) {
      const n = i[e];

      if (isNaN(n)) {
        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
        break;
      }
    }
    return t;
  },
  optimize: function () {
    const t = Ps.arraySlice(this.times),
          e = Ps.arraySlice(this.values),
          n = this.getValueSize(),
          i = 2302 === this.getInterpolation(),
          r = t.length - 1;
    let o = 1;

    for (let s = 1; s < r; ++s) {
      let r = !1;
      const a = t[s];
      if (a !== t[s + 1] && (1 !== s || a !== a[0])) if (i) r = !0;else {
        const t = s * n,
              i = t - n,
              o = t + n;

        for (let s = 0; s !== n; ++s) {
          const n = e[t + s];

          if (n !== e[i + s] || n !== e[o + s]) {
            r = !0;
            break;
          }
        }
      }

      if (r) {
        if (s !== o) {
          t[o] = t[s];
          const i = s * n,
                r = o * n;

          for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
        }

        ++o;
      }
    }

    if (r > 0) {
      t[o] = t[r];

      for (let t = r * n, i = o * n, s = 0; s !== n; ++s) e[i + s] = e[t + s];

      ++o;
    }

    return o !== t.length ? (this.times = Ps.arraySlice(t, 0, o), this.values = Ps.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this;
  },
  clone: function () {
    const t = Ps.arraySlice(this.times, 0),
          e = Ps.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, t, e);
    return n.createInterpolant = this.createInterpolant, n;
  }
}), Bs.prototype = Object.assign(Object.create(zs.prototype), {
  constructor: Bs,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: 2300,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
}), ks.prototype = Object.assign(Object.create(zs.prototype), {
  constructor: ks,
  ValueTypeName: "color"
}), Hs.prototype = Object.assign(Object.create(zs.prototype), {
  constructor: Hs,
  ValueTypeName: "number"
}), Fs.prototype = Object.assign(Object.create(Os.prototype), {
  constructor: Fs,
  interpolate_: function (t, e, n, i) {
    const r = this.resultBuffer,
          o = this.sampleValues,
          s = this.valueSize,
          a = (n - e) / (i - e);
    let c = t * s;

    for (let t = c + s; c !== t; c += 4) d.slerpFlat(r, 0, o, c - s, o, c, a);

    return r;
  }
}), Us.prototype = Object.assign(Object.create(zs.prototype), {
  constructor: Us,
  ValueTypeName: "quaternion",
  DefaultInterpolation: 2301,
  InterpolantFactoryMethodLinear: function (t) {
    return new Fs(this.times, this.values, this.getValueSize(), t);
  },
  InterpolantFactoryMethodSmooth: void 0
}), Gs.prototype = Object.assign(Object.create(zs.prototype), {
  constructor: Gs,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: 2300,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
}), js.prototype = Object.assign(Object.create(zs.prototype), {
  constructor: js,
  ValueTypeName: "vector"
}), Object.assign(Vs, {
  parse: function (t) {
    const e = [],
          n = t.tracks,
          i = 1 / (t.fps || 1);

    for (let t = 0, r = n.length; t !== r; ++t) e.push(Ws(n[t]).scale(i));

    return new Vs(t.name, t.duration, e, t.blendMode);
  },
  toJSON: function (t) {
    const e = [],
          n = t.tracks,
          i = {
      name: t.name,
      duration: t.duration,
      tracks: e,
      uuid: t.uuid,
      blendMode: t.blendMode
    };

    for (let t = 0, i = n.length; t !== i; ++t) e.push(zs.toJSON(n[t]));

    return i;
  },
  CreateFromMorphTargetSequence: function (t, e, n, i) {
    const r = e.length,
          o = [];

    for (let t = 0; t < r; t++) {
      let s = [],
          a = [];
      s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
      const c = Ps.getKeyframeOrder(s);
      s = Ps.sortedArray(s, 1, c), a = Ps.sortedArray(a, 1, c), i || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new Hs(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / n));
    }

    return new Vs(t, -1, o);
  },
  findByName: function (t, e) {
    let n = t;

    if (!Array.isArray(t)) {
      const e = t;
      n = e.geometry && e.geometry.animations || e.animations;
    }

    for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];

    return null;
  },
  CreateClipsFromMorphTargetSequences: function (t, e, n) {
    const i = {},
          r = /^([\w-]*?)([\d]+)$/;

    for (let e = 0, n = t.length; e < n; e++) {
      const n = t[e],
            o = n.name.match(r);

      if (o && o.length > 1) {
        const t = o[1];
        let e = i[t];
        e || (i[t] = e = []), e.push(n);
      }
    }

    const o = [];

    for (const t in i) o.push(Vs.CreateFromMorphTargetSequence(t, i[t], e, n));

    return o;
  },
  parseAnimation: function (t, e) {
    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;

    const n = function (t, e, n, i, r) {
      if (0 !== n.length) {
        const o = [],
              s = [];
        Ps.flattenJSON(n, o, s, i), 0 !== o.length && r.push(new t(e, o, s));
      }
    },
          i = [],
          r = t.name || "default",
          o = t.fps || 30,
          s = t.blendMode;

    let a = t.length || -1;
    const c = t.hierarchy || [];

    for (let t = 0; t < c.length; t++) {
      const r = c[t].keys;
      if (r && 0 !== r.length) if (r[0].morphTargets) {
        const t = {};
        let e;

        for (e = 0; e < r.length; e++) if (r[e].morphTargets) for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;

        for (const n in t) {
          const t = [],
                o = [];

          for (let i = 0; i !== r[e].morphTargets.length; ++i) {
            const i = r[e];
            t.push(i.time), o.push(i.morphTarget === n ? 1 : 0);
          }

          i.push(new Hs(".morphTargetInfluence[" + n + "]", t, o));
        }

        a = t.length * (o || 1);
      } else {
        const o = ".bones[" + e[t].name + "]";
        n(js, o + ".position", r, "pos", i), n(Us, o + ".quaternion", r, "rot", i), n(js, o + ".scale", r, "scl", i);
      }
    }

    return 0 === i.length ? null : new Vs(r, a, i, s);
  }
}), Object.assign(Vs.prototype, {
  resetDuration: function () {
    let t = 0;

    for (let e = 0, n = this.tracks.length; e !== n; ++e) {
      const n = this.tracks[e];
      t = Math.max(t, n.times[n.times.length - 1]);
    }

    return this.duration = t, this;
  },
  trim: function () {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);

    return this;
  },
  validate: function () {
    let t = !0;

    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();

    return t;
  },
  optimize: function () {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();

    return this;
  },
  clone: function () {
    const t = [];

    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());

    return new Vs(this.name, this.duration, t, this.blendMode);
  }
});
const qs = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    !1 !== this.enabled && (this.files[t] = e);
  },
  get: function (t) {
    if (!1 !== this.enabled) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  }
};

function Xs(t, e, n) {
  const i = this;
  let r = !1,
      o = 0,
      s = 0,
      a = void 0;
  const c = [];
  this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
    s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), r = !0;
  }, this.itemEnd = function (t) {
    o++, void 0 !== i.onProgress && i.onProgress(t, o, s), o === s && (r = !1, void 0 !== i.onLoad && i.onLoad());
  }, this.itemError = function (t) {
    void 0 !== i.onError && i.onError(t);
  }, this.resolveURL = function (t) {
    return a ? a(t) : t;
  }, this.setURLModifier = function (t) {
    return a = t, this;
  }, this.addHandler = function (t, e) {
    return c.push(t, e), this;
  }, this.removeHandler = function (t) {
    const e = c.indexOf(t);
    return -1 !== e && c.splice(e, 2), this;
  }, this.getHandler = function (t) {
    for (let e = 0, n = c.length; e < n; e += 2) {
      const n = c[e],
            i = c[e + 1];
      if (n.global && (n.lastIndex = 0), n.test(t)) return i;
    }

    return null;
  };
}

const Ys = new Xs();

function Zs(t) {
  this.manager = void 0 !== t ? t : Ys, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = "", this.requestHeader = {};
}

Object.assign(Zs.prototype, {
  load: function () {},
  loadAsync: function (t, e) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(t, i, e, r);
    });
  },
  parse: function () {},
  setCrossOrigin: function (t) {
    return this.crossOrigin = t, this;
  },
  setPath: function (t) {
    return this.path = t, this;
  },
  setResourcePath: function (t) {
    return this.resourcePath = t, this;
  },
  setRequestHeader: function (t) {
    return this.requestHeader = t, this;
  }
});
const Js = {};

function Qs(t) {
  Zs.call(this, t);
}

function Ks(t) {
  Zs.call(this, t);
}

function $s(t) {
  Zs.call(this, t);
}

function ta(t) {
  Zs.call(this, t);
}

function ea(t) {
  Zs.call(this, t);
}

function na(t) {
  Zs.call(this, t);
}

function ia(t) {
  Zs.call(this, t);
}

function ra() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}

function oa(t, e, n, i, r, o, s, a) {
  ra.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0;
}

function sa(t, e, n, i, r, o) {
  oa.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve";
}

function aa() {
  let t = 0,
      e = 0,
      n = 0,
      i = 0;

  function r(r, o, s, a) {
    t = r, e = s, n = -3 * r + 3 * o - 2 * s - a, i = 2 * r - 2 * o + s + a;
  }

  return {
    initCatmullRom: function (t, e, n, i, o) {
      r(e, n, o * (n - t), o * (i - e));
    },
    initNonuniformCatmullRom: function (t, e, n, i, o, s, a) {
      let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
          l = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
      c *= s, l *= s, r(e, n, c, l);
    },
    calc: function (r) {
      const o = r * r;
      return t + e * r + n * o + i * (o * r);
    }
  };
}

Qs.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: Qs,
  load: function (t, e, n, i) {
    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
    const r = this,
          o = qs.get(t);
    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
      e && e(o), r.manager.itemEnd(t);
    }, 0), o;
    if (void 0 !== Js[t]) return void Js[t].push({
      onLoad: e,
      onProgress: n,
      onError: i
    });
    const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
    let a;

    if (s) {
      const n = s[1],
            o = !!s[2];
      let a = s[3];
      a = decodeURIComponent(a), o && (a = atob(a));

      try {
        let i;
        const o = (this.responseType || "").toLowerCase();

        switch (o) {
          case "arraybuffer":
          case "blob":
            const t = new Uint8Array(a.length);

            for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);

            i = "blob" === o ? new Blob([t.buffer], {
              type: n
            }) : t.buffer;
            break;

          case "document":
            const e = new DOMParser();
            i = e.parseFromString(a, n);
            break;

          case "json":
            i = JSON.parse(a);
            break;

          default:
            i = a;
        }

        setTimeout(function () {
          e && e(i), r.manager.itemEnd(t);
        }, 0);
      } catch (e) {
        setTimeout(function () {
          i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
        }, 0);
      }
    } else {
      Js[t] = [], Js[t].push({
        onLoad: e,
        onProgress: n,
        onError: i
      }), a = new XMLHttpRequest(), a.open("GET", t, !0), a.addEventListener("load", function (e) {
        const n = this.response,
              i = Js[t];

        if (delete Js[t], 200 === this.status || 0 === this.status) {
          0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), qs.add(t, n);

          for (let t = 0, e = i.length; t < e; t++) {
            const e = i[t];
            e.onLoad && e.onLoad(n);
          }

          r.manager.itemEnd(t);
        } else {
          for (let t = 0, n = i.length; t < n; t++) {
            const n = i[t];
            n.onError && n.onError(e);
          }

          r.manager.itemError(t), r.manager.itemEnd(t);
        }
      }, !1), a.addEventListener("progress", function (e) {
        const n = Js[t];

        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t];
          i.onProgress && i.onProgress(e);
        }
      }, !1), a.addEventListener("error", function (e) {
        const n = Js[t];
        delete Js[t];

        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t];
          i.onError && i.onError(e);
        }

        r.manager.itemError(t), r.manager.itemEnd(t);
      }, !1), a.addEventListener("abort", function (e) {
        const n = Js[t];
        delete Js[t];

        for (let t = 0, i = n.length; t < i; t++) {
          const i = n[t];
          i.onError && i.onError(e);
        }

        r.manager.itemError(t), r.manager.itemEnd(t);
      }, !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");

      for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);

      a.send(null);
    }

    return r.manager.itemStart(t), a;
  },
  setResponseType: function (t) {
    return this.responseType = t, this;
  },
  setWithCredentials: function (t) {
    return this.withCredentials = t, this;
  },
  setMimeType: function (t) {
    return this.mimeType = t, this;
  }
}), Ks.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: Ks,
  load: function (t, e, n, i) {
    const r = this,
          o = new Qs(r.manager);
    o.setPath(r.path), o.load(t, function (n) {
      try {
        e(r.parse(JSON.parse(n)));
      } catch (e) {
        i ? i(e) : console.error(e), r.manager.itemError(t);
      }
    }, n, i);
  },
  parse: function (t) {
    const e = [];

    for (let n = 0; n < t.length; n++) {
      const i = Vs.parse(t[n]);
      e.push(i);
    }

    return e;
  }
}), $s.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: $s,
  load: function (t, e, n, i) {
    const r = this,
          o = [],
          s = new eo();
    s.image = o;
    const a = new Qs(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer");
    let c = 0;

    function l(l) {
      a.load(t[l], function (t) {
        const n = r.parse(t, !0);
        o[l] = {
          width: n.width,
          height: n.height,
          format: n.format,
          mipmaps: n.mipmaps
        }, c += 1, 6 === c && (1 === n.mipmapCount && (s.minFilter = 1006), s.format = n.format, s.needsUpdate = !0, e && e(s));
      }, n, i);
    }

    if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) l(e);else a.load(t, function (t) {
      const n = r.parse(t, !0);

      if (n.isCubemap) {
        const t = n.mipmaps.length / n.mipmapCount;

        for (let e = 0; e < t; e++) {
          o[e] = {
            mipmaps: []
          };

          for (let t = 0; t < n.mipmapCount; t++) o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height;
        }
      } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;

      1 === n.mipmapCount && (s.minFilter = 1006), s.format = n.format, s.needsUpdate = !0, e && e(s);
    }, n, i);
    return s;
  }
}), ta.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: ta,
  load: function (t, e, n, i) {
    const r = this,
          o = new Ge(),
          s = new Qs(this.manager);
    return s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(t, function (t) {
      const n = r.parse(t);
      n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001, o.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001, o.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006, o.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = 1008), 1 === n.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, e && e(o, n));
    }, n, i), o;
  }
}), ea.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: ea,
  load: function (t, e, n, i) {
    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
    const r = this,
          o = qs.get(t);
    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
      e && e(o), r.manager.itemEnd(t);
    }, 0), o;
    const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

    function a() {
      s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), qs.add(t, this), e && e(this), r.manager.itemEnd(t);
    }

    function c(e) {
      s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
    }

    return s.addEventListener("load", a, !1), s.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s;
  }
}), na.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: na,
  load: function (t, e, n, i) {
    const r = new pn(),
          o = new ea(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let s = 0;

    function a(n) {
      o.load(t[n], function (t) {
        r.images[n] = t, s++, 6 === s && (r.needsUpdate = !0, e && e(r));
      }, void 0, i);
    }

    for (let e = 0; e < t.length; ++e) a(e);

    return r;
  }
}), ia.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: ia,
  load: function (t, e, n, i) {
    const r = new c(),
          o = new ea(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (n) {
      r.image = n;
      const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
      r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== e && e(r);
    }, n, i), r;
  }
}), Object.assign(ra.prototype, {
  getPoint: function () {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  },
  getPointAt: function (t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  },
  getPoints: function (t) {
    void 0 === t && (t = 5);
    const e = [];

    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));

    return e;
  },
  getSpacedPoints: function (t) {
    void 0 === t && (t = 5);
    const e = [];

    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));

    return e;
  },
  getLength: function () {
    const t = this.getLengths();
    return t[t.length - 1];
  },
  getLengths: function (t) {
    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n,
        i = this.getPoint(0),
        r = 0;
    e.push(0);

    for (let o = 1; o <= t; o++) n = this.getPoint(o / t), r += n.distanceTo(i), e.push(r), i = n;

    return this.cacheArcLengths = e, e;
  },
  updateArcLengths: function () {
    this.needsUpdate = !0, this.getLengths();
  },
  getUtoTmapping: function (t, e) {
    const n = this.getLengths();
    let i,
        r = 0,
        o = n.length;
    i = e || t * n[o - 1];
    let s,
        a = 0,
        c = o - 1;

    for (; a <= c;) if (r = Math.floor(a + (c - a) / 2), s = n[r] - i, s < 0) a = r + 1;else {
      if (!(s > 0)) {
        c = r;
        break;
      }

      c = r - 1;
    }

    if (r = c, n[r] === i) return r / (o - 1);
    const l = n[r];
    return (r + (i - l) / (n[r + 1] - l)) / (o - 1);
  },
  getTangent: function (t, e) {
    let n = t - 1e-4,
        r = t + 1e-4;
    n < 0 && (n = 0), r > 1 && (r = 1);
    const o = this.getPoint(n),
          s = this.getPoint(r),
          a = e || (o.isVector2 ? new i() : new m());
    return a.copy(s).sub(o).normalize(), a;
  },
  getTangentAt: function (t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  },
  computeFrenetFrames: function (t, e) {
    const i = new m(),
          r = [],
          o = [],
          s = [],
          a = new m(),
          c = new M();

    for (let e = 0; e <= t; e++) {
      const n = e / t;
      r[e] = this.getTangentAt(n, new m()), r[e].normalize();
    }

    o[0] = new m(), s[0] = new m();
    let l = Number.MAX_VALUE;
    const u = Math.abs(r[0].x),
          h = Math.abs(r[0].y),
          d = Math.abs(r[0].z);
    u <= l && (l = u, i.set(1, 0, 0)), h <= l && (l = h, i.set(0, 1, 0)), d <= l && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), o[0].crossVectors(r[0], a), s[0].crossVectors(r[0], o[0]);

    for (let e = 1; e <= t; e++) {
      if (o[e] = o[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(r[e - 1], r[e]), a.length() > Number.EPSILON) {
        a.normalize();
        const t = Math.acos(n.clamp(r[e - 1].dot(r[e]), -1, 1));
        o[e].applyMatrix4(c.makeRotationAxis(a, t));
      }

      s[e].crossVectors(r[e], o[e]);
    }

    if (!0 === e) {
      let e = Math.acos(n.clamp(o[0].dot(o[t]), -1, 1));
      e /= t, r[0].dot(a.crossVectors(o[0], o[t])) > 0 && (e = -e);

      for (let n = 1; n <= t; n++) o[n].applyMatrix4(c.makeRotationAxis(r[n], e * n)), s[n].crossVectors(r[n], o[n]);
    }

    return {
      tangents: r,
      normals: o,
      binormals: s
    };
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  },
  toJSON: function () {
    const t = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
  },
  fromJSON: function (t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
}), oa.prototype = Object.create(ra.prototype), oa.prototype.constructor = oa, oa.prototype.isEllipseCurve = !0, oa.prototype.getPoint = function (t, e) {
  const n = e || new i(),
        r = 2 * Math.PI;
  let o = this.aEndAngle - this.aStartAngle;
  const s = Math.abs(o) < Number.EPSILON;

  for (; o < 0;) o += r;

  for (; o > r;) o -= r;

  o < Number.EPSILON && (o = s ? 0 : r), !0 !== this.aClockwise || s || (o === r ? o = -r : o -= r);
  const a = this.aStartAngle + t * o;
  let c = this.aX + this.xRadius * Math.cos(a),
      l = this.aY + this.yRadius * Math.sin(a);

  if (0 !== this.aRotation) {
    const t = Math.cos(this.aRotation),
          e = Math.sin(this.aRotation),
          n = c - this.aX,
          i = l - this.aY;
    c = n * t - i * e + this.aX, l = n * e + i * t + this.aY;
  }

  return n.set(c, l);
}, oa.prototype.copy = function (t) {
  return ra.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
}, oa.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
}, oa.prototype.fromJSON = function (t) {
  return ra.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
}, sa.prototype = Object.create(oa.prototype), sa.prototype.constructor = sa, sa.prototype.isArcCurve = !0;
const ca = new m(),
      la = new aa(),
      ua = new aa(),
      ha = new aa();

function da(t, e, n, i) {
  ra.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = i || .5;
}

function pa(t, e, n, i, r) {
  const o = .5 * (i - e),
        s = .5 * (r - n),
        a = t * t;
  return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n;
}

function fa(t, e, n, i) {
  return function (t, e) {
    const n = 1 - t;
    return n * n * e;
  }(t, e) + function (t, e) {
    return 2 * (1 - t) * t * e;
  }(t, n) + function (t, e) {
    return t * t * e;
  }(t, i);
}

function ma(t, e, n, i, r) {
  return function (t, e) {
    const n = 1 - t;
    return n * n * n * e;
  }(t, e) + function (t, e) {
    const n = 1 - t;
    return 3 * n * n * t * e;
  }(t, n) + function (t, e) {
    return 3 * (1 - t) * t * t * e;
  }(t, i) + function (t, e) {
    return t * t * t * e;
  }(t, r);
}

function ga(t, e, n, r) {
  ra.call(this), this.type = "CubicBezierCurve", this.v0 = t || new i(), this.v1 = e || new i(), this.v2 = n || new i(), this.v3 = r || new i();
}

function va(t, e, n, i) {
  ra.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new m(), this.v1 = e || new m(), this.v2 = n || new m(), this.v3 = i || new m();
}

function ya(t, e) {
  ra.call(this), this.type = "LineCurve", this.v1 = t || new i(), this.v2 = e || new i();
}

function xa(t, e) {
  ra.call(this), this.type = "LineCurve3", this.v1 = t || new m(), this.v2 = e || new m();
}

function _a(t, e, n) {
  ra.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new i(), this.v1 = e || new i(), this.v2 = n || new i();
}

function ba(t, e, n) {
  ra.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new m(), this.v1 = e || new m(), this.v2 = n || new m();
}

function wa(t) {
  ra.call(this), this.type = "SplineCurve", this.points = t || [];
}

da.prototype = Object.create(ra.prototype), da.prototype.constructor = da, da.prototype.isCatmullRomCurve3 = !0, da.prototype.getPoint = function (t, e) {
  const n = e || new m(),
        i = this.points,
        r = i.length,
        o = (r - (this.closed ? 0 : 1)) * t;
  let s,
      a,
      c,
      l,
      u = Math.floor(o),
      h = o - u;

  if (this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / r) + 1) * r : 0 === h && u === r - 1 && (u = r - 2, h = 1), this.closed || u > 0 ? s = i[(u - 1) % r] : (ca.subVectors(i[0], i[1]).add(i[0]), s = ca), a = i[u % r], c = i[(u + 1) % r], this.closed || u + 2 < r ? l = i[(u + 2) % r] : (ca.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), l = ca), "centripetal" === this.curveType || "chordal" === this.curveType) {
    const t = "chordal" === this.curveType ? .5 : .25;
    let e = Math.pow(s.distanceToSquared(a), t),
        n = Math.pow(a.distanceToSquared(c), t),
        i = Math.pow(c.distanceToSquared(l), t);
    n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), la.initNonuniformCatmullRom(s.x, a.x, c.x, l.x, e, n, i), ua.initNonuniformCatmullRom(s.y, a.y, c.y, l.y, e, n, i), ha.initNonuniformCatmullRom(s.z, a.z, c.z, l.z, e, n, i);
  } else "catmullrom" === this.curveType && (la.initCatmullRom(s.x, a.x, c.x, l.x, this.tension), ua.initCatmullRom(s.y, a.y, c.y, l.y, this.tension), ha.initCatmullRom(s.z, a.z, c.z, l.z, this.tension));

  return n.set(la.calc(h), ua.calc(h), ha.calc(h)), n;
}, da.prototype.copy = function (t) {
  ra.prototype.copy.call(this, t), this.points = [];

  for (let e = 0, n = t.points.length; e < n; e++) {
    const n = t.points[e];
    this.points.push(n.clone());
  }

  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
}, da.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  t.points = [];

  for (let e = 0, n = this.points.length; e < n; e++) {
    const n = this.points[e];
    t.points.push(n.toArray());
  }

  return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
}, da.prototype.fromJSON = function (t) {
  ra.prototype.fromJSON.call(this, t), this.points = [];

  for (let e = 0, n = t.points.length; e < n; e++) {
    const n = t.points[e];
    this.points.push(new m().fromArray(n));
  }

  return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
}, ga.prototype = Object.create(ra.prototype), ga.prototype.constructor = ga, ga.prototype.isCubicBezierCurve = !0, ga.prototype.getPoint = function (t, e) {
  const n = e || new i(),
        r = this.v0,
        o = this.v1,
        s = this.v2,
        a = this.v3;
  return n.set(ma(t, r.x, o.x, s.x, a.x), ma(t, r.y, o.y, s.y, a.y)), n;
}, ga.prototype.copy = function (t) {
  return ra.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
}, ga.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
}, ga.prototype.fromJSON = function (t) {
  return ra.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
}, va.prototype = Object.create(ra.prototype), va.prototype.constructor = va, va.prototype.isCubicBezierCurve3 = !0, va.prototype.getPoint = function (t, e) {
  const n = e || new m(),
        i = this.v0,
        r = this.v1,
        o = this.v2,
        s = this.v3;
  return n.set(ma(t, i.x, r.x, o.x, s.x), ma(t, i.y, r.y, o.y, s.y), ma(t, i.z, r.z, o.z, s.z)), n;
}, va.prototype.copy = function (t) {
  return ra.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
}, va.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
}, va.prototype.fromJSON = function (t) {
  return ra.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
}, ya.prototype = Object.create(ra.prototype), ya.prototype.constructor = ya, ya.prototype.isLineCurve = !0, ya.prototype.getPoint = function (t, e) {
  const n = e || new i();
  return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
}, ya.prototype.getPointAt = function (t, e) {
  return this.getPoint(t, e);
}, ya.prototype.getTangent = function (t, e) {
  const n = e || new i();
  return n.copy(this.v2).sub(this.v1).normalize(), n;
}, ya.prototype.copy = function (t) {
  return ra.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
}, ya.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
}, ya.prototype.fromJSON = function (t) {
  return ra.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
}, xa.prototype = Object.create(ra.prototype), xa.prototype.constructor = xa, xa.prototype.isLineCurve3 = !0, xa.prototype.getPoint = function (t, e) {
  const n = e || new m();
  return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
}, xa.prototype.getPointAt = function (t, e) {
  return this.getPoint(t, e);
}, xa.prototype.copy = function (t) {
  return ra.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
}, xa.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
}, xa.prototype.fromJSON = function (t) {
  return ra.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
}, _a.prototype = Object.create(ra.prototype), _a.prototype.constructor = _a, _a.prototype.isQuadraticBezierCurve = !0, _a.prototype.getPoint = function (t, e) {
  const n = e || new i(),
        r = this.v0,
        o = this.v1,
        s = this.v2;
  return n.set(fa(t, r.x, o.x, s.x), fa(t, r.y, o.y, s.y)), n;
}, _a.prototype.copy = function (t) {
  return ra.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
}, _a.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
}, _a.prototype.fromJSON = function (t) {
  return ra.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
}, ba.prototype = Object.create(ra.prototype), ba.prototype.constructor = ba, ba.prototype.isQuadraticBezierCurve3 = !0, ba.prototype.getPoint = function (t, e) {
  const n = e || new m(),
        i = this.v0,
        r = this.v1,
        o = this.v2;
  return n.set(fa(t, i.x, r.x, o.x), fa(t, i.y, r.y, o.y), fa(t, i.z, r.z, o.z)), n;
}, ba.prototype.copy = function (t) {
  return ra.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
}, ba.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
}, ba.prototype.fromJSON = function (t) {
  return ra.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
}, wa.prototype = Object.create(ra.prototype), wa.prototype.constructor = wa, wa.prototype.isSplineCurve = !0, wa.prototype.getPoint = function (t, e) {
  const n = e || new i(),
        r = this.points,
        o = (r.length - 1) * t,
        s = Math.floor(o),
        a = o - s,
        c = r[0 === s ? s : s - 1],
        l = r[s],
        u = r[s > r.length - 2 ? r.length - 1 : s + 1],
        h = r[s > r.length - 3 ? r.length - 1 : s + 2];
  return n.set(pa(a, c.x, l.x, u.x, h.x), pa(a, c.y, l.y, u.y, h.y)), n;
}, wa.prototype.copy = function (t) {
  ra.prototype.copy.call(this, t), this.points = [];

  for (let e = 0, n = t.points.length; e < n; e++) {
    const n = t.points[e];
    this.points.push(n.clone());
  }

  return this;
}, wa.prototype.toJSON = function () {
  const t = ra.prototype.toJSON.call(this);
  t.points = [];

  for (let e = 0, n = this.points.length; e < n; e++) {
    const n = this.points[e];
    t.points.push(n.toArray());
  }

  return t;
}, wa.prototype.fromJSON = function (t) {
  ra.prototype.fromJSON.call(this, t), this.points = [];

  for (let e = 0, n = t.points.length; e < n; e++) {
    const n = t.points[e];
    this.points.push(new i().fromArray(n));
  }

  return this;
};
var Ma = Object.freeze({
  __proto__: null,
  ArcCurve: sa,
  CatmullRomCurve3: da,
  CubicBezierCurve: ga,
  CubicBezierCurve3: va,
  EllipseCurve: oa,
  LineCurve: ya,
  LineCurve3: xa,
  QuadraticBezierCurve: _a,
  QuadraticBezierCurve3: ba,
  SplineCurve: wa
});

function Sa() {
  ra.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
}

function Ea(t) {
  Sa.call(this), this.type = "Path", this.currentPoint = new i(), t && this.setFromPoints(t);
}

function Ta(t) {
  Ea.call(this, t), this.uuid = n.generateUUID(), this.type = "Shape", this.holes = [];
}

function Aa(t, e) {
  U.call(this), this.type = "Light", this.color = new Ot(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0;
}

function La(t, e, n) {
  Aa.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(U.DefaultUp), this.updateMatrix(), this.groundColor = new Ot(e);
}

function Ca(t) {
  this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.mapPass = null, this.matrix = new M(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new We(), this._frameExtents = new i(1, 1), this._viewportCount = 1, this._viewports = [new l(0, 0, 1, 1)];
}

function Ra() {
  Ca.call(this, new He(50, 1, .5, 500));
}

function Pa(t, e, n, i, r, o) {
  Aa.call(this, t, e), this.type = "SpotLight", this.position.copy(U.DefaultUp), this.updateMatrix(), this.target = new U(), Object.defineProperty(this, "power", {
    get: function () {
      return this.intensity * Math.PI;
    },
    set: function (t) {
      this.intensity = t / Math.PI;
    }
  }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Ra();
}

function Oa() {
  Ca.call(this, new He(90, 1, .5, 500)), this._frameExtents = new i(4, 2), this._viewportCount = 6, this._viewports = [new l(2, 1, 1, 1), new l(0, 1, 1, 1), new l(3, 1, 1, 1), new l(1, 1, 1, 1), new l(3, 0, 1, 1), new l(1, 0, 1, 1)], this._cubeDirections = [new m(1, 0, 0), new m(-1, 0, 0), new m(0, 0, 1), new m(0, 0, -1), new m(0, 1, 0), new m(0, -1, 0)], this._cubeUps = [new m(0, 1, 0), new m(0, 1, 0), new m(0, 1, 0), new m(0, 1, 0), new m(0, 0, 1), new m(0, 0, -1)];
}

function Na(t, e, n, i) {
  Aa.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
    get: function () {
      return 4 * this.intensity * Math.PI;
    },
    set: function (t) {
      this.intensity = t / (4 * Math.PI);
    }
  }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Oa();
}

function Da(t, e, n, i, r, o) {
  ke.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix();
}

function Ia() {
  Ca.call(this, new Da(-5, 5, 5, -5, .5, 500));
}

function za(t, e) {
  Aa.call(this, t, e), this.type = "DirectionalLight", this.position.copy(U.DefaultUp), this.updateMatrix(), this.target = new U(), this.shadow = new Ia();
}

function Ba(t, e) {
  Aa.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0;
}

function ka(t, e, n, i) {
  Aa.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10;
}

function Ha() {
  this.coefficients = [];

  for (let t = 0; t < 9; t++) this.coefficients.push(new m());
}

function Fa(t, e) {
  Aa.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new Ha();
}

function Ua(t) {
  Zs.call(this, t), this.textures = {};
}

Sa.prototype = Object.assign(Object.create(ra.prototype), {
  constructor: Sa,
  add: function (t) {
    this.curves.push(t);
  },
  closePath: function () {
    const t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new ya(e, t));
  },
  getPoint: function (t) {
    const e = t * this.getLength(),
          n = this.getCurveLengths();
    let i = 0;

    for (; i < n.length;) {
      if (n[i] >= e) {
        const t = n[i] - e,
              r = this.curves[i],
              o = r.getLength(),
              s = 0 === o ? 0 : 1 - t / o;
        return r.getPointAt(s);
      }

      i++;
    }

    return null;
  },
  getLength: function () {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  },
  updateArcLengths: function () {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  },
  getCurveLengths: function () {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    const t = [];
    let e = 0;

    for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);

    return this.cacheLengths = t, t;
  },
  getSpacedPoints: function (t) {
    void 0 === t && (t = 40);
    const e = [];

    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));

    return this.autoClose && e.push(e[0]), e;
  },
  getPoints: function (t) {
    t = t || 12;
    const e = [];
    let n;

    for (let i = 0, r = this.curves; i < r.length; i++) {
      const o = r[i],
            s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
            a = o.getPoints(s);

      for (let t = 0; t < a.length; t++) {
        const i = a[t];
        n && n.equals(i) || (e.push(i), n = i);
      }
    }

    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  },
  copy: function (t) {
    ra.prototype.copy.call(this, t), this.curves = [];

    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e];
      this.curves.push(n.clone());
    }

    return this.autoClose = t.autoClose, this;
  },
  toJSON: function () {
    const t = ra.prototype.toJSON.call(this);
    t.autoClose = this.autoClose, t.curves = [];

    for (let e = 0, n = this.curves.length; e < n; e++) {
      const n = this.curves[e];
      t.curves.push(n.toJSON());
    }

    return t;
  },
  fromJSON: function (t) {
    ra.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];

    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e];
      this.curves.push(new Ma[n.type]().fromJSON(n));
    }

    return this;
  }
}), Ea.prototype = Object.assign(Object.create(Sa.prototype), {
  constructor: Ea,
  setFromPoints: function (t) {
    this.moveTo(t[0].x, t[0].y);

    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);

    return this;
  },
  moveTo: function (t, e) {
    return this.currentPoint.set(t, e), this;
  },
  lineTo: function (t, e) {
    const n = new ya(this.currentPoint.clone(), new i(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  },
  quadraticCurveTo: function (t, e, n, r) {
    const o = new _a(this.currentPoint.clone(), new i(t, e), new i(n, r));
    return this.curves.push(o), this.currentPoint.set(n, r), this;
  },
  bezierCurveTo: function (t, e, n, r, o, s) {
    const a = new ga(this.currentPoint.clone(), new i(t, e), new i(n, r), new i(o, s));
    return this.curves.push(a), this.currentPoint.set(o, s), this;
  },
  splineThru: function (t) {
    const e = new wa([this.currentPoint.clone()].concat(t));
    return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this;
  },
  arc: function (t, e, n, i, r, o) {
    const s = this.currentPoint.x,
          a = this.currentPoint.y;
    return this.absarc(t + s, e + a, n, i, r, o), this;
  },
  absarc: function (t, e, n, i, r, o) {
    return this.absellipse(t, e, n, n, i, r, o), this;
  },
  ellipse: function (t, e, n, i, r, o, s, a) {
    const c = this.currentPoint.x,
          l = this.currentPoint.y;
    return this.absellipse(t + c, e + l, n, i, r, o, s, a), this;
  },
  absellipse: function (t, e, n, i, r, o, s, a) {
    const c = new oa(t, e, n, i, r, o, s, a);

    if (this.curves.length > 0) {
      const t = c.getPoint(0);
      t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
    }

    this.curves.push(c);
    const l = c.getPoint(1);
    return this.currentPoint.copy(l), this;
  },
  copy: function (t) {
    return Sa.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this;
  },
  toJSON: function () {
    const t = Sa.prototype.toJSON.call(this);
    return t.currentPoint = this.currentPoint.toArray(), t;
  },
  fromJSON: function (t) {
    return Sa.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this;
  }
}), Ta.prototype = Object.assign(Object.create(Ea.prototype), {
  constructor: Ta,
  getPointsHoles: function (t) {
    const e = [];

    for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);

    return e;
  },
  extractPoints: function (t) {
    return {
      shape: this.getPoints(t),
      holes: this.getPointsHoles(t)
    };
  },
  copy: function (t) {
    Ea.prototype.copy.call(this, t), this.holes = [];

    for (let e = 0, n = t.holes.length; e < n; e++) {
      const n = t.holes[e];
      this.holes.push(n.clone());
    }

    return this;
  },
  toJSON: function () {
    const t = Ea.prototype.toJSON.call(this);
    t.uuid = this.uuid, t.holes = [];

    for (let e = 0, n = this.holes.length; e < n; e++) {
      const n = this.holes[e];
      t.holes.push(n.toJSON());
    }

    return t;
  },
  fromJSON: function (t) {
    Ea.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];

    for (let e = 0, n = t.holes.length; e < n; e++) {
      const n = t.holes[e];
      this.holes.push(new Ea().fromJSON(n));
    }

    return this;
  }
}), Aa.prototype = Object.assign(Object.create(U.prototype), {
  constructor: Aa,
  isLight: !0,
  copy: function (t) {
    return U.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this;
  },
  toJSON: function (t) {
    const e = U.prototype.toJSON.call(this, t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
  }
}), La.prototype = Object.assign(Object.create(Aa.prototype), {
  constructor: La,
  isHemisphereLight: !0,
  copy: function (t) {
    return Aa.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
  }
}), Object.assign(Ca.prototype, {
  _projScreenMatrix: new M(),
  _lightPositionWorld: new m(),
  _lookTarget: new m(),
  getViewportCount: function () {
    return this._viewportCount;
  },
  getFrustum: function () {
    return this._frustum;
  },
  updateMatrices: function (t) {
    const e = this.camera,
          n = this.matrix,
          i = this._projScreenMatrix,
          r = this._lookTarget,
          o = this._lightPositionWorld;
    o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
  },
  getViewport: function (t) {
    return this._viewports[t];
  },
  getFrameExtents: function () {
    return this._frameExtents;
  },
  copy: function (t) {
    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const t = {};
    return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
}), Ra.prototype = Object.assign(Object.create(Ca.prototype), {
  constructor: Ra,
  isSpotLightShadow: !0,
  updateMatrices: function (t) {
    const e = this.camera,
          i = 2 * n.RAD2DEG * t.angle,
          r = this.mapSize.width / this.mapSize.height,
          o = t.distance || e.far;
    i === e.fov && r === e.aspect && o === e.far || (e.fov = i, e.aspect = r, e.far = o, e.updateProjectionMatrix()), Ca.prototype.updateMatrices.call(this, t);
  }
}), Pa.prototype = Object.assign(Object.create(Aa.prototype), {
  constructor: Pa,
  isSpotLight: !0,
  copy: function (t) {
    return Aa.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
}), Oa.prototype = Object.assign(Object.create(Ca.prototype), {
  constructor: Oa,
  isPointLightShadow: !0,
  updateMatrices: function (t, e) {
    void 0 === e && (e = 0);
    const n = this.camera,
          i = this.matrix,
          r = this._lightPositionWorld,
          o = this._lookTarget,
          s = this._projScreenMatrix;
    r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s);
  }
}), Na.prototype = Object.assign(Object.create(Aa.prototype), {
  constructor: Na,
  isPointLight: !0,
  copy: function (t) {
    return Aa.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
  }
}), Da.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: Da,
  isOrthographicCamera: !0,
  copy: function (t, e) {
    return ke.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this;
  },
  setViewOffset: function (t, e, n, i, r, o) {
    null === this.view && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    const t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2;
    let r = n - t,
        o = n + t,
        s = i + e,
        a = i - e;

    if (null !== this.view && this.view.enabled) {
      const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += t * this.view.offsetX, o = r + t * this.view.width, s -= e * this.view.offsetY, a = s - e * this.view.height;
    }

    this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (t) {
    const e = U.prototype.toJSON.call(this, t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e;
  }
}), Ia.prototype = Object.assign(Object.create(Ca.prototype), {
  constructor: Ia,
  isDirectionalLightShadow: !0,
  updateMatrices: function (t) {
    Ca.prototype.updateMatrices.call(this, t);
  }
}), za.prototype = Object.assign(Object.create(Aa.prototype), {
  constructor: za,
  isDirectionalLight: !0,
  copy: function (t) {
    return Aa.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
}), Ba.prototype = Object.assign(Object.create(Aa.prototype), {
  constructor: Ba,
  isAmbientLight: !0
}), ka.prototype = Object.assign(Object.create(Aa.prototype), {
  constructor: ka,
  isRectAreaLight: !0,
  copy: function (t) {
    return Aa.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this;
  },
  toJSON: function (t) {
    const e = Aa.prototype.toJSON.call(this, t);
    return e.object.width = this.width, e.object.height = this.height, e;
  }
}), Object.assign(Ha.prototype, {
  isSphericalHarmonics3: !0,
  set: function (t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);

    return this;
  },
  zero: function () {
    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);

    return this;
  },
  getAt: function (t, e) {
    const n = t.x,
          i = t.y,
          r = t.z,
          o = this.coefficients;
    return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e;
  },
  getIrradianceAt: function (t, e) {
    const n = t.x,
          i = t.y,
          r = t.z,
          o = this.coefficients;
    return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e;
  },
  add: function (t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);

    return this;
  },
  addScaledSH: function (t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);

    return this;
  },
  scale: function (t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);

    return this;
  },
  lerp: function (t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);

    return this;
  },
  equals: function (t) {
    for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;

    return !0;
  },
  copy: function (t) {
    return this.set(t.coefficients);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  fromArray: function (t, e) {
    void 0 === e && (e = 0);
    const n = this.coefficients;

    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);

    return this;
  },
  toArray: function (t, e) {
    void 0 === t && (t = []), void 0 === e && (e = 0);
    const n = this.coefficients;

    for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);

    return t;
  }
}), Object.assign(Ha, {
  getBasisAt: function (t, e) {
    const n = t.x,
          i = t.y,
          r = t.z;
    e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i);
  }
}), Fa.prototype = Object.assign(Object.create(Aa.prototype), {
  constructor: Fa,
  isLightProbe: !0,
  copy: function (t) {
    return Aa.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
  },
  fromJSON: function (t) {
    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
  },
  toJSON: function (t) {
    const e = Aa.prototype.toJSON.call(this, t);
    return e.object.sh = this.sh.toArray(), e;
  }
}), Ua.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: Ua,
  load: function (t, e, n, i) {
    const r = this,
          o = new Qs(r.manager);
    o.setPath(r.path), o.load(t, function (n) {
      try {
        e(r.parse(JSON.parse(n)));
      } catch (e) {
        i ? i(e) : console.error(e), r.manager.itemError(t);
      }
    }, n, i);
  },
  parse: function (t) {
    const e = this.textures;

    function n(t) {
      return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t];
    }

    const o = new Rs[t.type]();
    if (void 0 !== t.uuid && (o.uuid = t.uuid), void 0 !== t.name && (o.name = t.name), void 0 !== t.color && o.color.setHex(t.color), void 0 !== t.roughness && (o.roughness = t.roughness), void 0 !== t.metalness && (o.metalness = t.metalness), void 0 !== t.sheen && (o.sheen = new Ot().setHex(t.sheen)), void 0 !== t.emissive && o.emissive.setHex(t.emissive), void 0 !== t.specular && o.specular.setHex(t.specular), void 0 !== t.shininess && (o.shininess = t.shininess), void 0 !== t.clearcoat && (o.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (o.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (o.fog = t.fog), void 0 !== t.flatShading && (o.flatShading = t.flatShading), void 0 !== t.blending && (o.blending = t.blending), void 0 !== t.combine && (o.combine = t.combine), void 0 !== t.side && (o.side = t.side), void 0 !== t.opacity && (o.opacity = t.opacity), void 0 !== t.transparent && (o.transparent = t.transparent), void 0 !== t.alphaTest && (o.alphaTest = t.alphaTest), void 0 !== t.depthTest && (o.depthTest = t.depthTest), void 0 !== t.depthWrite && (o.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (o.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (o.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (o.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (o.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (o.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (o.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (o.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (o.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (o.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (o.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (o.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (o.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (o.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (o.rotation = t.rotation), 1 !== t.linewidth && (o.linewidth = t.linewidth), void 0 !== t.dashSize && (o.dashSize = t.dashSize), void 0 !== t.gapSize && (o.gapSize = t.gapSize), void 0 !== t.scale && (o.scale = t.scale), void 0 !== t.polygonOffset && (o.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (o.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (o.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (o.skinning = t.skinning), void 0 !== t.morphTargets && (o.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (o.morphNormals = t.morphNormals), void 0 !== t.dithering && (o.dithering = t.dithering), void 0 !== t.vertexTangents && (o.vertexTangents = t.vertexTangents), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.toneMapped && (o.toneMapped = t.toneMapped), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? o.vertexColors = t.vertexColors > 0 : o.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (const e in t.uniforms) {
      const s = t.uniforms[e];

      switch (o.uniforms[e] = {}, s.type) {
        case "t":
          o.uniforms[e].value = n(s.value);
          break;

        case "c":
          o.uniforms[e].value = new Ot().setHex(s.value);
          break;

        case "v2":
          o.uniforms[e].value = new i().fromArray(s.value);
          break;

        case "v3":
          o.uniforms[e].value = new m().fromArray(s.value);
          break;

        case "v4":
          o.uniforms[e].value = new l().fromArray(s.value);
          break;

        case "m3":
          o.uniforms[e].value = new r().fromArray(s.value);

        case "m4":
          o.uniforms[e].value = new M().fromArray(s.value);
          break;

        default:
          o.uniforms[e].value = s.value;
      }
    }
    if (void 0 !== t.defines && (o.defines = t.defines), void 0 !== t.vertexShader && (o.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (o.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (const e in t.extensions) o.extensions[e] = t.extensions[e];

    if (void 0 !== t.shading && (o.flatShading = 1 === t.shading), void 0 !== t.size && (o.size = t.size), void 0 !== t.sizeAttenuation && (o.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (o.map = n(t.map)), void 0 !== t.matcap && (o.matcap = n(t.matcap)), void 0 !== t.alphaMap && (o.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (o.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (o.bumpScale = t.bumpScale), void 0 !== t.normalMap && (o.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (o.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
      let e = t.normalScale;
      !1 === Array.isArray(e) && (e = [e, e]), o.normalScale = new i().fromArray(e);
    }

    return void 0 !== t.displacementMap && (o.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (o.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (o.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (o.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (o.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (o.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (o.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (o.specularMap = n(t.specularMap)), void 0 !== t.envMap && (o.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (o.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (o.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (o.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (o.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (o.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (o.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (o.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (o.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (o.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (o.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (o.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (o.clearcoatNormalScale = new i().fromArray(t.clearcoatNormalScale)), o;
  },
  setTextures: function (t) {
    return this.textures = t, this;
  }
});

const Ga = function (t) {
  const e = t.lastIndexOf("/");
  return -1 === e ? "./" : t.substr(0, e + 1);
};

function ja() {
  ae.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
}

function Va(t, e, n, i) {
  "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Gt.call(this, t, e, n), this.meshPerAttribute = i || 1;
}

function Wa(t) {
  Zs.call(this, t);
}

ja.prototype = Object.assign(Object.create(ae.prototype), {
  constructor: ja,
  isInstancedBufferGeometry: !0,
  copy: function (t) {
    return ae.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const t = ae.prototype.toJSON.call(this);
    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
  }
}), Va.prototype = Object.assign(Object.create(Gt.prototype), {
  constructor: Va,
  isInstancedBufferAttribute: !0,
  copy: function (t) {
    return Gt.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  toJSON: function () {
    const t = Gt.prototype.toJSON.call(this);
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
  }
}), Wa.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: Wa,
  load: function (t, e, n, i) {
    const r = this,
          o = new Qs(r.manager);
    o.setPath(r.path), o.load(t, function (n) {
      try {
        e(r.parse(JSON.parse(n)));
      } catch (e) {
        i ? i(e) : console.error(e), r.manager.itemError(t);
      }
    }, n, i);
  },
  parse: function (t) {
    const e = {},
          n = {};

    function i(t, i) {
      if (void 0 !== e[i]) return e[i];

      const r = t.interleavedBuffers[i],
            o = function (t, e) {
        if (void 0 !== n[e]) return n[e];
        const i = t.arrayBuffers[e],
              r = new Uint32Array(i).buffer;
        return n[e] = r, r;
      }(t, r.buffer),
            s = new rr(new qa[r.type](o), r.stride);

      return s.uuid = r.uuid, e[i] = s, s;
    }

    const r = t.isInstancedBufferGeometry ? new ja() : new ae(),
          o = t.data.index;

    if (void 0 !== o) {
      const t = new qa[o.type](o.array);
      r.setIndex(new Gt(t, 1));
    }

    const s = t.data.attributes;

    for (const e in s) {
      const n = s[e];
      let o;
      if (n.isInterleavedBufferAttribute) o = new sr(i(t.data, n.data), n.itemSize, n.offset, n.normalized);else {
        const t = new qa[n.type](n.array);
        o = new (n.isInstancedBufferAttribute ? Va : Gt)(t, n.itemSize, n.normalized);
      }
      void 0 !== n.name && (o.name = n.name), r.setAttribute(e, o);
    }

    const a = t.data.morphAttributes;
    if (a) for (const e in a) {
      const n = a[e],
            o = [];

      for (let e = 0, r = n.length; e < r; e++) {
        const r = n[e];
        let s;
        s = r.isInterleavedBufferAttribute ? new sr(i(t.data, r.data), r.itemSize, r.offset, r.normalized) : new Gt(new qa[r.type](r.array), r.itemSize, r.normalized), void 0 !== r.name && (s.name = r.name), o.push(s);
      }

      r.morphAttributes[e] = o;
    }
    t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
    const c = t.data.groups || t.data.drawcalls || t.data.offsets;
    if (void 0 !== c) for (let t = 0, e = c.length; t !== e; ++t) {
      const e = c[t];
      r.addGroup(e.start, e.count, e.materialIndex);
    }
    const l = t.data.boundingSphere;

    if (void 0 !== l) {
      const t = new m();
      void 0 !== l.center && t.fromArray(l.center), r.boundingSphere = new ot(t, l.radius);
    }

    return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r;
  }
});
const qa = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function Xa(t) {
  Zs.call(this, t);
}

Xa.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: Xa,
  load: function (t, e, n, i) {
    const r = this,
          o = "" === this.path ? Ga(t) : this.path;
    this.resourcePath = this.resourcePath || o;
    const s = new Qs(r.manager);
    s.setPath(this.path), s.load(t, function (n) {
      let o = null;

      try {
        o = JSON.parse(n);
      } catch (e) {
        return void 0 !== i && i(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message);
      }

      const s = o.metadata;
      void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t);
    }, n, i);
  },
  parse: function (t, e) {
    const n = this.parseShape(t.shapes),
          i = this.parseGeometries(t.geometries, n),
          r = this.parseImages(t.images, function () {
      void 0 !== e && e(a);
    }),
          o = this.parseTextures(t.textures, r),
          s = this.parseMaterials(t.materials, o),
          a = this.parseObject(t.object, i, s);
    return t.animations && (a.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(a), a;
  },
  parseShape: function (t) {
    const e = {};
    if (void 0 !== t) for (let n = 0, i = t.length; n < i; n++) {
      const i = new Ta().fromJSON(t[n]);
      e[i.uuid] = i;
    }
    return e;
  },
  parseGeometries: function (t, e) {
    const n = {};
    let i;

    if (void 0 !== t) {
      const r = new Wa();

      for (let o = 0, s = t.length; o < s; o++) {
        let s;
        const a = t[o];

        switch (a.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            s = new xs[a.type](a.width, a.height, a.widthSegments, a.heightSegments);
            break;

          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            s = new xs[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
            break;

          case "CircleGeometry":
          case "CircleBufferGeometry":
            s = new xs[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength);
            break;

          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            s = new xs[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
            break;

          case "ConeGeometry":
          case "ConeBufferGeometry":
            s = new xs[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
            break;

          case "SphereGeometry":
          case "SphereBufferGeometry":
            s = new xs[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
            break;

          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            s = new xs[a.type](a.radius, a.detail);
            break;

          case "RingGeometry":
          case "RingBufferGeometry":
            s = new xs[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength);
            break;

          case "TorusGeometry":
          case "TorusBufferGeometry":
            s = new xs[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
            break;

          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            s = new xs[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q);
            break;

          case "TubeGeometry":
          case "TubeBufferGeometry":
            s = new xs[a.type](new Ma[a.path.type]().fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed);
            break;

          case "LatheGeometry":
          case "LatheBufferGeometry":
            s = new xs[a.type](a.points, a.segments, a.phiStart, a.phiLength);
            break;

          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            s = new xs[a.type](a.vertices, a.indices, a.radius, a.details);
            break;

          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            i = [];

            for (let t = 0, n = a.shapes.length; t < n; t++) {
              const n = e[a.shapes[t]];
              i.push(n);
            }

            s = new xs[a.type](i, a.curveSegments);
            break;

          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            i = [];

            for (let t = 0, n = a.shapes.length; t < n; t++) {
              const n = e[a.shapes[t]];
              i.push(n);
            }

            const t = a.options.extrudePath;
            void 0 !== t && (a.options.extrudePath = new Ma[t.type]().fromJSON(t)), s = new xs[a.type](i, a.options);
            break;

          case "BufferGeometry":
          case "InstancedBufferGeometry":
            s = r.parse(a);
            break;

          case "Geometry":
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;

          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"');
            continue;
        }

        s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), n[a.uuid] = s;
      }
    }

    return n;
  },
  parseMaterials: function (t, e) {
    const n = {},
          i = {};

    if (void 0 !== t) {
      const r = new Ua();
      r.setTextures(e);

      for (let e = 0, o = t.length; e < o; e++) {
        const o = t[e];

        if ("MultiMaterial" === o.type) {
          const t = [];

          for (let e = 0; e < o.materials.length; e++) {
            const i = o.materials[e];
            void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid]);
          }

          i[o.uuid] = t;
        } else void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)), i[o.uuid] = n[o.uuid];
      }
    }

    return i;
  },
  parseAnimations: function (t) {
    const e = [];

    for (let n = 0; n < t.length; n++) {
      const i = t[n],
            r = Vs.parse(i);
      void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
    }

    return e;
  },
  parseImages: function (t, e) {
    const n = this,
          i = {};
    let r;

    function o(t) {
      return n.manager.itemStart(t), r.load(t, function () {
        n.manager.itemEnd(t);
      }, void 0, function () {
        n.manager.itemError(t), n.manager.itemEnd(t);
      });
    }

    if (void 0 !== t && t.length > 0) {
      const s = new Xs(e);
      r = new ea(s), r.setCrossOrigin(this.crossOrigin);

      for (let e = 0, r = t.length; e < r; e++) {
        const r = t[e],
              s = r.url;

        if (Array.isArray(s)) {
          i[r.uuid] = [];

          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t],
                  a = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e;
            i[r.uuid].push(o(a));
          }
        } else {
          const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url) ? r.url : n.resourcePath + r.url;
          i[r.uuid] = o(t);
        }
      }
    }

    return i;
  },
  parseTextures: function (t, e) {
    function n(t, e) {
      return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]);
    }

    const i = {};
    if (void 0 !== t) for (let r = 0, o = t.length; r < o; r++) {
      const o = t[r];
      let s;
      void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image), s = Array.isArray(e[o.image]) ? new pn(e[o.image]) : new c(e[o.image]), s.needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = n(o.mapping, Ya)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = n(o.wrap[0], Za), s.wrapT = n(o.wrap[1], Za)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, Ja)), void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, Ja)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), i[o.uuid] = s;
    }
    return i;
  },
  parseObject: function (t, e, n) {
    let i, r, o;

    function s(t) {
      return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t];
    }

    function a(t) {
      if (void 0 !== t) {
        if (Array.isArray(t)) {
          const e = [];

          for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i];
            void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), e.push(n[r]);
          }

          return e;
        }

        return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t];
      }
    }

    switch (t.type) {
      case "Scene":
        i = new G(), void 0 !== t.background && Number.isInteger(t.background) && (i.background = new Ot(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new ir(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new nr(t.fog.color, t.fog.density)));
        break;

      case "PerspectiveCamera":
        i = new He(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
        break;

      case "OrthographicCamera":
        i = new Da(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
        break;

      case "AmbientLight":
        i = new Ba(t.color, t.intensity);
        break;

      case "DirectionalLight":
        i = new za(t.color, t.intensity);
        break;

      case "PointLight":
        i = new Na(t.color, t.intensity, t.distance, t.decay);
        break;

      case "RectAreaLight":
        i = new ka(t.color, t.intensity, t.width, t.height);
        break;

      case "SpotLight":
        i = new Pa(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
        break;

      case "HemisphereLight":
        i = new La(t.color, t.groundColor, t.intensity);
        break;

      case "LightProbe":
        i = new Fa().fromJSON(t);
        break;

      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");

      case "Mesh":
        r = s(t.geometry), o = a(t.material), i = new Ee(r, o);
        break;

      case "InstancedMesh":
        r = s(t.geometry), o = a(t.material);
        const e = t.count,
              n = t.instanceMatrix;
        i = new Ir(r, o, e), i.instanceMatrix = new Gt(new Float32Array(n.array), 16);
        break;

      case "LOD":
        i = new Er();
        break;

      case "Line":
        i = new Gr(s(t.geometry), a(t.material), t.mode);
        break;

      case "LineLoop":
        i = new qr(s(t.geometry), a(t.material));
        break;

      case "LineSegments":
        i = new Wr(s(t.geometry), a(t.material));
        break;

      case "PointCloud":
      case "Points":
        i = new Kr(s(t.geometry), a(t.material));
        break;

      case "Sprite":
        i = new br(a(t.material));
        break;

      case "Group":
        i = new Ji();
        break;

      default:
        i = new U();
    }

    if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (i.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children) {
      const r = t.children;

      for (let t = 0; t < r.length; t++) i.add(this.parseObject(r[t], e, n));
    }

    if ("LOD" === t.type) {
      void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
      const e = t.levels;

      for (let t = 0; t < e.length; t++) {
        const n = e[t],
              r = i.getObjectByProperty("uuid", n.object);
        void 0 !== r && i.addLevel(r, n.distance);
      }
    }

    return i;
  }
});
const Ya = {
  UVMapping: 300,
  CubeReflectionMapping: 301,
  CubeRefractionMapping: 302,
  EquirectangularReflectionMapping: 303,
  EquirectangularRefractionMapping: 304,
  CubeUVReflectionMapping: 306,
  CubeUVRefractionMapping: 307
},
      Za = {
  RepeatWrapping: 1e3,
  ClampToEdgeWrapping: 1001,
  MirroredRepeatWrapping: 1002
},
      Ja = {
  NearestFilter: 1003,
  NearestMipmapNearestFilter: 1004,
  NearestMipmapLinearFilter: 1005,
  LinearFilter: 1006,
  LinearMipmapNearestFilter: 1007,
  LinearMipmapLinearFilter: 1008
};

function Qa(t) {
  "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Zs.call(this, t), this.options = {
    premultiplyAlpha: "none"
  };
}

function Ka() {
  this.type = "ShapePath", this.color = new Ot(), this.subPaths = [], this.currentPath = null;
}

function $a(t) {
  this.type = "Font", this.data = t;
}

function tc(t, e, n, i, r) {
  const o = r.glyphs[t] || r.glyphs["?"];
  if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
  const s = new Ka();
  let a, c, l, u, h, d, p, f;

  if (o.o) {
    const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));

    for (let r = 0, o = t.length; r < o;) switch (t[r++]) {
      case "m":
        a = t[r++] * e + n, c = t[r++] * e + i, s.moveTo(a, c);
        break;

      case "l":
        a = t[r++] * e + n, c = t[r++] * e + i, s.lineTo(a, c);
        break;

      case "q":
        l = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, s.quadraticCurveTo(h, d, l, u);
        break;

      case "b":
        l = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, p = t[r++] * e + n, f = t[r++] * e + i, s.bezierCurveTo(h, d, p, f, l, u);
    }
  }

  return {
    offsetX: o.ha * e,
    path: s
  };
}

function ec(t) {
  Zs.call(this, t);
}

let nc;
Qa.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: Qa,
  isImageBitmapLoader: !0,
  setOptions: function (t) {
    return this.options = t, this;
  },
  load: function (t, e, n, i) {
    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
    const r = this,
          o = qs.get(t);
    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () {
      e && e(o), r.manager.itemEnd(t);
    }, 0), o;
    fetch(t).then(function (t) {
      return t.blob();
    }).then(function (t) {
      return createImageBitmap(t, r.options);
    }).then(function (n) {
      qs.add(t, n), e && e(n), r.manager.itemEnd(t);
    }).catch(function (e) {
      i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
    }), r.manager.itemStart(t);
  }
}), Object.assign(Ka.prototype, {
  moveTo: function (t, e) {
    return this.currentPath = new Ea(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
  },
  lineTo: function (t, e) {
    return this.currentPath.lineTo(t, e), this;
  },
  quadraticCurveTo: function (t, e, n, i) {
    return this.currentPath.quadraticCurveTo(t, e, n, i), this;
  },
  bezierCurveTo: function (t, e, n, i, r, o) {
    return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this;
  },
  splineThru: function (t) {
    return this.currentPath.splineThru(t), this;
  },
  toShapes: function (t, e) {
    function n(t) {
      const e = [];

      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n],
              r = new Ta();
        r.curves = i.curves, e.push(r);
      }

      return e;
    }

    function i(t, e) {
      const n = e.length;
      let i = !1;

      for (let r = n - 1, o = 0; o < n; r = o++) {
        let n = e[r],
            s = e[o],
            a = s.x - n.x,
            c = s.y - n.y;

        if (Math.abs(c) > Number.EPSILON) {
          if (c < 0 && (n = e[o], a = -a, s = e[r], c = -c), t.y < n.y || t.y > s.y) continue;

          if (t.y === n.y) {
            if (t.x === n.x) return !0;
          } else {
            const e = c * (t.x - n.x) - a * (t.y - n.y);
            if (0 === e) return !0;
            if (e < 0) continue;
            i = !i;
          }
        } else {
          if (t.y !== n.y) continue;
          if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x) return !0;
        }
      }

      return i;
    }

    const r = Yo.isClockWise,
          o = this.subPaths;
    if (0 === o.length) return [];
    if (!0 === e) return n(o);
    let s,
        a,
        c,
        l = [];
    if (1 === o.length) return a = o[0], c = new Ta(), c.curves = a.curves, l.push(c), l;
    let u = !r(o[0].getPoints());
    u = t ? !u : u;
    const h = [],
          d = [];
    let p,
        f,
        m = [],
        g = 0;
    d[g] = void 0, m[g] = [];

    for (let e = 0, n = o.length; e < n; e++) a = o[e], p = a.getPoints(), s = r(p), s = t ? !s : s, s ? (!u && d[g] && g++, d[g] = {
      s: new Ta(),
      p: p
    }, d[g].s.curves = a.curves, u && g++, m[g] = []) : m[g].push({
      h: a,
      p: p[0]
    });

    if (!d[0]) return n(o);

    if (d.length > 1) {
      let t = !1;
      const e = [];

      for (let t = 0, e = d.length; t < e; t++) h[t] = [];

      for (let n = 0, r = d.length; n < r; n++) {
        const r = m[n];

        for (let o = 0; o < r.length; o++) {
          const s = r[o];
          let a = !0;

          for (let r = 0; r < d.length; r++) i(s.p, d[r].p) && (n !== r && e.push({
            froms: n,
            tos: r,
            hole: o
          }), a ? (a = !1, h[r].push(s)) : t = !0);

          a && h[n].push(s);
        }
      }

      e.length > 0 && (t || (m = h));
    }

    for (let t = 0, e = d.length; t < e; t++) {
      c = d[t].s, l.push(c), f = m[t];

      for (let t = 0, e = f.length; t < e; t++) c.holes.push(f[t].h);
    }

    return l;
  }
}), Object.assign($a.prototype, {
  isFont: !0,
  generateShapes: function (t, e) {
    void 0 === e && (e = 100);

    const n = [],
          i = function (t, e, n) {
      const i = Array.from ? Array.from(t) : String(t).split(""),
            r = e / n.resolution,
            o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
            s = [];
      let a = 0,
          c = 0;

      for (let t = 0; t < i.length; t++) {
        const e = i[t];
        if ("\n" === e) a = 0, c -= o;else {
          const t = tc(e, r, a, c, n);
          a += t.offsetX, s.push(t.path);
        }
      }

      return s;
    }(t, e, this.data);

    for (let t = 0, e = i.length; t < e; t++) Array.prototype.push.apply(n, i[t].toShapes());

    return n;
  }
}), ec.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: ec,
  load: function (t, e, n, i) {
    const r = this,
          o = new Qs(this.manager);
    o.setPath(this.path), o.load(t, function (t) {
      let n;

      try {
        n = JSON.parse(t);
      } catch (e) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2));
      }

      const i = r.parse(n);
      e && e(i);
    }, n, i);
  },
  parse: function (t) {
    return new $a(t);
  }
});

const ic = function () {
  return void 0 === nc && (nc = new (window.AudioContext || window.webkitAudioContext)()), nc;
};

function rc(t) {
  Zs.call(this, t);
}

function oc(t, e, n) {
  Fa.call(this, void 0, n);
  const i = new Ot().set(t),
        r = new Ot().set(e),
        o = new m(i.r, i.g, i.b),
        s = new m(r.r, r.g, r.b),
        a = Math.sqrt(Math.PI),
        c = a * Math.sqrt(.75);
  this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c);
}

function sc(t, e) {
  Fa.call(this, void 0, e);
  const n = new Ot().set(t);
  this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}

rc.prototype = Object.assign(Object.create(Zs.prototype), {
  constructor: rc,
  load: function (t, e, n, i) {
    const r = this,
          o = new Qs(r.manager);
    o.setResponseType("arraybuffer"), o.setPath(r.path), o.load(t, function (n) {
      try {
        const t = n.slice(0);
        ic().decodeAudioData(t, function (t) {
          e(t);
        });
      } catch (e) {
        i ? i(e) : console.error(e), r.manager.itemError(t);
      }
    }, n, i);
  }
}), oc.prototype = Object.assign(Object.create(Fa.prototype), {
  constructor: oc,
  isHemisphereLightProbe: !0,
  copy: function (t) {
    return Fa.prototype.copy.call(this, t), this;
  },
  toJSON: function (t) {
    return Fa.prototype.toJSON.call(this, t);
  }
}), sc.prototype = Object.assign(Object.create(Fa.prototype), {
  constructor: sc,
  isAmbientLightProbe: !0,
  copy: function (t) {
    return Fa.prototype.copy.call(this, t), this;
  },
  toJSON: function (t) {
    return Fa.prototype.toJSON.call(this, t);
  }
});
const ac = new M(),
      cc = new M();

function lc(t) {
  this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
}

Object.assign(function () {
  this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new He(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new He(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}.prototype, {
  update: function (t) {
    const e = this._cache;

    if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
      e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
      const i = t.projectionMatrix.clone(),
            r = e.eyeSep / 2,
            o = r * e.near / e.focus,
            s = e.near * Math.tan(n.DEG2RAD * e.fov * .5) / e.zoom;
      let a, c;
      cc.elements[12] = -r, ac.elements[12] = r, a = -s * e.aspect + o, c = s * e.aspect + o, i.elements[0] = 2 * e.near / (c - a), i.elements[8] = (c + a) / (c - a), this.cameraL.projectionMatrix.copy(i), a = -s * e.aspect - o, c = s * e.aspect - o, i.elements[0] = 2 * e.near / (c - a), i.elements[8] = (c + a) / (c - a), this.cameraR.projectionMatrix.copy(i);
    }

    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(cc), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(ac);
  }
}), Object.assign(lc.prototype, {
  start: function () {
    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  },
  stop: function () {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  },
  getElapsedTime: function () {
    return this.getDelta(), this.elapsedTime;
  },
  getDelta: function () {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;

    if (this.running) {
      const e = ("undefined" == typeof performance ? Date : performance).now();
      t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
    }

    return t;
  }
});
const uc = new m(),
      hc = new d(),
      dc = new m(),
      pc = new m();

function fc() {
  U.call(this), this.type = "AudioListener", this.context = ic(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new lc();
}

function mc(t) {
  U.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this.filters = [];
}

fc.prototype = Object.assign(Object.create(U.prototype), {
  constructor: fc,
  getInput: function () {
    return this.gain;
  },
  removeFilter: function () {
    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  },
  getFilter: function () {
    return this.filter;
  },
  setFilter: function (t) {
    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  },
  getMasterVolume: function () {
    return this.gain.gain.value;
  },
  setMasterVolume: function (t) {
    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this;
  },
  updateMatrixWorld: function (t) {
    U.prototype.updateMatrixWorld.call(this, t);
    const e = this.context.listener,
          n = this.up;

    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(uc, hc, dc), pc.set(0, 0, -1).applyQuaternion(hc), e.positionX) {
      const t = this.context.currentTime + this.timeDelta;
      e.positionX.linearRampToValueAtTime(uc.x, t), e.positionY.linearRampToValueAtTime(uc.y, t), e.positionZ.linearRampToValueAtTime(uc.z, t), e.forwardX.linearRampToValueAtTime(pc.x, t), e.forwardY.linearRampToValueAtTime(pc.y, t), e.forwardZ.linearRampToValueAtTime(pc.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t);
    } else e.setPosition(uc.x, uc.y, uc.z), e.setOrientation(pc.x, pc.y, pc.z, n.x, n.y, n.z);
  }
}), mc.prototype = Object.assign(Object.create(U.prototype), {
  constructor: mc,
  getOutput: function () {
    return this.gain;
  },
  setNodeSource: function (t) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
  },
  setMediaElementSource: function (t) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
  },
  setMediaStreamSource: function (t) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
  },
  setBuffer: function (t) {
    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
  },
  play: function (t) {
    if (void 0 === t && (t = 0), !0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
    this._startedAt = this.context.currentTime + t;
    const e = this.context.createBufferSource();
    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  },
  pause: function () {
    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  },
  stop: function () {
    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  },
  connect: function () {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);

      for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);

      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());

    return this;
  },
  disconnect: function () {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);

      for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);

      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());

    return this;
  },
  getFilters: function () {
    return this.filters;
  },
  setFilters: function (t) {
    return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this;
  },
  setDetune: function (t) {
    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
  },
  getDetune: function () {
    return this.detune;
  },
  getFilter: function () {
    return this.getFilters()[0];
  },
  setFilter: function (t) {
    return this.setFilters(t ? [t] : []);
  },
  setPlaybackRate: function (t) {
    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  },
  getPlaybackRate: function () {
    return this.playbackRate;
  },
  onEnded: function () {
    this.isPlaying = !1;
  },
  getLoop: function () {
    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  },
  setLoop: function (t) {
    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  },
  setLoopStart: function (t) {
    return this.loopStart = t, this;
  },
  setLoopEnd: function (t) {
    return this.loopEnd = t, this;
  },
  getVolume: function () {
    return this.gain.gain.value;
  },
  setVolume: function (t) {
    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this;
  }
});
const gc = new m(),
      vc = new d(),
      yc = new m(),
      xc = new m();

function _c(t) {
  mc.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
}

function bc(t, e) {
  this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
}

function wc(t, e, n) {
  let i, r, o;

  switch (this.binding = t, this.valueSize = n, e) {
    case "quaternion":
      i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
      break;

    case "string":
    case "bool":
      i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
      break;

    default:
      i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n);
  }

  this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
}

_c.prototype = Object.assign(Object.create(mc.prototype), {
  constructor: _c,
  getOutput: function () {
    return this.panner;
  },
  getRefDistance: function () {
    return this.panner.refDistance;
  },
  setRefDistance: function (t) {
    return this.panner.refDistance = t, this;
  },
  getRolloffFactor: function () {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function (t) {
    return this.panner.rolloffFactor = t, this;
  },
  getDistanceModel: function () {
    return this.panner.distanceModel;
  },
  setDistanceModel: function (t) {
    return this.panner.distanceModel = t, this;
  },
  getMaxDistance: function () {
    return this.panner.maxDistance;
  },
  setMaxDistance: function (t) {
    return this.panner.maxDistance = t, this;
  },
  setDirectionalCone: function (t, e, n) {
    return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this;
  },
  updateMatrixWorld: function (t) {
    if (U.prototype.updateMatrixWorld.call(this, t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
    this.matrixWorld.decompose(gc, vc, yc), xc.set(0, 0, 1).applyQuaternion(vc);
    const e = this.panner;

    if (e.positionX) {
      const t = this.context.currentTime + this.listener.timeDelta;
      e.positionX.linearRampToValueAtTime(gc.x, t), e.positionY.linearRampToValueAtTime(gc.y, t), e.positionZ.linearRampToValueAtTime(gc.z, t), e.orientationX.linearRampToValueAtTime(xc.x, t), e.orientationY.linearRampToValueAtTime(xc.y, t), e.orientationZ.linearRampToValueAtTime(xc.z, t);
    } else e.setPosition(gc.x, gc.y, gc.z), e.setOrientation(xc.x, xc.y, xc.z);
  }
}), Object.assign(bc.prototype, {
  getFrequencyData: function () {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  },
  getAverageFrequency: function () {
    let t = 0;
    const e = this.getFrequencyData();

    for (let n = 0; n < e.length; n++) t += e[n];

    return t / e.length;
  }
}), Object.assign(wc.prototype, {
  accumulate: function (t, e) {
    const n = this.buffer,
          i = this.valueSize,
          r = t * i + i;
    let o = this.cumulativeWeight;

    if (0 === o) {
      for (let t = 0; t !== i; ++t) n[r + t] = n[t];

      o = e;
    } else {
      o += e;
      const t = e / o;

      this._mixBufferRegion(n, r, 0, t, i);
    }

    this.cumulativeWeight = o;
  },
  accumulateAdditive: function (t) {
    const e = this.buffer,
          n = this.valueSize,
          i = n * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t;
  },
  apply: function (t) {
    const e = this.valueSize,
          n = this.buffer,
          i = t * e + e,
          r = this.cumulativeWeight,
          o = this.cumulativeWeightAdditive,
          s = this.binding;

    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const t = e * this._origIndex;

      this._mixBufferRegion(n, i, t, 1 - r, e);
    }

    o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);

    for (let t = e, r = e + e; t !== r; ++t) if (n[t] !== n[t + e]) {
      s.setValue(n, i);
      break;
    }
  },
  saveOriginalState: function () {
    const t = this.binding,
          e = this.buffer,
          n = this.valueSize,
          i = n * this._origIndex;
    t.getValue(e, i);

    for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];

    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  },
  restoreOriginalState: function () {
    const t = 3 * this.valueSize;
    this.binding.setValue(this.buffer, t);
  },
  _setAdditiveIdentityNumeric: function () {
    const t = this._addIndex * this.valueSize,
          e = t + this.valueSize;

    for (let n = t; n < e; n++) this.buffer[n] = 0;
  },
  _setAdditiveIdentityQuaternion: function () {
    this._setAdditiveIdentityNumeric(), this.buffer[4 * this._addIndex + 3] = 1;
  },
  _setAdditiveIdentityOther: function () {
    const t = this._origIndex * this.valueSize,
          e = this._addIndex * this.valueSize;

    for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n];
  },
  _select: function (t, e, n, i, r) {
    if (i >= .5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
  },
  _slerp: function (t, e, n, i) {
    d.slerpFlat(t, e, t, e, t, n, i);
  },
  _slerpAdditive: function (t, e, n, i, r) {
    const o = this._workIndex * r;
    d.multiplyQuaternionsFlat(t, o, t, e, t, n), d.slerpFlat(t, e, t, e, t, o, i);
  },
  _lerp: function (t, e, n, i, r) {
    const o = 1 - i;

    for (let s = 0; s !== r; ++s) {
      const r = e + s;
      t[r] = t[r] * o + t[n + s] * i;
    }
  },
  _lerpAdditive: function (t, e, n, i, r) {
    for (let o = 0; o !== r; ++o) {
      const r = e + o;
      t[r] = t[r] + t[n + o] * i;
    }
  }
});
const Mc = new RegExp("[\\[\\]\\.:\\/]", "g"),
      Sc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      Ec = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Tc = /(WCOD+)?/.source.replace("WCOD", Sc),
      Ac = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Lc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
      Cc = new RegExp("^" + Ec + Tc + Ac + Lc + "$"),
      Rc = ["material", "materials", "bones"];

function Pc(t, e, n) {
  const i = n || Oc.parseTrackName(e);
  this._targetGroup = t, this._bindings = t.subscribe_(e, i);
}

function Oc(t, e, n) {
  this.path = e, this.parsedPath = n || Oc.parseTrackName(e), this.node = Oc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t;
}

function Nc(t, e, n, i) {
  this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = i || e.blendMode;
  const r = e.tracks,
        o = r.length,
        s = new Array(o),
        a = {
    endingStart: 2400,
    endingEnd: 2400
  };

  for (let t = 0; t !== o; ++t) {
    const e = r[t].createInterpolant(null);
    s[t] = e, e.settings = a;
  }

  this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
}

function Dc(t) {
  this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
}

function Ic(t) {
  "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t;
}

function zc(t, e, n) {
  rr.call(this, t, e), this.meshPerAttribute = n || 1;
}

function Bc(t, e, n, i) {
  this.ray = new pt(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new A(), this.params = {
    Mesh: {},
    Line: {
      threshold: 1
    },
    LOD: {},
    Points: {
      threshold: 1
    },
    Sprite: {}
  }, Object.defineProperties(this.params, {
    PointCloud: {
      get: function () {
        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
      }
    }
  });
}

function kc(t, e) {
  return t.distance - e.distance;
}

function Hc(t, e, n, i) {
  if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
    const i = t.children;

    for (let t = 0, r = i.length; t < r; t++) Hc(i[t], e, n, !0);
  }
}

function Fc(t, e, n) {
  return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this;
}

Object.assign(Pc.prototype, {
  getValue: function (t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
    void 0 !== i && i.getValue(t, e);
  },
  setValue: function (t, e) {
    const n = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e);
  },
  bind: function () {
    const t = this._bindings;

    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind();
  },
  unbind: function () {
    const t = this._bindings;

    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind();
  }
}), Object.assign(Oc, {
  Composite: Pc,
  create: function (t, e, n) {
    return t && t.isAnimationObjectGroup ? new Oc.Composite(t, e, n) : new Oc(t, e, n);
  },
  sanitizeNodeName: function (t) {
    return t.replace(/\s/g, "_").replace(Mc, "");
  },
  parseTrackName: function (t) {
    const e = Cc.exec(t);
    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = {
      nodeName: e[2],
      objectName: e[3],
      objectIndex: e[4],
      propertyName: e[5],
      propertyIndex: e[6]
    },
          i = n.nodeName && n.nodeName.lastIndexOf(".");

    if (void 0 !== i && -1 !== i) {
      const t = n.nodeName.substring(i + 1);
      -1 !== Rc.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t);
    }

    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return n;
  },
  findNode: function (t, e) {
    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;

    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (void 0 !== n) return n;
    }

    if (t.children) {
      const n = function t(n) {
        for (let i = 0; i < n.length; i++) {
          const r = n[i];
          if (r.name === e || r.uuid === e) return r;
          const o = t(r.children);
          if (o) return o;
        }

        return null;
      }(t.children);

      if (n) return n;
    }

    return null;
  }
}), Object.assign(Oc.prototype, {
  _getValue_unavailable: function () {},
  _setValue_unavailable: function () {},
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [function (t, e) {
    t[e] = this.node[this.propertyName];
  }, function (t, e) {
    const n = this.resolvedProperty;

    for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
  }, function (t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex];
  }, function (t, e) {
    this.resolvedProperty.toArray(t, e);
  }],
  SetterByBindingTypeAndVersioning: [[function (t, e) {
    this.targetObject[this.propertyName] = t[e];
  }, function (t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
  }, function (t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function (t, e) {
    const n = this.resolvedProperty;

    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
  }, function (t, e) {
    const n = this.resolvedProperty;

    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];

    this.targetObject.needsUpdate = !0;
  }, function (t, e) {
    const n = this.resolvedProperty;

    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];

    this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function (t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e];
  }, function (t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
  }, function (t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }], [function (t, e) {
    this.resolvedProperty.fromArray(t, e);
  }, function (t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
  }, function (t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
  }]],
  getValue: function (t, e) {
    this.bind(), this.getValue(t, e);
  },
  setValue: function (t, e) {
    this.bind(), this.setValue(t, e);
  },
  bind: function () {
    let t = this.node,
        e = this.parsedPath,
        n = e.objectName,
        i = e.propertyName,
        r = e.propertyIndex;
    if (t || (t = Oc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");

    if (n) {
      let i = e.objectIndex;

      switch (n) {
        case "materials":
          if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
          t = t.material.materials;
          break;

        case "bones":
          if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
          t = t.skeleton.bones;

          for (let e = 0; e < t.length; e++) if (t[e].name === i) {
            i = e;
            break;
          }

          break;

        default:
          if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
          t = t[n];
      }

      if (void 0 !== i) {
        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
        t = t[i];
      }
    }

    const o = t[i];

    if (void 0 === o) {
      const n = e.nodeName;
      return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t);
    }

    let s = this.Versioning.None;
    this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
    let a = this.BindingType.Direct;

    if (void 0 !== r) {
      if ("morphTargetInfluences" === i) {
        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
        if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]);
      }

      a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
    } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;

    this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s];
  },
  unbind: function () {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}), Object.assign(Oc.prototype, {
  _getValue_unbound: Oc.prototype.getValue,
  _setValue_unbound: Oc.prototype.setValue
}), Object.assign(function () {
  this.uuid = n.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
  const t = {};
  this._indicesByUUID = t;

  for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;

  this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
  const e = this;
  this.stats = {
    objects: {
      get total() {
        return e._objects.length;
      },

      get inUse() {
        return this.total - e.nCachedObjects_;
      }

    },

    get bindingsPerObject() {
      return e._bindings.length;
    }

  };
}.prototype, {
  isAnimationObjectGroup: !0,
  add: function () {
    const t = this._objects,
          e = this._indicesByUUID,
          n = this._paths,
          i = this._parsedPaths,
          r = this._bindings,
          o = r.length;
    let s = void 0,
        a = t.length,
        c = this.nCachedObjects_;

    for (let l = 0, u = arguments.length; l !== u; ++l) {
      const u = arguments[l],
            h = u.uuid;
      let d = e[h];

      if (void 0 === d) {
        d = a++, e[h] = d, t.push(u);

        for (let t = 0, e = o; t !== e; ++t) r[t].push(new Oc(u, n[t], i[t]));
      } else if (d < c) {
        s = t[d];
        const a = --c,
              l = t[a];
        e[l.uuid] = d, t[d] = l, e[h] = a, t[a] = u;

        for (let t = 0, e = o; t !== e; ++t) {
          const e = r[t],
                o = e[a];
          let s = e[d];
          e[d] = o, void 0 === s && (s = new Oc(u, n[t], i[t])), e[a] = s;
        }
      } else t[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }

    this.nCachedObjects_ = c;
  },
  remove: function () {
    const t = this._objects,
          e = this._indicesByUUID,
          n = this._bindings,
          i = n.length;
    let r = this.nCachedObjects_;

    for (let o = 0, s = arguments.length; o !== s; ++o) {
      const s = arguments[o],
            a = s.uuid,
            c = e[a];

      if (void 0 !== c && c >= r) {
        const o = r++,
              l = t[o];
        e[l.uuid] = c, t[c] = l, e[a] = o, t[o] = s;

        for (let t = 0, e = i; t !== e; ++t) {
          const e = n[t],
                i = e[o],
                r = e[c];
          e[c] = i, e[o] = r;
        }
      }
    }

    this.nCachedObjects_ = r;
  },
  uncache: function () {
    const t = this._objects,
          e = this._indicesByUUID,
          n = this._bindings,
          i = n.length;
    let r = this.nCachedObjects_,
        o = t.length;

    for (let s = 0, a = arguments.length; s !== a; ++s) {
      const a = arguments[s].uuid,
            c = e[a];
      if (void 0 !== c) if (delete e[a], c < r) {
        const s = --r,
              a = t[s],
              l = --o,
              u = t[l];
        e[a.uuid] = c, t[c] = a, e[u.uuid] = s, t[s] = u, t.pop();

        for (let t = 0, e = i; t !== e; ++t) {
          const e = n[t],
                i = e[s],
                r = e[l];
          e[c] = i, e[s] = r, e.pop();
        }
      } else {
        const r = --o,
              s = t[r];
        e[s.uuid] = c, t[c] = s, t.pop();

        for (let t = 0, e = i; t !== e; ++t) {
          const e = n[t];
          e[c] = e[r], e.pop();
        }
      }
    }

    this.nCachedObjects_ = r;
  },
  subscribe_: function (t, e) {
    let n = this._bindingsIndicesByPath,
        i = n[t],
        r = this._bindings;
    if (void 0 !== i) return r[i];
    const o = this._paths,
          s = this._parsedPaths,
          a = this._objects,
          c = a.length,
          l = this.nCachedObjects_,
          u = new Array(c);
    i = r.length, n[t] = i, o.push(t), s.push(e), r.push(u);

    for (let n = l, i = a.length; n !== i; ++n) {
      const i = a[n];
      u[n] = new Oc(i, t, e);
    }

    return u;
  },
  unsubscribe_: function (t) {
    const e = this._bindingsIndicesByPath,
          n = e[t];

    if (void 0 !== n) {
      const i = this._paths,
            r = this._parsedPaths,
            o = this._bindings,
            s = o.length - 1,
            a = o[s];
      e[t[s]] = n, o[n] = a, o.pop(), r[n] = r[s], r.pop(), i[n] = i[s], i.pop();
    }
  }
}), Object.assign(Nc.prototype, {
  play: function () {
    return this._mixer._activateAction(this), this;
  },
  stop: function () {
    return this._mixer._deactivateAction(this), this.reset();
  },
  reset: function () {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  },
  isRunning: function () {
    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
  },
  isScheduled: function () {
    return this._mixer._isActiveAction(this);
  },
  startAt: function (t) {
    return this._startTime = t, this;
  },
  setLoop: function (t, e) {
    return this.loop = t, this.repetitions = e, this;
  },
  setEffectiveWeight: function (t) {
    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
  },
  getEffectiveWeight: function () {
    return this._effectiveWeight;
  },
  fadeIn: function (t) {
    return this._scheduleFading(t, 0, 1);
  },
  fadeOut: function (t) {
    return this._scheduleFading(t, 1, 0);
  },
  crossFadeFrom: function (t, e, n) {
    if (t.fadeOut(e), this.fadeIn(e), n) {
      const n = this._clip.duration,
            i = t._clip.duration,
            r = i / n,
            o = n / i;
      t.warp(1, r, e), this.warp(o, 1, e);
    }

    return this;
  },
  crossFadeTo: function (t, e, n) {
    return t.crossFadeFrom(this, e, n);
  },
  stopFading: function () {
    let t = this._weightInterpolant;
    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
  },
  setEffectiveTimeScale: function (t) {
    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
  },
  getEffectiveTimeScale: function () {
    return this._effectiveTimeScale;
  },
  setDuration: function (t) {
    return this.timeScale = this._clip.duration / t, this.stopWarping();
  },
  syncWith: function (t) {
    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
  },
  halt: function (t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  },
  warp: function (t, e, n) {
    const i = this._mixer,
          r = i.time,
          o = this.timeScale;
    let s = this._timeScaleInterpolant;
    null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
    const a = s.parameterPositions,
          c = s.sampleValues;
    return a[0] = r, a[1] = r + n, c[0] = t / o, c[1] = e / o, this;
  },
  stopWarping: function () {
    let t = this._timeScaleInterpolant;
    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
  },
  getMixer: function () {
    return this._mixer;
  },
  getClip: function () {
    return this._clip;
  },
  getRoot: function () {
    return this._localRoot || this._mixer._root;
  },
  _update: function (t, e, n, i) {
    if (!this.enabled) return void this._updateWeight(t);
    const r = this._startTime;

    if (null !== r) {
      const i = (t - r) * n;
      if (i < 0 || 0 === n) return;
      this._startTime = null, e = n * i;
    }

    e *= this._updateTimeScale(t);

    const o = this._updateTime(e),
          s = this._updateWeight(t);

    if (s > 0) {
      const t = this._interpolants,
            e = this._propertyBindings;

      switch (this.blendMode) {
        case 2501:
          for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(o), e[n].accumulateAdditive(s);

          break;

        case 2500:
        default:
          for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulate(i, s);

      }
    }
  },
  _updateWeight: function (t) {
    let e = 0;

    if (this.enabled) {
      e = this.weight;
      const n = this._weightInterpolant;

      if (null !== n) {
        const i = n.evaluate(t)[0];
        e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1));
      }
    }

    return this._effectiveWeight = e, e;
  },
  _updateTimeScale: function (t) {
    let e = 0;

    if (!this.paused) {
      e = this.timeScale;
      const n = this._timeScaleInterpolant;
      null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e));
    }

    return this._effectiveTimeScale = e, e;
  },
  _updateTime: function (t) {
    const e = this._clip.duration,
          n = this.loop;
    let i = this.time + t,
        r = this._loopCount;
    const o = 2202 === n;
    if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;

    if (2200 === n) {
      -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));

      t: {
        if (i >= e) i = e;else {
          if (!(i < 0)) {
            this.time = i;
            break t;
          }

          i = 0;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: t < 0 ? -1 : 1
        });
      }
    } else {
      if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= e || i < 0) {
        const n = Math.floor(i / e);
        i -= e * n, r += Math.abs(n);
        const s = this.repetitions - r;
        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: t > 0 ? 1 : -1
        });else {
          if (1 === s) {
            const e = t < 0;

            this._setEndings(e, !e, o);
          } else this._setEndings(!1, !1, o);

          this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: n
          });
        }
      } else this.time = i;

      if (o && 1 == (1 & r)) return e - i;
    }

    return i;
  },
  _setEndings: function (t, e, n) {
    const i = this._interpolantSettings;
    n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
  },
  _scheduleFading: function (t, e, n) {
    const i = this._mixer,
          r = i.time;
    let o = this._weightInterpolant;
    null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
    const s = o.parameterPositions,
          a = o.sampleValues;
    return s[0] = r, a[0] = e, s[1] = r + t, a[1] = n, this;
  }
}), Dc.prototype = Object.assign(Object.create(t.prototype), {
  constructor: Dc,
  _bindAction: function (t, e) {
    const n = t._localRoot || this._root,
          i = t._clip.tracks,
          r = i.length,
          o = t._propertyBindings,
          s = t._interpolants,
          a = n.uuid,
          c = this._bindingsByRootAndName;
    let l = c[a];
    void 0 === l && (l = {}, c[a] = l);

    for (let t = 0; t !== r; ++t) {
      const r = i[t],
            c = r.name;
      let u = l[c];
      if (void 0 !== u) o[t] = u;else {
        if (u = o[t], void 0 !== u) {
          null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, c));
          continue;
        }

        const i = e && e._propertyBindings[t].binding.parsedPath;
        u = new wc(Oc.create(n, c, i), r.ValueTypeName, r.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, c), o[t] = u;
      }
      s[t].resultBuffer = u.buffer;
    }
  },
  _activateAction: function (t) {
    if (!this._isActiveAction(t)) {
      if (null === t._cacheIndex) {
        const e = (t._localRoot || this._root).uuid,
              n = t._clip.uuid,
              i = this._actionsByClip[n];
        this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e);
      }

      const e = t._propertyBindings;

      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t];
        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
      }

      this._lendAction(t);
    }
  },
  _deactivateAction: function (t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;

      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t];
        0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n));
      }

      this._takeBackAction(t);
    }
  },
  _initMemoryManager: function () {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },

        get inUse() {
          return t._nActiveActions;
        }

      },
      bindings: {
        get total() {
          return t._bindings.length;
        },

        get inUse() {
          return t._nActiveBindings;
        }

      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },

        get inUse() {
          return t._nActiveControlInterpolants;
        }

      }
    };
  },
  _isActiveAction: function (t) {
    const e = t._cacheIndex;
    return null !== e && e < this._nActiveActions;
  },
  _addInactiveAction: function (t, e, n) {
    const i = this._actions,
          r = this._actionsByClip;
    let o = r[e];
    if (void 0 === o) o = {
      knownActions: [t],
      actionByRoot: {}
    }, t._byClipCacheIndex = 0, r[e] = o;else {
      const e = o.knownActions;
      t._byClipCacheIndex = e.length, e.push(t);
    }
    t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t;
  },
  _removeInactiveAction: function (t) {
    const e = this._actions,
          n = e[e.length - 1],
          i = t._cacheIndex;
    n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
    const r = t._clip.uuid,
          o = this._actionsByClip,
          s = o[r],
          a = s.knownActions,
          c = a[a.length - 1],
          l = t._byClipCacheIndex;
    c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t);
  },
  _removeInactiveBindingsForAction: function (t) {
    const e = t._propertyBindings;

    for (let t = 0, n = e.length; t !== n; ++t) {
      const n = e[t];
      0 == --n.referenceCount && this._removeInactiveBinding(n);
    }
  },
  _lendAction: function (t) {
    const e = this._actions,
          n = t._cacheIndex,
          i = this._nActiveActions++,
          r = e[i];
    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
  },
  _takeBackAction: function (t) {
    const e = this._actions,
          n = t._cacheIndex,
          i = --this._nActiveActions,
          r = e[i];
    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
  },
  _addInactiveBinding: function (t, e, n) {
    const i = this._bindingsByRootAndName,
          r = this._bindings;
    let o = i[e];
    void 0 === o && (o = {}, i[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t);
  },
  _removeInactiveBinding: function (t) {
    const e = this._bindings,
          n = t.binding,
          i = n.rootNode.uuid,
          r = n.path,
          o = this._bindingsByRootAndName,
          s = o[i],
          a = e[e.length - 1],
          c = t._cacheIndex;
    a._cacheIndex = c, e[c] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i];
  },
  _lendBinding: function (t) {
    const e = this._bindings,
          n = t._cacheIndex,
          i = this._nActiveBindings++,
          r = e[i];
    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
  },
  _takeBackBinding: function (t) {
    const e = this._bindings,
          n = t._cacheIndex,
          i = --this._nActiveBindings,
          r = e[i];
    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r;
  },
  _lendControlInterpolant: function () {
    const t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++;
    let n = t[e];
    return void 0 === n && (n = new Ds(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n;
  },
  _takeBackControlInterpolant: function (t) {
    const e = this._controlInterpolants,
          n = t.__cacheIndex,
          i = --this._nActiveControlInterpolants,
          r = e[i];
    t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  clipAction: function (t, e, n) {
    const i = e || this._root,
          r = i.uuid;
    let o = "string" == typeof t ? Vs.findByName(i, t) : t;
    const s = null !== o ? o.uuid : t;
    let a = this._actionsByClip[s],
        c = null;

    if (void 0 === n && (n = null !== o ? o.blendMode : 2500), void 0 !== a) {
      const t = a.actionByRoot[r];
      if (void 0 !== t && t.blendMode === n) return t;
      c = a.knownActions[0], null === o && (o = c._clip);
    }

    if (null === o) return null;
    const l = new Nc(this, o, e, n);
    return this._bindAction(l, c), this._addInactiveAction(l, s, r), l;
  },
  existingAction: function (t, e) {
    const n = e || this._root,
          i = n.uuid,
          r = "string" == typeof t ? Vs.findByName(n, t) : t,
          o = r ? r.uuid : t,
          s = this._actionsByClip[o];
    return void 0 !== s && s.actionByRoot[i] || null;
  },
  stopAllAction: function () {
    const t = this._actions;

    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();

    return this;
  },
  update: function (t) {
    t *= this.timeScale;
    const e = this._actions,
          n = this._nActiveActions,
          i = this.time += t,
          r = Math.sign(t),
          o = this._accuIndex ^= 1;

    for (let s = 0; s !== n; ++s) e[s]._update(i, t, r, o);

    const s = this._bindings,
          a = this._nActiveBindings;

    for (let t = 0; t !== a; ++t) s[t].apply(o);

    return this;
  },
  setTime: function (t) {
    this.time = 0;

    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;

    return this.update(t);
  },
  getRoot: function () {
    return this._root;
  },
  uncacheClip: function (t) {
    const e = this._actions,
          n = t.uuid,
          i = this._actionsByClip,
          r = i[n];

    if (void 0 !== r) {
      const t = r.knownActions;

      for (let n = 0, i = t.length; n !== i; ++n) {
        const i = t[n];

        this._deactivateAction(i);

        const r = i._cacheIndex,
              o = e[e.length - 1];
        i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(i);
      }

      delete i[n];
    }
  },
  uncacheRoot: function (t) {
    const e = t.uuid,
          n = this._actionsByClip;

    for (const t in n) {
      const i = n[t].actionByRoot[e];
      void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
    }

    const i = this._bindingsByRootAndName[e];
    if (void 0 !== i) for (const t in i) {
      const e = i[t];
      e.restoreOriginalState(), this._removeInactiveBinding(e);
    }
  },
  uncacheAction: function (t, e) {
    const n = this.existingAction(t, e);
    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}), Ic.prototype.clone = function () {
  return new Ic(void 0 === this.value.clone ? this.value : this.value.clone());
}, zc.prototype = Object.assign(Object.create(rr.prototype), {
  constructor: zc,
  isInstancedInterleavedBuffer: !0,
  copy: function (t) {
    return rr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this;
  },
  clone: function (t) {
    const e = rr.prototype.clone.call(this, t);
    return e.meshPerAttribute = this.meshPerAttribute, e;
  },
  toJSON: function (t) {
    const e = rr.prototype.toJSON.call(this, t);
    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e;
  }
}), Object.assign(Bc.prototype, {
  set: function (t, e) {
    this.ray.set(t, e);
  },
  setFromCamera: function (t, e) {
    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.");
  },
  intersectObject: function (t, e, n) {
    const i = n || [];
    return Hc(t, this, i, e), i.sort(kc), i;
  },
  intersectObjects: function (t, e, n) {
    const i = n || [];
    if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;

    for (let n = 0, r = t.length; n < r; n++) Hc(t[n], this, i, e);

    return i.sort(kc), i;
  }
}), Object.assign(Fc.prototype, {
  set: function (t, e, n) {
    return this.radius = t, this.phi = e, this.theta = n, this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
  },
  makeSafe: function () {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  },
  setFromVector3: function (t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  },
  setFromCartesianCoords: function (t, e, i) {
    return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(n.clamp(e / this.radius, -1, 1))), this;
  }
}), Object.assign(function (t, e, n) {
  return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this;
}.prototype, {
  set: function (t, e, n) {
    return this.radius = t, this.theta = e, this.y = n, this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
  },
  setFromVector3: function (t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  },
  setFromCartesianCoords: function (t, e, n) {
    return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this;
  }
});
const Uc = new i();

function Gc(t, e) {
  this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new i(-1 / 0, -1 / 0);
}

Object.assign(Gc.prototype, {
  set: function (t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  },
  setFromPoints: function (t) {
    this.makeEmpty();

    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);

    return this;
  },
  setFromCenterAndSize: function (t, e) {
    const n = Uc.copy(e).multiplyScalar(.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  },
  makeEmpty: function () {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  },
  isEmpty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function (t) {
    return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new i()), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
  },
  getSize: function (t) {
    return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new i()), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
  },
  expandByPoint: function (t) {
    return this.min.min(t), this.max.max(t), this;
  },
  expandByVector: function (t) {
    return this.min.sub(t), this.max.add(t), this;
  },
  expandByScalar: function (t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  },
  containsPoint: function (t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
  },
  containsBox: function (t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
  },
  getParameter: function (t, e) {
    return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new i()), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
  },
  intersectsBox: function (t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
  },
  clampPoint: function (t, e) {
    return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new i()), e.copy(t).clamp(this.min, this.max);
  },
  distanceToPoint: function (t) {
    return Uc.copy(t).clamp(this.min, this.max).sub(t).length();
  },
  intersect: function (t) {
    return this.min.max(t.min), this.max.min(t.max), this;
  },
  union: function (t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  },
  translate: function (t) {
    return this.min.add(t), this.max.add(t), this;
  },
  equals: function (t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
});
const jc = new m(),
      Vc = new m();

function Wc(t, e) {
  this.start = void 0 !== t ? t : new m(), this.end = void 0 !== e ? e : new m();
}

function qc(t) {
  U.call(this), this.material = t, this.render = function () {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
}

Object.assign(Wc.prototype, {
  set: function (t, e) {
    return this.start.copy(t), this.end.copy(e), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return this.start.copy(t.start), this.end.copy(t.end), this;
  },
  getCenter: function (t) {
    return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new m()), t.addVectors(this.start, this.end).multiplyScalar(.5);
  },
  delta: function (t) {
    return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new m()), t.subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, e) {
    return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new m()), this.delta(e).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function (t, e) {
    jc.subVectors(t, this.start), Vc.subVectors(this.end, this.start);
    const i = Vc.dot(Vc);
    let r = Vc.dot(jc) / i;
    return e && (r = n.clamp(r, 0, 1)), r;
  },
  closestPointToPoint: function (t, e, n) {
    const i = this.closestPointToPointParameter(t, e);
    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new m()), this.delta(n).multiplyScalar(i).add(this.start);
  },
  applyMatrix4: function (t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
  },
  equals: function (t) {
    return t.start.equals(this.start) && t.end.equals(this.end);
  }
}), qc.prototype = Object.create(U.prototype), qc.prototype.constructor = qc, qc.prototype.isImmediateRenderObject = !0;
const Xc = new m();

function Yc(t, e) {
  U.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
  const n = new ae(),
        i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

  for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
    const r = t / n * Math.PI * 2,
          o = e / n * Math.PI * 2;
    i.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1);
  }

  n.setAttribute("position", new Jt(i, 3));
  const r = new zr({
    fog: !1,
    toneMapped: !1
  });
  this.cone = new Wr(n, r), this.add(this.cone), this.update();
}

Yc.prototype = Object.create(U.prototype), Yc.prototype.constructor = Yc, Yc.prototype.dispose = function () {
  this.cone.geometry.dispose(), this.cone.material.dispose();
}, Yc.prototype.update = function () {
  this.light.updateMatrixWorld();
  const t = this.light.distance ? this.light.distance : 1e3,
        e = t * Math.tan(this.light.angle);
  this.cone.scale.set(e, e, t), Xc.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Xc), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
};
const Zc = new m(),
      Jc = new M(),
      Qc = new M();

function Kc(t) {
  const e = function t(e) {
    const n = [];
    e && e.isBone && n.push(e);

    for (let i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));

    return n;
  }(t),
        n = new ae(),
        i = [],
        r = [],
        o = new Ot(0, 0, 1),
        s = new Ot(0, 1, 0);

  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b));
  }

  n.setAttribute("position", new Jt(i, 3)), n.setAttribute("color", new Jt(r, 3));
  const a = new zr({
    vertexColors: !0,
    depthTest: !1,
    depthWrite: !1,
    toneMapped: !1,
    transparent: !0
  });
  Wr.call(this, n, a), this.type = "SkeletonHelper", this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
}

function $c(t, e, n) {
  this.light = t, this.light.updateMatrixWorld(), this.color = n;
  const i = new rs(e, 4, 2),
        r = new Ht({
    wireframe: !0,
    fog: !1,
    toneMapped: !1
  });
  Ee.call(this, i, r), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
}

Kc.prototype = Object.create(Wr.prototype), Kc.prototype.constructor = Kc, Kc.prototype.isSkeletonHelper = !0, Kc.prototype.updateMatrixWorld = function (t) {
  const e = this.bones,
        n = this.geometry,
        i = n.getAttribute("position");
  Qc.getInverse(this.root.matrixWorld);

  for (let t = 0, n = 0; t < e.length; t++) {
    const r = e[t];
    r.parent && r.parent.isBone && (Jc.multiplyMatrices(Qc, r.matrixWorld), Zc.setFromMatrixPosition(Jc), i.setXYZ(n, Zc.x, Zc.y, Zc.z), Jc.multiplyMatrices(Qc, r.parent.matrixWorld), Zc.setFromMatrixPosition(Jc), i.setXYZ(n + 1, Zc.x, Zc.y, Zc.z), n += 2);
  }

  n.getAttribute("position").needsUpdate = !0, U.prototype.updateMatrixWorld.call(this, t);
}, $c.prototype = Object.create(Ee.prototype), $c.prototype.constructor = $c, $c.prototype.dispose = function () {
  this.geometry.dispose(), this.material.dispose();
}, $c.prototype.update = function () {
  void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
};
const tl = new m(),
      el = new Ot(),
      nl = new Ot();

function il(t, e, n) {
  U.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
  const i = new po(e);
  i.rotateY(.5 * Math.PI), this.material = new Ht({
    wireframe: !0,
    fog: !1,
    toneMapped: !1
  }), void 0 === this.color && (this.material.vertexColors = !0);
  const r = i.getAttribute("position"),
        o = new Float32Array(3 * r.count);
  i.setAttribute("color", new Gt(o, 3)), this.add(new Ee(i, this.material)), this.update();
}

function rl(t, e, n, i) {
  t = t || 10, e = e || 10, n = new Ot(void 0 !== n ? n : 4473924), i = new Ot(void 0 !== i ? i : 8947848);
  const r = e / 2,
        o = t / e,
        s = t / 2,
        a = [],
        c = [];

  for (let t = 0, l = 0, u = -s; t <= e; t++, u += o) {
    a.push(-s, 0, u, s, 0, u), a.push(u, 0, -s, u, 0, s);
    const e = t === r ? n : i;
    e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3;
  }

  const l = new ae();
  l.setAttribute("position", new Jt(a, 3)), l.setAttribute("color", new Jt(c, 3));
  const u = new zr({
    vertexColors: !0,
    toneMapped: !1
  });
  Wr.call(this, l, u), this.type = "GridHelper";
}

function ol(t, e, n, i, r, o) {
  t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new Ot(void 0 !== r ? r : 4473924), o = new Ot(void 0 !== o ? o : 8947848);
  const s = [],
        a = [];

  for (let n = 0; n <= e; n++) {
    const i = n / e * (2 * Math.PI),
          c = Math.sin(i) * t,
          l = Math.cos(i) * t;
    s.push(0, 0, 0), s.push(c, 0, l);
    const u = 1 & n ? r : o;
    a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b);
  }

  for (let e = 0; e <= n; e++) {
    const c = 1 & e ? r : o,
          l = t - t / n * e;

    for (let t = 0; t < i; t++) {
      let e = t / i * (2 * Math.PI),
          n = Math.sin(e) * l,
          r = Math.cos(e) * l;
      s.push(n, 0, r), a.push(c.r, c.g, c.b), e = (t + 1) / i * (2 * Math.PI), n = Math.sin(e) * l, r = Math.cos(e) * l, s.push(n, 0, r), a.push(c.r, c.g, c.b);
    }
  }

  const c = new ae();
  c.setAttribute("position", new Jt(s, 3)), c.setAttribute("color", new Jt(a, 3));
  const l = new zr({
    vertexColors: !0,
    toneMapped: !1
  });
  Wr.call(this, c, l), this.type = "PolarGridHelper";
}

il.prototype = Object.create(U.prototype), il.prototype.constructor = il, il.prototype.dispose = function () {
  this.children[0].geometry.dispose(), this.children[0].material.dispose();
}, il.prototype.update = function () {
  const t = this.children[0];
  if (void 0 !== this.color) this.material.color.set(this.color);else {
    const e = t.geometry.getAttribute("color");
    el.copy(this.light.color), nl.copy(this.light.groundColor);

    for (let t = 0, n = e.count; t < n; t++) {
      const i = t < n / 2 ? el : nl;
      e.setXYZ(t, i.r, i.g, i.b);
    }

    e.needsUpdate = !0;
  }
  t.lookAt(tl.setFromMatrixPosition(this.light.matrixWorld).negate());
}, rl.prototype = Object.assign(Object.create(Wr.prototype), {
  constructor: rl,
  copy: function (t) {
    return Wr.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
}), ol.prototype = Object.create(Wr.prototype), ol.prototype.constructor = ol;
const sl = new m(),
      al = new m(),
      cl = new m();

function ll(t, e, n) {
  U.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
  let i = new ae();
  i.setAttribute("position", new Jt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
  const r = new zr({
    fog: !1,
    toneMapped: !1
  });
  this.lightPlane = new Gr(i, r), this.add(this.lightPlane), i = new ae(), i.setAttribute("position", new Jt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Gr(i, r), this.add(this.targetLine), this.update();
}

ll.prototype = Object.create(U.prototype), ll.prototype.constructor = ll, ll.prototype.dispose = function () {
  this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
}, ll.prototype.update = function () {
  sl.setFromMatrixPosition(this.light.matrixWorld), al.setFromMatrixPosition(this.light.target.matrixWorld), cl.subVectors(al, sl), this.lightPlane.lookAt(al), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(al), this.targetLine.scale.z = cl.length();
};
const ul = new m(),
      hl = new ke();

function dl(t) {
  const e = new ae(),
        n = new zr({
    color: 16777215,
    vertexColors: !0,
    toneMapped: !1
  }),
        i = [],
        r = [],
        o = {},
        s = new Ot(16755200),
        a = new Ot(16711680),
        c = new Ot(43775),
        l = new Ot(16777215),
        u = new Ot(3355443);

  function h(t, e, n) {
    d(t, n), d(e, n);
  }

  function d(t, e) {
    i.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(i.length / 3 - 1);
  }

  h("n1", "n2", s), h("n2", "n4", s), h("n4", "n3", s), h("n3", "n1", s), h("f1", "f2", s), h("f2", "f4", s), h("f4", "f3", s), h("f3", "f1", s), h("n1", "f1", s), h("n2", "f2", s), h("n3", "f3", s), h("n4", "f4", s), h("p", "n1", a), h("p", "n2", a), h("p", "n3", a), h("p", "n4", a), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", l), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), e.setAttribute("position", new Jt(i, 3)), e.setAttribute("color", new Jt(r, 3)), Wr.call(this, e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
}

function pl(t, e, n, i, r, o, s) {
  ul.set(r, o, s).unproject(i);
  const a = e[t];

  if (void 0 !== a) {
    const t = n.getAttribute("position");

    for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], ul.x, ul.y, ul.z);
  }
}

dl.prototype = Object.create(Wr.prototype), dl.prototype.constructor = dl, dl.prototype.update = function () {
  const t = this.geometry,
        e = this.pointMap;
  hl.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), pl("c", e, t, hl, 0, 0, -1), pl("t", e, t, hl, 0, 0, 1), pl("n1", e, t, hl, -1, -1, -1), pl("n2", e, t, hl, 1, -1, -1), pl("n3", e, t, hl, -1, 1, -1), pl("n4", e, t, hl, 1, 1, -1), pl("f1", e, t, hl, -1, -1, 1), pl("f2", e, t, hl, 1, -1, 1), pl("f3", e, t, hl, -1, 1, 1), pl("f4", e, t, hl, 1, 1, 1), pl("u1", e, t, hl, .7, 1.1, -1), pl("u2", e, t, hl, -.7, 1.1, -1), pl("u3", e, t, hl, 0, 2, -1), pl("cf1", e, t, hl, -1, 0, 1), pl("cf2", e, t, hl, 1, 0, 1), pl("cf3", e, t, hl, 0, -1, 1), pl("cf4", e, t, hl, 0, 1, 1), pl("cn1", e, t, hl, -1, 0, -1), pl("cn2", e, t, hl, 1, 0, -1), pl("cn3", e, t, hl, 0, -1, -1), pl("cn4", e, t, hl, 0, 1, -1), t.getAttribute("position").needsUpdate = !0;
};
const fl = new nt();

function ml(t, e) {
  this.object = t, void 0 === e && (e = 16776960);
  const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
        i = new Float32Array(24),
        r = new ae();
  r.setIndex(new Gt(n, 1)), r.setAttribute("position", new Gt(i, 3)), Wr.call(this, r, new zr({
    color: e,
    toneMapped: !1
  })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
}

function gl(t, e) {
  this.type = "Box3Helper", this.box = t, e = e || 16776960;
  const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
        i = new ae();
  i.setIndex(new Gt(n, 1)), i.setAttribute("position", new Jt([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Wr.call(this, i, new zr({
    color: e,
    toneMapped: !1
  })), this.type = "Box3Helper", this.geometry.computeBoundingSphere();
}

function vl(t, e, n) {
  this.plane = t, this.size = void 0 === e ? 1 : e;
  const i = void 0 !== n ? n : 16776960,
        r = new ae();
  r.setAttribute("position", new Jt([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Gr.call(this, r, new zr({
    color: i,
    toneMapped: !1
  })), this.type = "PlaneHelper";
  const o = new ae();
  o.setAttribute("position", new Jt([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Ee(o, new Ht({
    color: i,
    opacity: .2,
    transparent: !0,
    depthWrite: !1,
    toneMapped: !1
  })));
}

ml.prototype = Object.create(Wr.prototype), ml.prototype.constructor = ml, ml.prototype.update = function (t) {
  if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && fl.setFromObject(this.object), fl.isEmpty()) return;
  const e = fl.min,
        n = fl.max,
        i = this.geometry.attributes.position,
        r = i.array;
  r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
}, ml.prototype.setFromObject = function (t) {
  return this.object = t, this.update(), this;
}, ml.prototype.copy = function (t) {
  return Wr.prototype.copy.call(this, t), this.object = t.object, this;
}, ml.prototype.clone = function () {
  return new this.constructor().copy(this);
}, gl.prototype = Object.create(Wr.prototype), gl.prototype.constructor = gl, gl.prototype.updateMatrixWorld = function (t) {
  const e = this.box;
  e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), U.prototype.updateMatrixWorld.call(this, t));
}, vl.prototype = Object.create(Gr.prototype), vl.prototype.constructor = vl, vl.prototype.updateMatrixWorld = function (t) {
  let e = -this.plane.constant;
  Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? 1 : 0, this.lookAt(this.plane.normal), U.prototype.updateMatrixWorld.call(this, t);
};
const yl = new m();

let xl, _l;

function bl(t, e, n, i, r, o) {
  U.call(this), this.type = "ArrowHelper", void 0 === t && (t = new m(0, 0, 1)), void 0 === e && (e = new m(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === xl && (xl = new ae(), xl.setAttribute("position", new Jt([0, 0, 0, 0, 1, 0], 3)), _l = new fs(0, .5, 1, 5, 1), _l.translate(0, -.5, 0)), this.position.copy(e), this.line = new Gr(xl, new zr({
    color: i,
    toneMapped: !1
  })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ee(_l, new Ht({
    color: i,
    toneMapped: !1
  })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, o);
}

function wl(t) {
  const e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
        n = new ae();
  n.setAttribute("position", new Jt(e, 3)), n.setAttribute("color", new Jt([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
  const i = new zr({
    vertexColors: !0,
    toneMapped: !1
  });
  Wr.call(this, n, i), this.type = "AxesHelper";
}

bl.prototype = Object.create(U.prototype), bl.prototype.constructor = bl, bl.prototype.setDirection = function (t) {
  if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);else {
    yl.set(t.z, 0, -t.x).normalize();
    const e = Math.acos(t.y);
    this.quaternion.setFromAxisAngle(yl, e);
  }
}, bl.prototype.setLength = function (t, e, n) {
  void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix();
}, bl.prototype.setColor = function (t) {
  this.line.material.color.set(t), this.cone.material.color.set(t);
}, bl.prototype.copy = function (t) {
  return U.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this;
}, bl.prototype.clone = function () {
  return new this.constructor().copy(this);
}, wl.prototype = Object.create(Wr.prototype), wl.prototype.constructor = wl;

const Ml = Math.pow(2, 8),
      Sl = [.125, .215, .35, .446, .526, .582],
      El = 5 + Sl.length,
      Tl = {
  3e3: 0,
  3001: 1,
  3002: 2,
  3004: 3,
  3005: 4,
  3006: 5,
  3007: 6
},
      Al = new Da(),
      {
  _lodPlanes: Ll,
  _sizeLods: Cl,
  _sigmas: Rl
} = function () {
  const t = [],
        e = [],
        n = [];
  let i = 8;

  for (let r = 0; r < El; r++) {
    const o = Math.pow(2, i);
    e.push(o);
    let s = 1 / o;
    r > 4 ? s = Sl[r - 8 + 4 - 1] : 0 == r && (s = 0), n.push(s);
    const a = 1 / (o - 1),
          c = -a / 2,
          l = 1 + a / 2,
          u = [c, c, l, c, l, l, c, c, l, l, c, l],
          h = 6,
          d = 6,
          p = 3,
          f = 2,
          m = 1,
          g = new Float32Array(p * d * h),
          v = new Float32Array(f * d * h),
          y = new Float32Array(m * d * h);

    for (let t = 0; t < h; t++) {
      const e = t % 3 * 2 / 3 - 1,
            n = t > 2 ? 0 : -1,
            i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
      g.set(i, p * d * t), v.set(u, f * d * t);
      const r = [t, t, t, t, t, t];
      y.set(r, m * d * t);
    }

    const x = new ae();
    x.setAttribute("position", new Gt(g, p)), x.setAttribute("uv", new Gt(v, f)), x.setAttribute("faceIndex", new Gt(y, m)), t.push(x), i > 4 && i--;
  }

  return {
    _lodPlanes: t,
    _sizeLods: e,
    _sigmas: n
  };
}();

let Pl = null;
const Ol = (1 + Math.sqrt(5)) / 2,
      Nl = 1 / Ol,
      Dl = [new m(1, 1, 1), new m(-1, 1, 1), new m(1, 1, -1), new m(-1, 1, -1), new m(0, Ol, Nl), new m(0, Ol, -Nl), new m(Nl, 0, Ol), new m(-Nl, 0, Ol), new m(Ol, Nl, 0), new m(-Ol, Nl, 0)];

function Il(t) {
  this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = new bs({
    name: "SphericalGaussianBlur",
    defines: {
      n: 20
    },
    uniforms: {
      envMap: {
        value: null
      },
      samples: {
        value: 1
      },
      weights: {
        value: new Float32Array(20)
      },
      latitudinal: {
        value: !1
      },
      dTheta: {
        value: 0
      },
      mipInt: {
        value: 0
      },
      poleAxis: {
        value: new m(0, 1, 0)
      },
      inputEncoding: {
        value: Tl[3e3]
      },
      outputEncoding: {
        value: Tl[3e3]
      }
    },
    vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n".concat("\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t", "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  }), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
}

function zl(t) {
  return void 0 !== t && 1009 === t.type && (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding);
}

function Bl(t) {
  const e = new u(3 * Ml, 3 * Ml, t);
  return e.texture.mapping = 306, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e;
}

function kl(t, e, n, i, r) {
  t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
}

function Hl() {
  return new bs({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {
        value: null
      },
      texelSize: {
        value: new i(1, 1)
      },
      inputEncoding: {
        value: Tl[3e3]
      },
      outputEncoding: {
        value: Tl[3e3]
      }
    },
    vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n".concat("\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t", "\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}

function Fl() {
  return new bs({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {
        value: null
      },
      inputEncoding: {
        value: Tl[3e3]
      },
      outputEncoding: {
        value: Tl[3e3]
      }
    },
    vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n".concat("\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t", "\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),
    blending: 0,
    depthTest: !1,
    depthWrite: !1
  });
}

function Ul(t) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), da.call(this, t), this.type = "catmullrom";
}

Il.prototype = {
  constructor: Il,
  fromScene: function (t, e = 0, n = .1, i = 100) {
    Pl = this._renderer.getRenderTarget();

    const r = this._allocateTargets();

    return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r;
  },
  fromEquirectangular: function (t) {
    return this._fromTexture(t);
  },
  fromCubemap: function (t) {
    return this._fromTexture(t);
  },
  compileCubemapShader: function () {
    null === this._cubemapShader && (this._cubemapShader = Fl(), this._compileMaterial(this._cubemapShader));
  },
  compileEquirectangularShader: function () {
    null === this._equirectShader && (this._equirectShader = Hl(), this._compileMaterial(this._equirectShader));
  },
  dispose: function () {
    this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();

    for (let t = 0; t < Ll.length; t++) Ll[t].dispose();
  },
  _cleanup: function (t) {
    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Pl), t.scissorTest = !1, kl(t, 0, 0, t.width, t.height);
  },
  _fromTexture: function (t) {
    Pl = this._renderer.getRenderTarget();

    const e = this._allocateTargets(t);

    return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
  },
  _allocateTargets: function (t) {
    const e = {
      magFilter: 1003,
      minFilter: 1003,
      generateMipmaps: !1,
      type: 1009,
      format: 1023,
      encoding: zl(t) ? t.encoding : 3002,
      depthBuffer: !1,
      stencilBuffer: !1
    },
          n = Bl(e);
    return n.depthBuffer = !t, this._pingPongRenderTarget = Bl(e), n;
  },
  _compileMaterial: function (t) {
    const e = new Ee(Ll[0], t);

    this._renderer.compile(e, Al);
  },
  _sceneToCubeUV: function (t, e, n, i) {
    const r = new He(90, 1, e, n),
          o = [1, -1, 1, 1, 1, 1],
          s = [1, 1, 1, -1, -1, -1],
          a = this._renderer,
          c = a.outputEncoding,
          l = a.toneMapping,
          u = a.getClearColor(),
          h = a.getClearAlpha();
    a.toneMapping = 0, a.outputEncoding = 3e3;
    let d = t.background;

    if (d && d.isColor) {
      d.convertSRGBToLinear();
      const e = Math.max(d.r, d.g, d.b),
            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
      d = d.multiplyScalar(Math.pow(2, -n));
      const i = (n + 128) / 255;
      a.setClearColor(d, i), t.background = null;
    }

    for (let e = 0; e < 6; e++) {
      const n = e % 3;
      0 == n ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0)) : 1 == n ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0)) : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])), kl(i, n * Ml, e > 2 ? Ml : 0, Ml, Ml), a.setRenderTarget(i), a.render(t, r);
    }

    a.toneMapping = l, a.outputEncoding = c, a.setClearColor(u, h);
  },
  _textureToCubeUV: function (t, e) {
    const n = this._renderer;
    t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Fl()) : null == this._equirectShader && (this._equirectShader = Hl());
    const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
          r = new Ee(Ll[0], i),
          o = i.uniforms;
    o.envMap.value = t, t.isCubeTexture || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height), o.inputEncoding.value = Tl[t.encoding], o.outputEncoding.value = Tl[e.texture.encoding], kl(e, 0, 0, 3 * Ml, 2 * Ml), n.setRenderTarget(e), n.render(r, Al);
  },
  _applyPMREM: function (t) {
    const e = this._renderer,
          n = e.autoClear;
    e.autoClear = !1;

    for (let e = 1; e < El; e++) {
      const n = Math.sqrt(Rl[e] * Rl[e] - Rl[e - 1] * Rl[e - 1]),
            i = Dl[(e - 1) % Dl.length];

      this._blur(t, e - 1, e, n, i);
    }

    e.autoClear = n;
  },
  _blur: function (t, e, n, i, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(t, o, e, n, i, "latitudinal", r), this._halfBlur(o, t, n, n, i, "longitudinal", r);
  },
  _halfBlur: function (t, e, n, i, r, o, s) {
    const a = this._renderer,
          c = this._blurMaterial;
    "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
    const l = new Ee(Ll[i], c),
          u = c.uniforms,
          h = Cl[n] - 1,
          d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
          p = r / d,
          f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
    f > 20 && console.warn("sigmaRadians, ".concat(r, ", is too large and will clip, as it requested ").concat(f, " samples when the maximum is set to 20"));
    const m = [];
    let g = 0;

    for (let t = 0; t < 20; ++t) {
      const e = t / p,
            n = Math.exp(-e * e / 2);
      m.push(n), 0 == t ? g += n : t < f && (g += 2 * n);
    }

    for (let t = 0; t < m.length; t++) m[t] = m[t] / g;

    u.envMap.value = t.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === o, s && (u.poleAxis.value = s), u.dTheta.value = d, u.mipInt.value = 8 - n, u.inputEncoding.value = Tl[t.texture.encoding], u.outputEncoding.value = Tl[t.texture.encoding];
    const v = Cl[i];
    kl(e, 3 * Math.max(0, Ml - 2 * v), (0 === i ? 0 : 2 * Ml) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(l, Al);
  }
}, ra.create = function (t, e) {
  return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ra.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t;
}, Object.assign(Sa.prototype, {
  createPointsGeometry: function (t) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getPoints(t);
    return this.createGeometry(e);
  },
  createSpacedPointsGeometry: function (t) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = this.getSpacedPoints(t);
    return this.createGeometry(e);
  },
  createGeometry: function (t) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    const e = new Oe();

    for (let n = 0, i = t.length; n < i; n++) {
      const i = t[n];
      e.vertices.push(new m(i.x, i.y, i.z || 0));
    }

    return e;
  }
}), Object.assign(Ea.prototype, {
  fromPoints: function (t) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
  }
}), Object.create(da.prototype), Object.create(da.prototype), Ul.prototype = Object.create(da.prototype), Object.assign(Ul.prototype, {
  initFromArray: function () {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function () {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function () {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
}), rl.prototype.setColors = function () {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
}, Kc.prototype.update = function () {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
}, Object.assign(Zs.prototype, {
  extractUrlBase: function (t) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ga(t);
  }
}), Zs.Handlers = {
  add: function () {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function () {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
}, Object.assign(Xa.prototype, {
  setTexturePath: function (t) {
    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t);
  }
}), Object.assign(Gc.prototype, {
  center: function (t) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function () {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function (t) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  size: function (t) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t);
  }
}), Object.assign(nt.prototype, {
  center: function (t) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
  },
  empty: function () {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  },
  isIntersectionBox: function (t) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionSphere: function (t) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  },
  size: function (t) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
  }
}), Object.assign(ot.prototype, {
  empty: function () {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  }
}), We.prototype.setFromMatrix = function (t) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
}, Wc.prototype.center = function (t) {
  return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t);
}, Object.assign(n, {
  random16: function () {
    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
  },
  nearestPowerOfTwo: function (t) {
    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), n.floorPowerOfTwo(t);
  },
  nextPowerOfTwo: function (t) {
    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), n.ceilPowerOfTwo(t);
  }
}), Object.assign(r.prototype, {
  flattenToArrayOffset: function (t, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  multiplyVector3: function (t) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  multiplyVector3Array: function () {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBufferAttribute: function (t) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
  },
  applyToVector3Array: function () {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
}), Object.assign(M.prototype, {
  extractPosition: function (t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
  },
  flattenToArrayOffset: function (t, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e);
  },
  getPosition: function () {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new m().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function (t) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
  },
  multiplyToArray: function () {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function (t) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector4: function (t) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  multiplyVector3Array: function () {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function (t) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
  },
  crossVector: function (t) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  translate: function () {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function () {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function () {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function () {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function () {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBufferAttribute: function (t) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
  },
  applyToVector3Array: function () {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function (t, e, n, i, r, o) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o);
  }
}), vt.prototype.isIntersectionLine = function (t) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
}, d.prototype.multiplyVector3 = function (t) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
}, Object.assign(pt.prototype, {
  isIntersectionBox: function (t) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
  },
  isIntersectionPlane: function (t) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
  },
  isIntersectionSphere: function (t) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
  }
}), Object.assign(Lt.prototype, {
  area: function () {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  },
  barycoordFromPoint: function (t, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e);
  },
  midpoint: function (t) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
  },
  normal: function (t) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
  },
  plane: function (t) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
  }
}), Object.assign(Lt, {
  barycoordFromPoint: function (t, e, n, i, r) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Lt.getBarycoord(t, e, n, i, r);
  },
  normal: function (t, e, n, i) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Lt.getNormal(t, e, n, i);
  }
}), Object.assign(Ta.prototype, {
  extractAllPoints: function (t) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
  },
  extrude: function (t) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Qo(this, t);
  },
  makeGeometry: function (t) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ls(this, t);
  }
}), Object.assign(i.prototype, {
  fromAttribute: function (t, e, n) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function (t) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function () {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
}), Object.assign(m.prototype, {
  setEulerFromRotationMatrix: function () {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function () {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function (t) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
  },
  getScaleFromMatrix: function (t) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
  },
  getColumnFromMatrix: function (t, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t);
  },
  applyProjection: function (t) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
  },
  fromAttribute: function (t, e, n) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  distanceToManhattan: function (t) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
  },
  lengthManhattan: function () {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
}), Object.assign(l.prototype, {
  fromAttribute: function (t, e, n) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n);
  },
  lengthManhattan: function () {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  }
}), Object.assign(Oe.prototype, {
  computeTangents: function () {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function () {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  },
  applyMatrix: function (t) {
    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
}), Object.assign(U.prototype, {
  getChildByName: function (t) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
  },
  renderDepth: function () {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function (t, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t);
  },
  getWorldRotation: function () {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  },
  applyMatrix: function (t) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
}), Object.defineProperties(U.prototype, {
  eulerOrder: {
    get: function () {
      return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
    },
    set: function (t) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
    }
  },
  useQuaternion: {
    get: function () {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function () {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
}), Object.assign(Ee.prototype, {
  setDrawMode: function () {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  }
}), Object.defineProperties(Ee.prototype, {
  drawMode: {
    get: function () {
      return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
    },
    set: function () {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
}), Object.defineProperties(Er.prototype, {
  objects: {
    get: function () {
      return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
    }
  }
}), Object.defineProperty(Cr.prototype, "useVertexTexture", {
  get: function () {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function () {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
}), Tr.prototype.initBones = function () {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
}, Object.defineProperty(ra.prototype, "__arcLengthDivisions", {
  get: function () {
    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
  },
  set: function (t) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t;
  }
}), He.prototype.setLens = function (t, e) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t);
}, Object.defineProperties(Aa.prototype, {
  onlyShadow: {
    set: function () {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
    }
  },
  shadowCameraLeft: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
    }
  },
  shadowCameraRight: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
    }
  },
  shadowCameraTop: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
    }
  },
  shadowCameraBottom: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
    }
  },
  shadowCameraNear: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
    }
  },
  shadowCameraFar: {
    set: function (t) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
    }
  },
  shadowCameraVisible: {
    set: function () {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function (t) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
    }
  },
  shadowDarkness: {
    set: function () {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function (t) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
    }
  },
  shadowMapHeight: {
    set: function (t) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
    }
  }
}), Object.defineProperties(Gt.prototype, {
  length: {
    get: function () {
      return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
    }
  },
  dynamic: {
    get: function () {
      return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage;
    },
    set: function () {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
    }
  }
}), Object.assign(Gt.prototype, {
  setDynamic: function (t) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this;
  },
  copyIndicesArray: function () {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  },
  setArray: function () {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
}), Object.assign(ae.prototype, {
  addIndex: function (t) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
  },
  addAttribute: function (t, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Gt(arguments[1], arguments[2])));
  },
  addDrawCall: function (t, e, n) {
    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e);
  },
  clearDrawCalls: function () {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  },
  computeTangents: function () {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function () {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  },
  removeAttribute: function (t) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
  },
  applyMatrix: function (t) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
  }
}), Object.defineProperties(ae.prototype, {
  drawcalls: {
    get: function () {
      return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
    }
  },
  offsets: {
    get: function () {
      return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
    }
  }
}), Object.defineProperties(ja.prototype, {
  maxInstancedCount: {
    get: function () {
      return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
    },
    set: function (t) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t;
    }
  }
}), Object.defineProperties(Bc.prototype, {
  linePrecision: {
    get: function () {
      return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
    },
    set: function (t) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t;
    }
  }
}), Object.defineProperties(rr.prototype, {
  dynamic: {
    get: function () {
      return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage;
    },
    set: function (t) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t);
    }
  }
}), Object.assign(rr.prototype, {
  setDynamic: function (t) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this;
  },
  setArray: function () {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  }
}), Object.assign(Ko.prototype, {
  getArrays: function () {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function () {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function () {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
}), Object.defineProperties(Ic.prototype, {
  dynamic: {
    set: function () {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function () {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
    }
  }
}), Object.defineProperties(kt.prototype, {
  wrapAround: {
    get: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function () {
      return console.warn("THREE.Material: .wrapRGB has been removed."), new Ot();
    }
  },
  shading: {
    get: function () {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function (t) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t;
    }
  },
  stencilMask: {
    get: function () {
      return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
    },
    set: function (t) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
    }
  }
}), Object.defineProperties(Ss.prototype, {
  metal: {
    get: function () {
      return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1;
    },
    set: function () {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
}), Object.defineProperties(Be.prototype, {
  derivatives: {
    get: function () {
      return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
    },
    set: function (t) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
    }
  }
}), Object.assign(tr.prototype, {
  clearTarget: function (t, e, n, i) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i);
  },
  animate: function (t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
  },
  getCurrentRenderTarget: function () {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  },
  getMaxAnisotropy: function () {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function () {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  },
  resetGLState: function () {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  },
  supportsFloatTextures: function () {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function () {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function () {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function () {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function () {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function () {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function () {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function () {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function (t) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
  },
  initMaterial: function () {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function () {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function () {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function () {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function () {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  },
  allocTextureUnit: function () {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  },
  setTexture: function () {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  },
  setTexture2D: function () {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  },
  setTextureCube: function () {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  },
  getActiveMipMapLevel: function () {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  }
}), Object.defineProperties(tr.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
    }
  },
  shadowMapCullFace: {
    get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function () {
      return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
    }
  },
  vr: {
    get: function () {
      return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
    }
  },
  gammaInput: {
    get: function () {
      return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function () {
      return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? 3001 : 3e3;
    }
  },
  toneMappingWhitePoint: {
    get: function () {
      return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
}), Object.defineProperties(Wi.prototype, {
  cullFace: {
    get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
}), Object.defineProperties(u.prototype, {
  wrapS: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
    }
  },
  wrapT: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
    }
  },
  magFilter: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
    }
  },
  minFilter: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
    }
  },
  anisotropy: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
    }
  },
  offset: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
    }
  },
  repeat: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
    }
  },
  format: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
    }
  },
  type: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
    }
  },
  generateMipmaps: {
    get: function () {
      return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
    },
    set: function (t) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
    }
  }
}), Object.defineProperties(mc.prototype, {
  load: {
    value: function (t) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const e = this;
      return new rc().load(t, function (t) {
        e.setBuffer(t);
      }), this;
    }
  },
  startTime: {
    set: function () {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    }
  }
}), bc.prototype.getData = function () {
  return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
}, Fe.prototype.updateCubeMap = function (t, e) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e);
}, s.crossOrigin = void 0, s.loadTexture = function (t, e, n, i) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const r = new ia();
  r.setCrossOrigin(this.crossOrigin);
  const o = r.load(t, n, void 0, i);
  return e && (o.mapping = e), o;
}, s.loadTextureCube = function (t, e, n, i) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const r = new na();
  r.setCrossOrigin(this.crossOrigin);
  const o = r.load(t, n, void 0, i);
  return e && (o.mapping = e), o;
}, s.loadCompressedTexture = function () {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
}, s.loadCompressedTextureCube = function () {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
  detail: {
    revision: "118"
  }
}));

var Gl = function () {
  var t = 0,
      e = document.createElement("div");

  function n(t) {
    return e.appendChild(t.dom), t;
  }

  function i(n) {
    for (var i = 0; i < e.children.length; i++) e.children[i].style.display = i === n ? "block" : "none";

    t = n;
  }

  e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", function (n) {
    n.preventDefault(), i(++t % e.children.length);
  }, !1);
  var r = (performance || Date).now(),
      o = r,
      s = 0,
      a = n(new Gl.Panel("FPS", "#0ff", "#002")),
      c = n(new Gl.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory) var l = n(new Gl.Panel("MB", "#f08", "#201"));
  return i(0), {
    REVISION: 16,
    dom: e,
    addPanel: n,
    showPanel: i,
    begin: function () {
      r = (performance || Date).now();
    },
    end: function () {
      s++;
      var t = (performance || Date).now();

      if (c.update(t - r, 200), t >= o + 1e3 && (a.update(1e3 * s / (t - o), 100), o = t, s = 0, l)) {
        var e = performance.memory;
        l.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576);
      }

      return t;
    },
    update: function () {
      r = this.end();
    },
    domElement: e,
    setMode: i
  };
};

function jl(t, e) {
  var n = t.__state.conversionName.toString(),
      i = Math.round(t.r),
      r = Math.round(t.g),
      o = Math.round(t.b),
      s = t.a,
      a = Math.round(t.h),
      c = t.s.toFixed(1),
      l = t.v.toFixed(1);

  if (e || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
    for (var u = t.hex.toString(16); u.length < 6;) u = "0" + u;

    return "#" + u;
  }

  return "CSS_RGB" === n ? "rgb(" + i + "," + r + "," + o + ")" : "CSS_RGBA" === n ? "rgba(" + i + "," + r + "," + o + "," + s + ")" : "HEX" === n ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === n ? "[" + i + "," + r + "," + o + "]" : "RGBA_ARRAY" === n ? "[" + i + "," + r + "," + o + "," + s + "]" : "RGB_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + "}" : "RGBA_OBJ" === n ? "{r:" + i + ",g:" + r + ",b:" + o + ",a:" + s + "}" : "HSV_OBJ" === n ? "{h:" + a + ",s:" + c + ",v:" + l + "}" : "HSVA_OBJ" === n ? "{h:" + a + ",s:" + c + ",v:" + l + ",a:" + s + "}" : "unknown format";
}

Gl.Panel = function (t, e, n) {
  var i = 1 / 0,
      r = 0,
      o = Math.round,
      s = o(window.devicePixelRatio || 1),
      a = 80 * s,
      c = 48 * s,
      l = 3 * s,
      u = 2 * s,
      h = 3 * s,
      d = 15 * s,
      p = 74 * s,
      f = 30 * s,
      m = document.createElement("canvas");
  m.width = a, m.height = c, m.style.cssText = "width:80px;height:48px";
  var g = m.getContext("2d");
  return g.font = "bold " + 9 * s + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, a, c), g.fillStyle = e, g.fillText(t, l, u), g.fillRect(h, d, p, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h, d, p, f), {
    dom: m,
    update: function (c, v) {
      i = Math.min(i, c), r = Math.max(r, c), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, a, d), g.fillStyle = e, g.fillText(o(c) + " " + t + " (" + o(i) + "-" + o(r) + ")", l, u), g.drawImage(m, h + s, d, p - s, f, h, d, p - s, f), g.fillRect(h + p - s, d, s, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h + p - s, d, s, o((1 - c / v) * f));
    }
  };
};

var Vl = Array.prototype.forEach,
    Wl = Array.prototype.slice,
    ql = {
  BREAK: {},
  extend: function (t) {
    return this.each(Wl.call(arguments, 1), function (e) {
      (this.isObject(e) ? Object.keys(e) : []).forEach(function (n) {
        this.isUndefined(e[n]) || (t[n] = e[n]);
      }.bind(this));
    }, this), t;
  },
  defaults: function (t) {
    return this.each(Wl.call(arguments, 1), function (e) {
      (this.isObject(e) ? Object.keys(e) : []).forEach(function (n) {
        this.isUndefined(t[n]) && (t[n] = e[n]);
      }.bind(this));
    }, this), t;
  },
  compose: function () {
    var t = Wl.call(arguments);
    return function () {
      for (var e = Wl.call(arguments), n = t.length - 1; n >= 0; n--) e = [t[n].apply(this, e)];

      return e[0];
    };
  },
  each: function (t, e, n) {
    if (t) if (Vl && t.forEach && t.forEach === Vl) t.forEach(e, n);else if (t.length === t.length + 0) {
      var i,
          r = void 0;

      for (r = 0, i = t.length; r < i; r++) if (r in t && e.call(n, t[r], r) === this.BREAK) return;
    } else for (var o in t) if (e.call(n, t[o], o) === this.BREAK) return;
  },
  defer: function (t) {
    setTimeout(t, 0);
  },
  debounce: function (t, e, n) {
    var i = void 0;
    return function () {
      var r = this,
          o = arguments;

      function s() {
        i = null, n || t.apply(r, o);
      }

      var a = n || !i;
      clearTimeout(i), i = setTimeout(s, e), a && t.apply(r, o);
    };
  },
  toArray: function (t) {
    return t.toArray ? t.toArray() : Wl.call(t);
  },
  isUndefined: function (t) {
    return void 0 === t;
  },
  isNull: function (t) {
    return null === t;
  },
  isNaN: function (t) {
    function e() {
      return t.apply(this, arguments);
    }

    return e.toString = function () {
      return t.toString();
    }, e;
  }(function (t) {
    return isNaN(t);
  }),
  isArray: Array.isArray || function (t) {
    return t.constructor === Array;
  },
  isObject: function (t) {
    return t === Object(t);
  },
  isNumber: function (t) {
    return t === t + 0;
  },
  isString: function (t) {
    return t === t + "";
  },
  isBoolean: function (t) {
    return !1 === t || !0 === t;
  },
  isFunction: function (t) {
    return t instanceof Function;
  }
},
    Xl = [{
  litmus: ql.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function (t) {
        var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        return null !== e && {
          space: "HEX",
          hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
        };
      },
      write: jl
    },
    SIX_CHAR_HEX: {
      read: function (t) {
        var e = t.match(/^#([A-F0-9]{6})$/i);
        return null !== e && {
          space: "HEX",
          hex: parseInt("0x" + e[1].toString(), 0)
        };
      },
      write: jl
    },
    CSS_RGB: {
      read: function (t) {
        var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        return null !== e && {
          space: "RGB",
          r: parseFloat(e[1]),
          g: parseFloat(e[2]),
          b: parseFloat(e[3])
        };
      },
      write: jl
    },
    CSS_RGBA: {
      read: function (t) {
        var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        return null !== e && {
          space: "RGB",
          r: parseFloat(e[1]),
          g: parseFloat(e[2]),
          b: parseFloat(e[3]),
          a: parseFloat(e[4])
        };
      },
      write: jl
    }
  }
}, {
  litmus: ql.isNumber,
  conversions: {
    HEX: {
      read: function (t) {
        return {
          space: "HEX",
          hex: t,
          conversionName: "HEX"
        };
      },
      write: function (t) {
        return t.hex;
      }
    }
  }
}, {
  litmus: ql.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function (t) {
        return 3 === t.length && {
          space: "RGB",
          r: t[0],
          g: t[1],
          b: t[2]
        };
      },
      write: function (t) {
        return [t.r, t.g, t.b];
      }
    },
    RGBA_ARRAY: {
      read: function (t) {
        return 4 === t.length && {
          space: "RGB",
          r: t[0],
          g: t[1],
          b: t[2],
          a: t[3]
        };
      },
      write: function (t) {
        return [t.r, t.g, t.b, t.a];
      }
    }
  }
}, {
  litmus: ql.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function (t) {
        return !!(ql.isNumber(t.r) && ql.isNumber(t.g) && ql.isNumber(t.b) && ql.isNumber(t.a)) && {
          space: "RGB",
          r: t.r,
          g: t.g,
          b: t.b,
          a: t.a
        };
      },
      write: function (t) {
        return {
          r: t.r,
          g: t.g,
          b: t.b,
          a: t.a
        };
      }
    },
    RGB_OBJ: {
      read: function (t) {
        return !!(ql.isNumber(t.r) && ql.isNumber(t.g) && ql.isNumber(t.b)) && {
          space: "RGB",
          r: t.r,
          g: t.g,
          b: t.b
        };
      },
      write: function (t) {
        return {
          r: t.r,
          g: t.g,
          b: t.b
        };
      }
    },
    HSVA_OBJ: {
      read: function (t) {
        return !!(ql.isNumber(t.h) && ql.isNumber(t.s) && ql.isNumber(t.v) && ql.isNumber(t.a)) && {
          space: "HSV",
          h: t.h,
          s: t.s,
          v: t.v,
          a: t.a
        };
      },
      write: function (t) {
        return {
          h: t.h,
          s: t.s,
          v: t.v,
          a: t.a
        };
      }
    },
    HSV_OBJ: {
      read: function (t) {
        return !!(ql.isNumber(t.h) && ql.isNumber(t.s) && ql.isNumber(t.v)) && {
          space: "HSV",
          h: t.h,
          s: t.s,
          v: t.v
        };
      },
      write: function (t) {
        return {
          h: t.h,
          s: t.s,
          v: t.v
        };
      }
    }
  }
}],
    Yl = void 0,
    Zl = void 0,
    Jl = function () {
  Zl = !1;
  var t = arguments.length > 1 ? ql.toArray(arguments) : arguments[0];
  return ql.each(Xl, function (e) {
    if (e.litmus(t)) return ql.each(e.conversions, function (e, n) {
      if (Yl = e.read(t), !1 === Zl && !1 !== Yl) return Zl = Yl, Yl.conversionName = n, Yl.conversion = e, ql.BREAK;
    }), ql.BREAK;
  }), Zl;
},
    Ql = void 0,
    Kl = {
  hsv_to_rgb: function (t, e, n) {
    var i = Math.floor(t / 60) % 6,
        r = t / 60 - Math.floor(t / 60),
        o = n * (1 - e),
        s = n * (1 - r * e),
        a = n * (1 - (1 - r) * e),
        c = [[n, a, o], [s, n, o], [o, n, a], [o, s, n], [a, o, n], [n, o, s]][i];
    return {
      r: 255 * c[0],
      g: 255 * c[1],
      b: 255 * c[2]
    };
  },
  rgb_to_hsv: function (t, e, n) {
    var i = Math.min(t, e, n),
        r = Math.max(t, e, n),
        o = r - i,
        s = void 0;
    return 0 === r ? {
      h: NaN,
      s: 0,
      v: 0
    } : (s = t === r ? (e - n) / o : e === r ? 2 + (n - t) / o : 4 + (t - e) / o, (s /= 6) < 0 && (s += 1), {
      h: 360 * s,
      s: o / r,
      v: r / 255
    });
  },
  rgb_to_hex: function (t, e, n) {
    var i = this.hex_with_component(0, 2, t);
    return i = this.hex_with_component(i, 1, e), this.hex_with_component(i, 0, n);
  },
  component_from_hex: function (t, e) {
    return t >> 8 * e & 255;
  },
  hex_with_component: function (t, e, n) {
    return n << (Ql = 8 * e) | t & ~(255 << Ql);
  }
},
    $l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
  return typeof t;
} : function (t) {
  return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
},
    tu = function (t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
},
    eu = function () {
  function t(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
    }
  }

  return function (e, n, i) {
    return n && t(e.prototype, n), i && t(e, i), e;
  };
}(),
    nu = function t(e, n, i) {
  null === e && (e = Function.prototype);
  var r = Object.getOwnPropertyDescriptor(e, n);

  if (void 0 === r) {
    var o = Object.getPrototypeOf(e);
    return null === o ? void 0 : t(o, n, i);
  }

  if ("value" in r) return r.value;
  var s = r.get;
  return void 0 !== s ? s.call(i) : void 0;
},
    iu = function (t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
},
    ru = function (t, e) {
  if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return !e || "object" != typeof e && "function" != typeof e ? t : e;
},
    ou = function () {
  function t() {
    if (tu(this, t), this.__state = Jl.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
    this.__state.a = this.__state.a || 1;
  }

  return eu(t, [{
    key: "toString",
    value: function () {
      return jl(this);
    }
  }, {
    key: "toHexString",
    value: function () {
      return jl(this, !0);
    }
  }, {
    key: "toOriginal",
    value: function () {
      return this.__state.conversion.write(this);
    }
  }]), t;
}();

function su(t, e, n) {
  Object.defineProperty(t, e, {
    get: function () {
      return "RGB" === this.__state.space || ou.recalculateRGB(this, e, n), this.__state[e];
    },
    set: function (t) {
      "RGB" !== this.__state.space && (ou.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = t;
    }
  });
}

function au(t, e) {
  Object.defineProperty(t, e, {
    get: function () {
      return "HSV" === this.__state.space || ou.recalculateHSV(this), this.__state[e];
    },
    set: function (t) {
      "HSV" !== this.__state.space && (ou.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t;
    }
  });
}

ou.recalculateRGB = function (t, e, n) {
  if ("HEX" === t.__state.space) t.__state[e] = Kl.component_from_hex(t.__state.hex, n);else {
    if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
    ql.extend(t.__state, Kl.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v));
  }
}, ou.recalculateHSV = function (t) {
  var e = Kl.rgb_to_hsv(t.r, t.g, t.b);
  ql.extend(t.__state, {
    s: e.s,
    v: e.v
  }), ql.isNaN(e.h) ? ql.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h;
}, ou.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], su(ou.prototype, "r", 2), su(ou.prototype, "g", 1), su(ou.prototype, "b", 0), au(ou.prototype, "h"), au(ou.prototype, "s"), au(ou.prototype, "v"), Object.defineProperty(ou.prototype, "a", {
  get: function () {
    return this.__state.a;
  },
  set: function (t) {
    this.__state.a = t;
  }
}), Object.defineProperty(ou.prototype, "hex", {
  get: function () {
    return "HEX" !== this.__state.space && (this.__state.hex = Kl.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
  },
  set: function (t) {
    this.__state.space = "HEX", this.__state.hex = t;
  }
});

var cu = function () {
  function t(e, n) {
    tu(this, t), this.initialValue = e[n], this.domElement = document.createElement("div"), this.object = e, this.property = n, this.__onChange = void 0, this.__onFinishChange = void 0;
  }

  return eu(t, [{
    key: "onChange",
    value: function (t) {
      return this.__onChange = t, this;
    }
  }, {
    key: "onFinishChange",
    value: function (t) {
      return this.__onFinishChange = t, this;
    }
  }, {
    key: "setValue",
    value: function (t) {
      return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this;
    }
  }, {
    key: "getValue",
    value: function () {
      return this.object[this.property];
    }
  }, {
    key: "updateDisplay",
    value: function () {
      return this;
    }
  }, {
    key: "isModified",
    value: function () {
      return this.initialValue !== this.getValue();
    }
  }]), t;
}(),
    lu = {};

ql.each({
  HTMLEvents: ["change"],
  MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
  KeyboardEvents: ["keydown"]
}, function (t, e) {
  ql.each(t, function (t) {
    lu[t] = e;
  });
});
var uu = /(\d+(\.\d+)?)px/;

function hu(t) {
  if ("0" === t || ql.isUndefined(t)) return 0;
  var e = t.match(uu);
  return ql.isNull(e) ? 0 : parseFloat(e[1]);
}

var du = {
  makeSelectable: function (t, e) {
    void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function () {
      return !1;
    } : function () {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off");
  },
  makeFullscreen: function (t, e, n) {
    var i = n,
        r = e;
    ql.isUndefined(r) && (r = !0), ql.isUndefined(i) && (i = !0), t.style.position = "absolute", r && (t.style.left = 0, t.style.right = 0), i && (t.style.top = 0, t.style.bottom = 0);
  },
  fakeEvent: function (t, e, n, i) {
    var r = n || {},
        o = lu[e];
    if (!o) throw new Error("Event type " + e + " not supported.");
    var s = document.createEvent(o);

    switch (o) {
      case "MouseEvents":
        var a = r.x || r.clientX || 0,
            c = r.y || r.clientY || 0;
        s.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, a, c, !1, !1, !1, !1, 0, null);
        break;

      case "KeyboardEvents":
        var l = s.initKeyboardEvent || s.initKeyEvent;
        ql.defaults(r, {
          cancelable: !0,
          ctrlKey: !1,
          altKey: !1,
          shiftKey: !1,
          metaKey: !1,
          keyCode: void 0,
          charCode: void 0
        }), l(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
        break;

      default:
        s.initEvent(e, r.bubbles || !1, r.cancelable || !0);
    }

    ql.defaults(s, i), t.dispatchEvent(s);
  },
  bind: function (t, e, n, i) {
    var r = i || !1;
    return t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on" + e, n), du;
  },
  unbind: function (t, e, n, i) {
    var r = i || !1;
    return t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on" + e, n), du;
  },
  addClass: function (t, e) {
    if (void 0 === t.className) t.className = e;else if (t.className !== e) {
      var n = t.className.split(/ +/);
      -1 === n.indexOf(e) && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
    }
    return du;
  },
  removeClass: function (t, e) {
    if (e) {
      if (t.className === e) t.removeAttribute("class");else {
        var n = t.className.split(/ +/),
            i = n.indexOf(e);
        -1 !== i && (n.splice(i, 1), t.className = n.join(" "));
      }
    } else t.className = void 0;
    return du;
  },
  hasClass: function (t, e) {
    return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1;
  },
  getWidth: function (t) {
    var e = getComputedStyle(t);
    return hu(e["border-left-width"]) + hu(e["border-right-width"]) + hu(e["padding-left"]) + hu(e["padding-right"]) + hu(e.width);
  },
  getHeight: function (t) {
    var e = getComputedStyle(t);
    return hu(e["border-top-width"]) + hu(e["border-bottom-width"]) + hu(e["padding-top"]) + hu(e["padding-bottom"]) + hu(e.height);
  },
  getOffset: function (t) {
    var e = t,
        n = {
      left: 0,
      top: 0
    };
    if (e.offsetParent) do {
      n.left += e.offsetLeft, n.top += e.offsetTop, e = e.offsetParent;
    } while (e);
    return n;
  },
  isActive: function (t) {
    return t === document.activeElement && (t.type || t.href);
  }
},
    pu = function (t) {
  function e(t, n) {
    tu(this, e);
    var i = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
        r = i;
    return i.__prev = i.getValue(), i.__checkbox = document.createElement("input"), i.__checkbox.setAttribute("type", "checkbox"), du.bind(i.__checkbox, "change", function () {
      r.setValue(!r.__prev);
    }, !1), i.domElement.appendChild(i.__checkbox), i.updateDisplay(), i;
  }

  return iu(e, cu), eu(e, [{
    key: "setValue",
    value: function (t) {
      var n = nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n;
    }
  }, {
    key: "updateDisplay",
    value: function () {
      return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(),
    fu = function (t) {
  function e(t, n, i) {
    tu(this, e);
    var r = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
        o = i,
        s = r;

    if (r.__select = document.createElement("select"), ql.isArray(o)) {
      var a = {};
      ql.each(o, function (t) {
        a[t] = t;
      }), o = a;
    }

    return ql.each(o, function (t, e) {
      var n = document.createElement("option");
      n.innerHTML = e, n.setAttribute("value", t), s.__select.appendChild(n);
    }), r.updateDisplay(), du.bind(r.__select, "change", function () {
      var t = this.options[this.selectedIndex].value;
      s.setValue(t);
    }), r.domElement.appendChild(r.__select), r;
  }

  return iu(e, cu), eu(e, [{
    key: "setValue",
    value: function (t) {
      var n = nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
      return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n;
    }
  }, {
    key: "updateDisplay",
    value: function () {
      return du.isActive(this.__select) ? this : (this.__select.value = this.getValue(), nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this));
    }
  }]), e;
}(),
    mu = function (t) {
  function e(t, n) {
    tu(this, e);
    var i = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
        r = i;

    function o() {
      r.setValue(r.__input.value);
    }

    return i.__input = document.createElement("input"), i.__input.setAttribute("type", "text"), du.bind(i.__input, "keyup", o), du.bind(i.__input, "change", o), du.bind(i.__input, "blur", function () {
      r.__onFinishChange && r.__onFinishChange.call(r, r.getValue());
    }), du.bind(i.__input, "keydown", function (t) {
      13 === t.keyCode && this.blur();
    }), i.updateDisplay(), i.domElement.appendChild(i.__input), i;
  }

  return iu(e, cu), eu(e, [{
    key: "updateDisplay",
    value: function () {
      return du.isActive(this.__input) || (this.__input.value = this.getValue()), nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}();

function gu(t) {
  var e = t.toString();
  return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
}

var vu = function (t) {
  function e(t, n, i) {
    tu(this, e);
    var r = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
        o = i || {};
    return r.__min = o.min, r.__max = o.max, r.__step = o.step, ql.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = gu(r.__impliedStep), r;
  }

  return iu(e, cu), eu(e, [{
    key: "setValue",
    value: function (t) {
      var n = t;
      return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step != 0 && (n = Math.round(n / this.__step) * this.__step), nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, n);
    }
  }, {
    key: "min",
    value: function (t) {
      return this.__min = t, this;
    }
  }, {
    key: "max",
    value: function (t) {
      return this.__max = t, this;
    }
  }, {
    key: "step",
    value: function (t) {
      return this.__step = t, this.__impliedStep = t, this.__precision = gu(t), this;
    }
  }]), e;
}(),
    yu = function (t) {
  function e(t, n, i) {
    tu(this, e);
    var r = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, i));
    r.__truncationSuspended = !1;
    var o = r,
        s = void 0;

    function a() {
      o.__onFinishChange && o.__onFinishChange.call(o, o.getValue());
    }

    function c(t) {
      var e = s - t.clientY;
      o.setValue(o.getValue() + e * o.__impliedStep), s = t.clientY;
    }

    function l() {
      du.unbind(window, "mousemove", c), du.unbind(window, "mouseup", l), a();
    }

    return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), du.bind(r.__input, "change", function () {
      var t = parseFloat(o.__input.value);
      ql.isNaN(t) || o.setValue(t);
    }), du.bind(r.__input, "blur", function () {
      a();
    }), du.bind(r.__input, "mousedown", function (t) {
      du.bind(window, "mousemove", c), du.bind(window, "mouseup", l), s = t.clientY;
    }), du.bind(r.__input, "keydown", function (t) {
      13 === t.keyCode && (o.__truncationSuspended = !0, this.blur(), o.__truncationSuspended = !1, a());
    }), r.updateDisplay(), r.domElement.appendChild(r.__input), r;
  }

  return iu(e, vu), eu(e, [{
    key: "updateDisplay",
    value: function () {
      var t, n, i;
      return this.__input.value = this.__truncationSuspended ? this.getValue() : (t = this.getValue(), n = this.__precision, i = Math.pow(10, n), Math.round(t * i) / i), nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}();

function xu(t, e, n, i, r) {
  return i + (t - e) / (n - e) * (r - i);
}

var _u = function (t) {
  function e(t, n, i, r, o) {
    tu(this, e);
    var s = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
      min: i,
      max: r,
      step: o
    })),
        a = s;

    function c(t) {
      t.preventDefault();

      var e = a.__background.getBoundingClientRect();

      return a.setValue(xu(t.clientX, e.left, e.right, a.__min, a.__max)), !1;
    }

    function l() {
      du.unbind(window, "mousemove", c), du.unbind(window, "mouseup", l), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
    }

    function u(t) {
      var e = t.touches[0].clientX,
          n = a.__background.getBoundingClientRect();

      a.setValue(xu(e, n.left, n.right, a.__min, a.__max));
    }

    function h() {
      du.unbind(window, "touchmove", u), du.unbind(window, "touchend", h), a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
    }

    return s.__background = document.createElement("div"), s.__foreground = document.createElement("div"), du.bind(s.__background, "mousedown", function (t) {
      document.activeElement.blur(), du.bind(window, "mousemove", c), du.bind(window, "mouseup", l), c(t);
    }), du.bind(s.__background, "touchstart", function (t) {
      1 === t.touches.length && (du.bind(window, "touchmove", u), du.bind(window, "touchend", h), u(t));
    }), du.addClass(s.__background, "slider"), du.addClass(s.__foreground, "slider-fg"), s.updateDisplay(), s.__background.appendChild(s.__foreground), s.domElement.appendChild(s.__background), s;
  }

  return iu(e, vu), eu(e, [{
    key: "updateDisplay",
    value: function () {
      var t = (this.getValue() - this.__min) / (this.__max - this.__min);

      return this.__foreground.style.width = 100 * t + "%", nu(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this);
    }
  }]), e;
}(),
    bu = function (t) {
  function e(t, n, i) {
    tu(this, e);
    var r = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)),
        o = r;
    return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === i ? "Fire" : i, du.bind(r.__button, "click", function (t) {
      return t.preventDefault(), o.fire(), !1;
    }), du.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r;
  }

  return iu(e, cu), eu(e, [{
    key: "fire",
    value: function () {
      this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
    }
  }]), e;
}(),
    wu = function (t) {
  function e(t, n) {
    tu(this, e);
    var i = ru(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n));
    i.__color = new ou(i.getValue()), i.__temp = new ou(0);
    var r = i;
    i.domElement = document.createElement("div"), du.makeSelectable(i.domElement, !1), i.__selector = document.createElement("div"), i.__selector.className = "selector", i.__saturation_field = document.createElement("div"), i.__saturation_field.className = "saturation-field", i.__field_knob = document.createElement("div"), i.__field_knob.className = "field-knob", i.__field_knob_border = "2px solid ", i.__hue_knob = document.createElement("div"), i.__hue_knob.className = "hue-knob", i.__hue_field = document.createElement("div"), i.__hue_field.className = "hue-field", i.__input = document.createElement("input"), i.__input.type = "text", i.__input_textShadow = "0 1px 1px ", du.bind(i.__input, "keydown", function (t) {
      13 === t.keyCode && h.call(this);
    }), du.bind(i.__input, "blur", h), du.bind(i.__selector, "mousedown", function () {
      du.addClass(this, "drag").bind(window, "mouseup", function () {
        du.removeClass(r.__selector, "drag");
      });
    }), du.bind(i.__selector, "touchstart", function () {
      du.addClass(this, "drag").bind(window, "touchend", function () {
        du.removeClass(r.__selector, "drag");
      });
    });
    var o,
        s = document.createElement("div");

    function a(t) {
      p(t), du.bind(window, "mousemove", p), du.bind(window, "touchmove", p), du.bind(window, "mouseup", l), du.bind(window, "touchend", l);
    }

    function c(t) {
      f(t), du.bind(window, "mousemove", f), du.bind(window, "touchmove", f), du.bind(window, "mouseup", u), du.bind(window, "touchend", u);
    }

    function l() {
      du.unbind(window, "mousemove", p), du.unbind(window, "touchmove", p), du.unbind(window, "mouseup", l), du.unbind(window, "touchend", l), d();
    }

    function u() {
      du.unbind(window, "mousemove", f), du.unbind(window, "touchmove", f), du.unbind(window, "mouseup", u), du.unbind(window, "touchend", u), d();
    }

    function h() {
      var t = Jl(this.value);
      !1 !== t ? (r.__color.__state = t, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString();
    }

    function d() {
      r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal());
    }

    function p(t) {
      -1 === t.type.indexOf("touch") && t.preventDefault();

      var e = r.__saturation_field.getBoundingClientRect(),
          n = t.touches && t.touches[0] || t,
          i = n.clientX,
          o = n.clientY,
          s = (i - e.left) / (e.right - e.left),
          a = 1 - (o - e.top) / (e.bottom - e.top);

      return a > 1 ? a = 1 : a < 0 && (a = 0), s > 1 ? s = 1 : s < 0 && (s = 0), r.__color.v = a, r.__color.s = s, r.setValue(r.__color.toOriginal()), !1;
    }

    function f(t) {
      -1 === t.type.indexOf("touch") && t.preventDefault();

      var e = r.__hue_field.getBoundingClientRect(),
          n = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);

      return n > 1 ? n = 1 : n < 0 && (n = 0), r.__color.h = 360 * n, r.setValue(r.__color.toOriginal()), !1;
    }

    return ql.extend(i.__selector.style, {
      width: "122px",
      height: "102px",
      padding: "3px",
      backgroundColor: "#222",
      boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
    }), ql.extend(i.__field_knob.style, {
      position: "absolute",
      width: "12px",
      height: "12px",
      border: i.__field_knob_border + (i.__color.v < .5 ? "#fff" : "#000"),
      boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
      borderRadius: "12px",
      zIndex: 1
    }), ql.extend(i.__hue_knob.style, {
      position: "absolute",
      width: "15px",
      height: "2px",
      borderRight: "4px solid #fff",
      zIndex: 1
    }), ql.extend(i.__saturation_field.style, {
      width: "100px",
      height: "100px",
      border: "1px solid #555",
      marginRight: "3px",
      display: "inline-block",
      cursor: "pointer"
    }), ql.extend(s.style, {
      width: "100%",
      height: "100%",
      background: "none"
    }), Su(s, "top", "rgba(0,0,0,0)", "#000"), ql.extend(i.__hue_field.style, {
      width: "15px",
      height: "100px",
      border: "1px solid #555",
      cursor: "ns-resize",
      position: "absolute",
      top: "3px",
      right: "3px"
    }), (o = i.__hue_field).style.background = "", o.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", o.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", ql.extend(i.__input.style, {
      outline: "none",
      textAlign: "center",
      color: "#fff",
      border: 0,
      fontWeight: "bold",
      textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)"
    }), du.bind(i.__saturation_field, "mousedown", a), du.bind(i.__saturation_field, "touchstart", a), du.bind(i.__field_knob, "mousedown", a), du.bind(i.__field_knob, "touchstart", a), du.bind(i.__hue_field, "mousedown", c), du.bind(i.__hue_field, "touchstart", c), i.__saturation_field.appendChild(s), i.__selector.appendChild(i.__field_knob), i.__selector.appendChild(i.__saturation_field), i.__selector.appendChild(i.__hue_field), i.__hue_field.appendChild(i.__hue_knob), i.domElement.appendChild(i.__input), i.domElement.appendChild(i.__selector), i.updateDisplay(), i;
  }

  return iu(e, cu), eu(e, [{
    key: "updateDisplay",
    value: function () {
      var t = Jl(this.getValue());

      if (!1 !== t) {
        var e = !1;
        ql.each(ou.COMPONENTS, function (n) {
          if (!ql.isUndefined(t[n]) && !ql.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n]) return e = !0, {};
        }, this), e && ql.extend(this.__color.__state, t);
      }

      ql.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
      var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
          i = 255 - n;
      ql.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + "px",
        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
      }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, Su(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), ql.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: "rgb(" + n + "," + n + "," + n + ")",
        textShadow: this.__input_textShadow + "rgba(" + i + "," + i + "," + i + ",.7)"
      });
    }
  }]), e;
}(),
    Mu = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

function Su(t, e, n, i) {
  t.style.background = "", ql.each(Mu, function (r) {
    t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + n + " 0%, " + i + " 100%); ";
  });
}

var Eu = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
    Tu = function (t, e) {
  var n = t[e];
  return ql.isArray(arguments[2]) || ql.isObject(arguments[2]) ? new fu(t, e, arguments[2]) : ql.isNumber(n) ? ql.isNumber(arguments[2]) && ql.isNumber(arguments[3]) ? ql.isNumber(arguments[4]) ? new _u(t, e, arguments[2], arguments[3], arguments[4]) : new _u(t, e, arguments[2], arguments[3]) : ql.isNumber(arguments[4]) ? new yu(t, e, {
    min: arguments[2],
    max: arguments[3],
    step: arguments[4]
  }) : new yu(t, e, {
    min: arguments[2],
    max: arguments[3]
  }) : ql.isString(n) ? new mu(t, e) : ql.isFunction(n) ? new bu(t, e, "") : ql.isBoolean(n) ? new pu(t, e) : null;
},
    Au = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
  setTimeout(t, 1e3 / 60);
},
    Lu = function () {
  function t() {
    tu(this, t), this.backgroundElement = document.createElement("div"), ql.extend(this.backgroundElement.style, {
      backgroundColor: "rgba(0,0,0,0.8)",
      top: 0,
      left: 0,
      display: "none",
      zIndex: "1000",
      opacity: 0,
      WebkitTransition: "opacity 0.2s linear",
      transition: "opacity 0.2s linear"
    }), du.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), ql.extend(this.domElement.style, {
      position: "fixed",
      display: "none",
      zIndex: "1001",
      opacity: 0,
      WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
      transition: "transform 0.2s ease-out, opacity 0.2s linear"
    }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
    var e = this;
    du.bind(this.backgroundElement, "click", function () {
      e.hide();
    });
  }

  return eu(t, [{
    key: "show",
    value: function () {
      var t = this;
      this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), ql.defer(function () {
        t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)";
      });
    }
  }, {
    key: "hide",
    value: function () {
      var t = this,
          e = function e() {
        t.domElement.style.display = "none", t.backgroundElement.style.display = "none", du.unbind(t.domElement, "webkitTransitionEnd", e), du.unbind(t.domElement, "transitionend", e), du.unbind(t.domElement, "oTransitionEnd", e);
      };

      du.bind(this.domElement, "webkitTransitionEnd", e), du.bind(this.domElement, "transitionend", e), du.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
    }
  }, {
    key: "layout",
    value: function () {
      this.domElement.style.left = window.innerWidth / 2 - du.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - du.getHeight(this.domElement) / 2 + "px";
    }
  }]), t;
}();

!function (t, e) {
  var n = e || document,
      i = document.createElement("style");
  i.type = "text/css", i.innerHTML = t;
  var r = n.getElementsByTagName("head")[0];

  try {
    r.appendChild(i);
  } catch (t) {}
}(function (t) {
  if ("undefined" != typeof window) {
    var e = document.createElement("style");
    return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t;
  }
}(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));

var Cu = function () {
  try {
    return !!window.localStorage;
  } catch (t) {
    return !1;
  }
}(),
    Ru = void 0,
    Pu = !0,
    Ou = void 0,
    Nu = !1,
    Du = [],
    Iu = function t(e) {
  var n = this,
      i = e || {};
  this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), du.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], i = ql.defaults(i, {
    closeOnTop: !1,
    autoPlace: !0,
    width: t.DEFAULT_WIDTH
  }), i = ql.defaults(i, {
    resizable: i.autoPlace,
    hideable: i.autoPlace
  }), ql.isUndefined(i.load) ? i.load = {
    preset: "Default"
  } : i.preset && (i.load.preset = i.preset), ql.isUndefined(i.parent) && i.hideable && Du.push(this), i.resizable = ql.isUndefined(i.parent) && i.resizable, i.autoPlace && ql.isUndefined(i.scrollable) && (i.scrollable = !0);
  var r,
      o = Cu && "true" === localStorage.getItem(Uu(this, "isLocal")),
      s = void 0,
      a = void 0;

  if (Object.defineProperties(this, {
    parent: {
      get: function () {
        return i.parent;
      }
    },
    scrollable: {
      get: function () {
        return i.scrollable;
      }
    },
    autoPlace: {
      get: function () {
        return i.autoPlace;
      }
    },
    closeOnTop: {
      get: function () {
        return i.closeOnTop;
      }
    },
    preset: {
      get: function () {
        return n.parent ? n.getRoot().preset : i.load.preset;
      },
      set: function (t) {
        n.parent ? n.getRoot().preset = t : i.load.preset = t, function (t) {
          for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e);
        }(this), n.revert();
      }
    },
    width: {
      get: function () {
        return i.width;
      },
      set: function (t) {
        i.width = t, Wu(n, t);
      }
    },
    name: {
      get: function () {
        return i.name;
      },
      set: function (t) {
        i.name = t, a && (a.innerHTML = i.name);
      }
    },
    closed: {
      get: function () {
        return i.closed;
      },
      set: function (e) {
        i.closed = e, i.closed ? du.addClass(n.__ul, t.CLASS_CLOSED) : du.removeClass(n.__ul, t.CLASS_CLOSED), this.onResize(), n.__closeButton && (n.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED);
      }
    },
    load: {
      get: function () {
        return i.load;
      }
    },
    useLocalStorage: {
      get: function () {
        return o;
      },
      set: function (t) {
        Cu && (o = t, t ? du.bind(window, "unload", s) : du.unbind(window, "unload", s), localStorage.setItem(Uu(n, "isLocal"), t));
      }
    }
  }), ql.isUndefined(i.parent)) {
    if (this.closed = i.closed || !1, du.addClass(this.domElement, t.CLASS_MAIN), du.makeSelectable(this.domElement, !1), Cu && o) {
      n.useLocalStorage = !0;
      var c = localStorage.getItem(Uu(this, "gui"));
      c && (i.load = JSON.parse(c));
    }

    this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, du.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), i.closeOnTop ? (du.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (du.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), du.bind(this.__closeButton, "click", function () {
      n.closed = !n.closed;
    });
  } else {
    void 0 === i.closed && (i.closed = !0);
    var l = document.createTextNode(i.name);
    du.addClass(l, "controller-name"), a = zu(n, l), du.addClass(this.__ul, t.CLASS_CLOSED), du.addClass(a, "title"), du.bind(a, "click", function (t) {
      return t.preventDefault(), n.closed = !n.closed, !1;
    }), i.closed || (this.closed = !1);
  }

  i.autoPlace && (ql.isUndefined(i.parent) && (Pu && (Ou = document.createElement("div"), du.addClass(Ou, "dg"), du.addClass(Ou, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Ou), Pu = !1), Ou.appendChild(this.domElement), du.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || Wu(n, i.width)), this.__resizeHandler = function () {
    n.onResizeDebounced();
  }, du.bind(window, "resize", this.__resizeHandler), du.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), du.bind(this.__ul, "transitionend", this.__resizeHandler), du.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), i.resizable && function (t) {
    var e = void 0;

    function n(n) {
      return n.preventDefault(), t.width += e - n.clientX, t.onResize(), e = n.clientX, !1;
    }

    function i() {
      du.removeClass(t.__closeButton, Iu.CLASS_DRAG), du.unbind(window, "mousemove", n), du.unbind(window, "mouseup", i);
    }

    function r(r) {
      return r.preventDefault(), e = r.clientX, du.addClass(t.__closeButton, Iu.CLASS_DRAG), du.bind(window, "mousemove", n), du.bind(window, "mouseup", i), !1;
    }

    t.__resize_handle = document.createElement("div"), ql.extend(t.__resize_handle.style, {
      width: "6px",
      marginLeft: "-3px",
      height: "200px",
      cursor: "ew-resize",
      position: "absolute"
    }), du.bind(t.__resize_handle, "mousedown", r), du.bind(t.__closeButton, "mousedown", r), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild);
  }(this), s = function () {
    Cu && "true" === localStorage.getItem(Uu(n, "isLocal")) && localStorage.setItem(Uu(n, "gui"), JSON.stringify(n.getSaveObject()));
  }, this.saveToLocalStorageIfPossible = s, i.parent || ((r = n.getRoot()).width += 1, ql.defer(function () {
    r.width -= 1;
  }));
};

function zu(t, e, n) {
  var i = document.createElement("li");
  return e && i.appendChild(e), n ? t.__ul.insertBefore(i, n) : t.__ul.appendChild(i), t.onResize(), i;
}

function Bu(t) {
  du.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && du.unbind(window, "unload", t.saveToLocalStorageIfPossible);
}

function ku(t, e) {
  var n = t.__preset_select[t.__preset_select.selectedIndex];
  n.innerHTML = e ? n.value + "*" : n.value;
}

function Hu(t, e) {
  var n = t.getRoot(),
      i = n.__rememberedObjects.indexOf(e.object);

  if (-1 !== i) {
    var r = n.__rememberedObjectIndecesToControllers[i];

    if (void 0 === r && (r = {}, n.__rememberedObjectIndecesToControllers[i] = r), r[e.property] = e, n.load && n.load.remembered) {
      var o = n.load.remembered,
          s = void 0;
      if (o[t.preset]) s = o[t.preset];else {
        if (!o.Default) return;
        s = o.Default;
      }

      if (s[i] && void 0 !== s[i][e.property]) {
        var a = s[i][e.property];
        e.initialValue = a, e.setValue(a);
      }
    }
  }
}

function Fu(t, e, n, i) {
  if (void 0 === e[n]) throw new Error('Object "' + e + '" has no property "' + n + '"');
  var r = void 0;
  if (i.color) r = new wu(e, n);else {
    var o = [e, n].concat(i.factoryArgs);
    r = Tu.apply(t, o);
  }
  i.before instanceof cu && (i.before = i.before.__li), Hu(t, r), du.addClass(r.domElement, "c");
  var s = document.createElement("span");
  du.addClass(s, "property-name"), s.innerHTML = r.property;
  var a = document.createElement("div");
  a.appendChild(s), a.appendChild(r.domElement);
  var c = zu(t, a, i.before);
  return du.addClass(c, Iu.CLASS_CONTROLLER_ROW), r instanceof wu ? du.addClass(c, "color") : du.addClass(c, $l(r.getValue())), function (t, e, n) {
    if (n.__li = e, n.__gui = t, ql.extend(n, {
      options: function (e) {
        if (arguments.length > 1) {
          var i = n.__li.nextElementSibling;
          return n.remove(), Fu(t, n.object, n.property, {
            before: i,
            factoryArgs: [ql.toArray(arguments)]
          });
        }

        if (ql.isArray(e) || ql.isObject(e)) {
          var r = n.__li.nextElementSibling;
          return n.remove(), Fu(t, n.object, n.property, {
            before: r,
            factoryArgs: [e]
          });
        }
      },
      name: function (t) {
        return n.__li.firstElementChild.firstElementChild.innerHTML = t, n;
      },
      listen: function () {
        return n.__gui.listen(n), n;
      },
      remove: function () {
        return n.__gui.remove(n), n;
      }
    }), n instanceof _u) {
      var i = new yu(n.object, n.property, {
        min: n.__min,
        max: n.__max,
        step: n.__step
      });
      ql.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function (t) {
        var e = n[t],
            r = i[t];

        n[t] = i[t] = function () {
          var t = Array.prototype.slice.call(arguments);
          return r.apply(i, t), e.apply(n, t);
        };
      }), du.addClass(e, "has-slider"), n.domElement.insertBefore(i.domElement, n.domElement.firstElementChild);
    } else if (n instanceof yu) {
      var r = function (e) {
        if (ql.isNumber(n.__min) && ql.isNumber(n.__max)) {
          var i = n.__li.firstElementChild.firstElementChild.innerHTML,
              r = n.__gui.__listening.indexOf(n) > -1;
          n.remove();
          var o = Fu(t, n.object, n.property, {
            before: n.__li.nextElementSibling,
            factoryArgs: [n.__min, n.__max, n.__step]
          });
          return o.name(i), r && o.listen(), o;
        }

        return e;
      };

      n.min = ql.compose(r, n.min), n.max = ql.compose(r, n.max);
    } else n instanceof pu ? (du.bind(e, "click", function () {
      du.fakeEvent(n.__checkbox, "click");
    }), du.bind(n.__checkbox, "click", function (t) {
      t.stopPropagation();
    })) : n instanceof bu ? (du.bind(e, "click", function () {
      du.fakeEvent(n.__button, "click");
    }), du.bind(e, "mouseover", function () {
      du.addClass(n.__button, "hover");
    }), du.bind(e, "mouseout", function () {
      du.removeClass(n.__button, "hover");
    })) : n instanceof wu && (du.addClass(e, "color"), n.updateDisplay = ql.compose(function (t) {
      return e.style.borderLeftColor = n.__color.toString(), t;
    }, n.updateDisplay), n.updateDisplay());

    n.setValue = ql.compose(function (e) {
      return t.getRoot().__preset_select && n.isModified() && ku(t.getRoot(), !0), e;
    }, n.setValue);
  }(t, c, r), t.__controllers.push(r), r;
}

function Uu(t, e) {
  return document.location.href + "." + e;
}

function Gu(t, e, n) {
  var i = document.createElement("option");
  i.innerHTML = e, i.value = e, t.__preset_select.appendChild(i), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1);
}

function ju(t, e) {
  e.style.display = t.useLocalStorage ? "block" : "none";
}

function Vu(t) {
  var e = t.__save_row = document.createElement("li");
  du.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), du.addClass(e, "save-row");
  var n = document.createElement("span");
  n.innerHTML = "&nbsp;", du.addClass(n, "button gears");
  var i = document.createElement("span");
  i.innerHTML = "Save", du.addClass(i, "button"), du.addClass(i, "save");
  var r = document.createElement("span");
  r.innerHTML = "New", du.addClass(r, "button"), du.addClass(r, "save-as");
  var o = document.createElement("span");
  o.innerHTML = "Revert", du.addClass(o, "button"), du.addClass(o, "revert");
  var s = t.__preset_select = document.createElement("select");

  if (t.load && t.load.remembered ? ql.each(t.load.remembered, function (e, n) {
    Gu(t, n, n === t.preset);
  }) : Gu(t, "Default", !1), du.bind(s, "change", function () {
    for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;

    t.preset = this.value;
  }), e.appendChild(s), e.appendChild(n), e.appendChild(i), e.appendChild(r), e.appendChild(o), Cu) {
    var a = document.getElementById("dg-local-explain"),
        c = document.getElementById("dg-local-storage");
    document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(Uu(0, "isLocal")) && c.setAttribute("checked", "checked"), ju(t, a), du.bind(c, "change", function () {
      t.useLocalStorage = !t.useLocalStorage, ju(t, a);
    });
  }

  var l = document.getElementById("dg-new-constructor");
  du.bind(l, "keydown", function (t) {
    !t.metaKey || 67 !== t.which && 67 !== t.keyCode || Ru.hide();
  }), du.bind(n, "click", function () {
    l.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), Ru.show(), l.focus(), l.select();
  }), du.bind(i, "click", function () {
    t.save();
  }), du.bind(r, "click", function () {
    var e = prompt("Enter a new preset name.");
    e && t.saveAs(e);
  }), du.bind(o, "click", function () {
    t.revert();
  });
}

function Wu(t, e) {
  t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px");
}

function qu(t, e) {
  var n = {};
  return ql.each(t.__rememberedObjects, function (i, r) {
    var o = {},
        s = t.__rememberedObjectIndecesToControllers[r];
    ql.each(s, function (t, n) {
      o[n] = e ? t.initialValue : t.getValue();
    }), n[r] = o;
  }), n;
}

Iu.toggleHide = function () {
  Nu = !Nu, ql.each(Du, function (t) {
    t.domElement.style.display = Nu ? "none" : "";
  });
}, Iu.CLASS_AUTO_PLACE = "a", Iu.CLASS_AUTO_PLACE_CONTAINER = "ac", Iu.CLASS_MAIN = "main", Iu.CLASS_CONTROLLER_ROW = "cr", Iu.CLASS_TOO_TALL = "taller-than-window", Iu.CLASS_CLOSED = "closed", Iu.CLASS_CLOSE_BUTTON = "close-button", Iu.CLASS_CLOSE_TOP = "close-top", Iu.CLASS_CLOSE_BOTTOM = "close-bottom", Iu.CLASS_DRAG = "drag", Iu.DEFAULT_WIDTH = 245, Iu.TEXT_CLOSED = "Close Controls", Iu.TEXT_OPEN = "Open Controls", Iu._keydownHandler = function (t) {
  "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || Iu.toggleHide();
}, du.bind(window, "keydown", Iu._keydownHandler, !1), ql.extend(Iu.prototype, {
  add: function (t, e) {
    return Fu(this, t, e, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function (t, e) {
    return Fu(this, t, e, {
      color: !0
    });
  },
  remove: function (t) {
    this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
    var e = this;
    ql.defer(function () {
      e.onResize();
    });
  },
  destroy: function () {
    if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
    this.autoPlace && Ou.removeChild(this.domElement);
    var t = this;
    ql.each(this.__folders, function (e) {
      t.removeFolder(e);
    }), du.unbind(window, "keydown", Iu._keydownHandler, !1), Bu(this);
  },
  addFolder: function (t) {
    if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
    var e = {
      name: t,
      parent: this
    };
    e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
    var n = new Iu(e);
    this.__folders[t] = n;
    var i = zu(this, n.domElement);
    return du.addClass(i, "folder"), n;
  },
  removeFolder: function (t) {
    this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], Bu(t);
    var e = this;
    ql.each(t.__folders, function (e) {
      t.removeFolder(e);
    }), ql.defer(function () {
      e.onResize();
    });
  },
  open: function () {
    this.closed = !1;
  },
  close: function () {
    this.closed = !0;
  },
  hide: function () {
    this.domElement.style.display = "none";
  },
  show: function () {
    this.domElement.style.display = "";
  },
  onResize: function () {
    var t = this.getRoot();

    if (t.scrollable) {
      var e = du.getOffset(t.__ul).top,
          n = 0;
      ql.each(t.__ul.childNodes, function (e) {
        t.autoPlace && e === t.__save_row || (n += du.getHeight(e));
      }), window.innerHeight - e - 20 < n ? (du.addClass(t.domElement, Iu.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (du.removeClass(t.domElement, Iu.CLASS_TOO_TALL), t.__ul.style.height = "auto");
    }

    t.__resize_handle && ql.defer(function () {
      t.__resize_handle.style.height = t.__ul.offsetHeight + "px";
    }), t.__closeButton && (t.__closeButton.style.width = t.width + "px");
  },
  onResizeDebounced: ql.debounce(function () {
    this.onResize();
  }, 50),
  remember: function () {
    if (ql.isUndefined(Ru) && ((Ru = new Lu()).domElement.innerHTML = Eu), this.parent) throw new Error("You can only call remember on a top level GUI.");
    var t = this;
    ql.each(Array.prototype.slice.call(arguments), function (e) {
      0 === t.__rememberedObjects.length && Vu(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e);
    }), this.autoPlace && Wu(this, this.width);
  },
  getRoot: function () {
    for (var t = this; t.parent;) t = t.parent;

    return t;
  },
  getSaveObject: function () {
    var t = this.load;
    return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = qu(this)), t.folders = {}, ql.each(this.__folders, function (e, n) {
      t.folders[n] = e.getSaveObject();
    }), t;
  },
  save: function () {
    this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = qu(this), ku(this, !1), this.saveToLocalStorageIfPossible();
  },
  saveAs: function (t) {
    this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = qu(this, !0)), this.load.remembered[t] = qu(this), this.preset = t, Gu(this, t, !0), this.saveToLocalStorageIfPossible();
  },
  revert: function (t) {
    ql.each(this.__controllers, function (e) {
      this.getRoot().load.remembered ? Hu(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue());
    }, this), ql.each(this.__folders, function (t) {
      t.revert(t);
    }), t || ku(this.getRoot(), !1);
  },
  listen: function (t) {
    var e = 0 === this.__listening.length;
    this.__listening.push(t), e && function t(e) {
      0 !== e.length && Au.call(window, function () {
        t(e);
      }), ql.each(e, function (t) {
        t.updateDisplay();
      });
    }(this.__listening);
  },
  updateDisplay: function () {
    ql.each(this.__controllers, function (t) {
      t.updateDisplay();
    }), ql.each(this.__folders, function (t) {
      t.updateDisplay();
    });
  }
});

var Xu = Iu,
    Yu = function (t, e) {
  var n, r, o, s, a, c;
  void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.enabled = !0, this.target = new m(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    BOTTOM: 40
  }, this.mouseButtons = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
  }, this.touches = {
    ONE: 0,
    TWO: 2
  }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () {
    return y.phi;
  }, this.getAzimuthalAngle = function () {
    return y.theta;
  }, this.saveState = function () {
    l.target0.copy(l.target), l.position0.copy(l.object.position), l.zoom0 = l.object.zoom;
  }, this.reset = function () {
    l.target.copy(l.target0), l.object.position.copy(l.position0), l.object.zoom = l.zoom0, l.object.updateProjectionMatrix(), l.dispatchEvent(u), l.update(), g = f.NONE;
  }, this.update = (n = new m(), r = new d().setFromUnitVectors(t.up, new m(0, 1, 0)), o = r.clone().inverse(), s = new m(), a = new d(), c = 2 * Math.PI, function () {
    var t = l.object.position;
    n.copy(t).sub(l.target), n.applyQuaternion(r), y.setFromVector3(n), l.autoRotate && g === f.NONE && N(2 * Math.PI / 60 / 60 * l.autoRotateSpeed), l.enableDamping ? (y.theta += x.theta * l.dampingFactor, y.phi += x.phi * l.dampingFactor) : (y.theta += x.theta, y.phi += x.phi);
    var e = l.minAzimuthAngle,
        i = l.maxAzimuthAngle;
    return isFinite(e) && isFinite(i) && (e < -Math.PI ? e += c : e > Math.PI && (e -= c), i < -Math.PI ? i += c : i > Math.PI && (i -= c), y.theta = e < i ? Math.max(e, Math.min(i, y.theta)) : y.theta > (e + i) / 2 ? Math.max(e, y.theta) : Math.min(i, y.theta)), y.phi = Math.max(l.minPolarAngle, Math.min(l.maxPolarAngle, y.phi)), y.makeSafe(), y.radius *= _, y.radius = Math.max(l.minDistance, Math.min(l.maxDistance, y.radius)), !0 === l.enableDamping ? l.target.addScaledVector(b, l.dampingFactor) : l.target.add(b), n.setFromSpherical(y), n.applyQuaternion(o), t.copy(l.target).add(n), l.object.lookAt(l.target), !0 === l.enableDamping ? (x.theta *= 1 - l.dampingFactor, x.phi *= 1 - l.dampingFactor, b.multiplyScalar(1 - l.dampingFactor)) : (x.set(0, 0, 0), b.set(0, 0, 0)), _ = 1, !!(w || s.distanceToSquared(l.object.position) > v || 8 * (1 - a.dot(l.object.quaternion)) > v) && (l.dispatchEvent(u), s.copy(l.object.position), a.copy(l.object.quaternion), w = !1, !0);
  }), this.dispose = function () {
    l.domElement.removeEventListener("contextmenu", rt, !1), l.domElement.removeEventListener("mousedown", J, !1), l.domElement.removeEventListener("wheel", $, !1), l.domElement.removeEventListener("touchstart", et, !1), l.domElement.removeEventListener("touchend", it, !1), l.domElement.removeEventListener("touchmove", nt, !1), l.domElement.ownerDocument.removeEventListener("mousemove", Q, !1), l.domElement.ownerDocument.removeEventListener("mouseup", K, !1), l.domElement.removeEventListener("keydown", tt, !1);
  };
  var l = this,
      u = {
    type: "change"
  },
      h = {
    type: "start"
  },
      p = {
    type: "end"
  },
      f = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
  },
      g = f.NONE,
      v = 1e-6,
      y = new Fc(),
      x = new Fc(),
      _ = 1,
      b = new m(),
      w = !1,
      M = new i(),
      S = new i(),
      E = new i(),
      T = new i(),
      A = new i(),
      L = new i(),
      C = new i(),
      R = new i(),
      P = new i();

  function O() {
    return Math.pow(.95, l.zoomSpeed);
  }

  function N(t) {
    x.theta -= t;
  }

  function D(t) {
    x.phi -= t;
  }

  var I,
      z,
      B = (I = new m(), function (t, e) {
    I.setFromMatrixColumn(e, 0), I.multiplyScalar(-t), b.add(I);
  }),
      k = (z = new m(), function (t, e) {
    !0 === l.screenSpacePanning ? z.setFromMatrixColumn(e, 1) : (z.setFromMatrixColumn(e, 0), z.crossVectors(l.object.up, z)), z.multiplyScalar(t), b.add(z);
  }),
      H = function () {
    var t = new m();
    return function (e, n) {
      var i = l.domElement;

      if (l.object.isPerspectiveCamera) {
        var r = l.object.position;
        t.copy(r).sub(l.target);
        var o = t.length();
        o *= Math.tan(l.object.fov / 2 * Math.PI / 180), B(2 * e * o / i.clientHeight, l.object.matrix), k(2 * n * o / i.clientHeight, l.object.matrix);
      } else l.object.isOrthographicCamera ? (B(e * (l.object.right - l.object.left) / l.object.zoom / i.clientWidth, l.object.matrix), k(n * (l.object.top - l.object.bottom) / l.object.zoom / i.clientHeight, l.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), l.enablePan = !1);
    };
  }();

  function F(t) {
    l.object.isPerspectiveCamera ? _ /= t : l.object.isOrthographicCamera ? (l.object.zoom = Math.max(l.minZoom, Math.min(l.maxZoom, l.object.zoom * t)), l.object.updateProjectionMatrix(), w = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), l.enableZoom = !1);
  }

  function U(t) {
    l.object.isPerspectiveCamera ? _ *= t : l.object.isOrthographicCamera ? (l.object.zoom = Math.max(l.minZoom, Math.min(l.maxZoom, l.object.zoom / t)), l.object.updateProjectionMatrix(), w = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), l.enableZoom = !1);
  }

  function G(t) {
    M.set(t.clientX, t.clientY);
  }

  function j(t) {
    T.set(t.clientX, t.clientY);
  }

  function V(t) {
    if (1 == t.touches.length) M.set(t.touches[0].pageX, t.touches[0].pageY);else {
      var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
      M.set(e, n);
    }
  }

  function W(t) {
    if (1 == t.touches.length) T.set(t.touches[0].pageX, t.touches[0].pageY);else {
      var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
      T.set(e, n);
    }
  }

  function q(t) {
    var e = t.touches[0].pageX - t.touches[1].pageX,
        n = t.touches[0].pageY - t.touches[1].pageY,
        i = Math.sqrt(e * e + n * n);
    C.set(0, i);
  }

  function X(t) {
    if (1 == t.touches.length) S.set(t.touches[0].pageX, t.touches[0].pageY);else {
      var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
      S.set(e, n);
    }
    E.subVectors(S, M).multiplyScalar(l.rotateSpeed);
    var i = l.domElement;
    N(2 * Math.PI * E.x / i.clientHeight), D(2 * Math.PI * E.y / i.clientHeight), M.copy(S);
  }

  function Y(t) {
    if (1 == t.touches.length) A.set(t.touches[0].pageX, t.touches[0].pageY);else {
      var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
      A.set(e, n);
    }
    L.subVectors(A, T).multiplyScalar(l.panSpeed), H(L.x, L.y), T.copy(A);
  }

  function Z(t) {
    var e = t.touches[0].pageX - t.touches[1].pageX,
        n = t.touches[0].pageY - t.touches[1].pageY,
        i = Math.sqrt(e * e + n * n);
    R.set(0, i), P.set(0, Math.pow(R.y / C.y, l.zoomSpeed)), F(P.y), C.copy(R);
  }

  function J(t) {
    if (!1 !== l.enabled) {
      var e;

      switch (t.preventDefault(), l.domElement.focus ? l.domElement.focus() : window.focus(), t.button) {
        case 0:
          e = l.mouseButtons.LEFT;
          break;

        case 1:
          e = l.mouseButtons.MIDDLE;
          break;

        case 2:
          e = l.mouseButtons.RIGHT;
          break;

        default:
          e = -1;
      }

      switch (e) {
        case 1:
          if (!1 === l.enableZoom) return;
          !function (t) {
            C.set(t.clientX, t.clientY);
          }(t), g = f.DOLLY;
          break;

        case 0:
          if (t.ctrlKey || t.metaKey || t.shiftKey) {
            if (!1 === l.enablePan) return;
            j(t), g = f.PAN;
          } else {
            if (!1 === l.enableRotate) return;
            G(t), g = f.ROTATE;
          }

          break;

        case 2:
          if (t.ctrlKey || t.metaKey || t.shiftKey) {
            if (!1 === l.enableRotate) return;
            G(t), g = f.ROTATE;
          } else {
            if (!1 === l.enablePan) return;
            j(t), g = f.PAN;
          }

          break;

        default:
          g = f.NONE;
      }

      g !== f.NONE && (l.domElement.ownerDocument.addEventListener("mousemove", Q, !1), l.domElement.ownerDocument.addEventListener("mouseup", K, !1), l.dispatchEvent(h));
    }
  }

  function Q(t) {
    if (!1 !== l.enabled) switch (t.preventDefault(), g) {
      case f.ROTATE:
        if (!1 === l.enableRotate) return;
        !function (t) {
          S.set(t.clientX, t.clientY), E.subVectors(S, M).multiplyScalar(l.rotateSpeed);
          var e = l.domElement;
          N(2 * Math.PI * E.x / e.clientHeight), D(2 * Math.PI * E.y / e.clientHeight), M.copy(S), l.update();
        }(t);
        break;

      case f.DOLLY:
        if (!1 === l.enableZoom) return;
        !function (t) {
          R.set(t.clientX, t.clientY), P.subVectors(R, C), P.y > 0 ? F(O()) : P.y < 0 && U(O()), C.copy(R), l.update();
        }(t);
        break;

      case f.PAN:
        if (!1 === l.enablePan) return;
        !function (t) {
          A.set(t.clientX, t.clientY), L.subVectors(A, T).multiplyScalar(l.panSpeed), H(L.x, L.y), T.copy(A), l.update();
        }(t);
    }
  }

  function K(t) {
    !1 !== l.enabled && (l.domElement.ownerDocument.removeEventListener("mousemove", Q, !1), l.domElement.ownerDocument.removeEventListener("mouseup", K, !1), l.dispatchEvent(p), g = f.NONE);
  }

  function $(t) {
    !1 === l.enabled || !1 === l.enableZoom || g !== f.NONE && g !== f.ROTATE || (t.preventDefault(), t.stopPropagation(), l.dispatchEvent(h), function (t) {
      t.deltaY < 0 ? U(O()) : t.deltaY > 0 && F(O()), l.update();
    }(t), l.dispatchEvent(p));
  }

  function tt(t) {
    !1 !== l.enabled && !1 !== l.enableKeys && !1 !== l.enablePan && function (t) {
      var e = !1;

      switch (t.keyCode) {
        case l.keys.UP:
          H(0, l.keyPanSpeed), e = !0;
          break;

        case l.keys.BOTTOM:
          H(0, -l.keyPanSpeed), e = !0;
          break;

        case l.keys.LEFT:
          H(l.keyPanSpeed, 0), e = !0;
          break;

        case l.keys.RIGHT:
          H(-l.keyPanSpeed, 0), e = !0;
      }

      e && (t.preventDefault(), l.update());
    }(t);
  }

  function et(t) {
    if (!1 !== l.enabled) {
      switch (t.preventDefault(), t.touches.length) {
        case 1:
          switch (l.touches.ONE) {
            case 0:
              if (!1 === l.enableRotate) return;
              V(t), g = f.TOUCH_ROTATE;
              break;

            case 1:
              if (!1 === l.enablePan) return;
              W(t), g = f.TOUCH_PAN;
              break;

            default:
              g = f.NONE;
          }

          break;

        case 2:
          switch (l.touches.TWO) {
            case 2:
              if (!1 === l.enableZoom && !1 === l.enablePan) return;
              !function (t) {
                l.enableZoom && q(t), l.enablePan && W(t);
              }(t), g = f.TOUCH_DOLLY_PAN;
              break;

            case 3:
              if (!1 === l.enableZoom && !1 === l.enableRotate) return;
              !function (t) {
                l.enableZoom && q(t), l.enableRotate && V(t);
              }(t), g = f.TOUCH_DOLLY_ROTATE;
              break;

            default:
              g = f.NONE;
          }

          break;

        default:
          g = f.NONE;
      }

      g !== f.NONE && l.dispatchEvent(h);
    }
  }

  function nt(t) {
    if (!1 !== l.enabled) switch (t.preventDefault(), t.stopPropagation(), g) {
      case f.TOUCH_ROTATE:
        if (!1 === l.enableRotate) return;
        X(t), l.update();
        break;

      case f.TOUCH_PAN:
        if (!1 === l.enablePan) return;
        Y(t), l.update();
        break;

      case f.TOUCH_DOLLY_PAN:
        if (!1 === l.enableZoom && !1 === l.enablePan) return;
        !function (t) {
          l.enableZoom && Z(t), l.enablePan && Y(t);
        }(t), l.update();
        break;

      case f.TOUCH_DOLLY_ROTATE:
        if (!1 === l.enableZoom && !1 === l.enableRotate) return;
        !function (t) {
          l.enableZoom && Z(t), l.enableRotate && X(t);
        }(t), l.update();
        break;

      default:
        g = f.NONE;
    }
  }

  function it(t) {
    !1 !== l.enabled && (l.dispatchEvent(p), g = f.NONE);
  }

  function rt(t) {
    !1 !== l.enabled && t.preventDefault();
  }

  l.domElement.addEventListener("contextmenu", rt, !1), l.domElement.addEventListener("mousedown", J, !1), l.domElement.addEventListener("wheel", $, !1), l.domElement.addEventListener("touchstart", et, !1), l.domElement.addEventListener("touchend", it, !1), l.domElement.addEventListener("touchmove", nt, !1), l.domElement.addEventListener("keydown", tt, !1), -1 === l.domElement.tabIndex && (l.domElement.tabIndex = 0), this.update();
};

(Yu.prototype = Object.create(t.prototype)).constructor = Yu;

var Zu = function (t, e) {
  Yu.call(this, t, e), this.screenSpacePanning = !1, this.mouseButtons.LEFT = 2, this.mouseButtons.RIGHT = 0, this.touches.ONE = 1, this.touches.TWO = 3;
};

(Zu.prototype = Object.create(t.prototype)).constructor = Zu;
var Ju,
    Qu,
    Ku = {};
Ju = "undefined" != typeof window ? window : Ku, Qu = function (t, e) {
  var n = [],
      i = Object.getPrototypeOf,
      r = n.slice,
      o = n.flat ? function (t) {
    return n.flat.call(t);
  } : function (t) {
    return n.concat.apply([], t);
  },
      s = n.push,
      a = n.indexOf,
      c = {},
      l = c.toString,
      u = c.hasOwnProperty,
      h = u.toString,
      d = h.call(Object),
      p = {},
      f = function (t) {
    return "function" == typeof t && "number" != typeof t.nodeType;
  },
      m = function (t) {
    return null != t && t === t.window;
  },
      g = t.document,
      v = {
    type: !0,
    src: !0,
    nonce: !0,
    noModule: !0
  };

  function y(t, e, n) {
    var i,
        r,
        o = (n = n || g).createElement("script");
    if (o.text = t, e) for (i in v) (r = e[i] || e.getAttribute && e.getAttribute(i)) && o.setAttribute(i, r);
    n.head.appendChild(o).parentNode.removeChild(o);
  }

  function x(t) {
    return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? c[l.call(t)] || "object" : typeof t;
  }

  var _ = function t(e, n) {
    return new t.fn.init(e, n);
  };

  function b(t) {
    var e = !!t && "length" in t && t.length,
        n = x(t);
    return !f(t) && !m(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t);
  }

  _.fn = _.prototype = {
    jquery: "3.5.1",
    constructor: _,
    length: 0,
    toArray: function () {
      return r.call(this);
    },
    get: function (t) {
      return null == t ? r.call(this) : t < 0 ? this[t + this.length] : this[t];
    },
    pushStack: function (t) {
      var e = _.merge(this.constructor(), t);

      return e.prevObject = this, e;
    },
    each: function (t) {
      return _.each(this, t);
    },
    map: function (t) {
      return this.pushStack(_.map(this, function (e, n) {
        return t.call(e, n, e);
      }));
    },
    slice: function () {
      return this.pushStack(r.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    even: function () {
      return this.pushStack(_.grep(this, function (t, e) {
        return (e + 1) % 2;
      }));
    },
    odd: function () {
      return this.pushStack(_.grep(this, function (t, e) {
        return e % 2;
      }));
    },
    eq: function (t) {
      var e = this.length,
          n = +t + (t < 0 ? e : 0);
      return this.pushStack(n >= 0 && n < e ? [this[n]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor();
    },
    push: s,
    sort: n.sort,
    splice: n.splice
  }, _.extend = _.fn.extend = function () {
    var t,
        e,
        n,
        i,
        r,
        o,
        s = arguments[0] || {},
        a = 1,
        c = arguments.length,
        l = !1;

    for ("boolean" == typeof s && (l = s, s = arguments[a] || {}, a++), "object" == typeof s || f(s) || (s = {}), a === c && (s = this, a--); a < c; a++) if (null != (t = arguments[a])) for (e in t) i = t[e], "__proto__" !== e && s !== i && (l && i && (_.isPlainObject(i) || (r = Array.isArray(i))) ? (n = s[e], o = r && !Array.isArray(n) ? [] : r || _.isPlainObject(n) ? n : {}, r = !1, s[e] = _.extend(l, o, i)) : void 0 !== i && (s[e] = i));

    return s;
  }, _.extend({
    expando: "jQuery" + ("3.5.1" + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function (t) {
      throw new Error(t);
    },
    noop: function () {},
    isPlainObject: function (t) {
      var e, n;
      return !(!t || "[object Object]" !== l.call(t) || (e = i(t)) && ("function" != typeof (n = u.call(e, "constructor") && e.constructor) || h.call(n) !== d));
    },
    isEmptyObject: function (t) {
      var e;

      for (e in t) return !1;

      return !0;
    },
    globalEval: function (t, e, n) {
      y(t, {
        nonce: e && e.nonce
      }, n);
    },
    each: function (t, e) {
      var n,
          i = 0;
      if (b(t)) for (n = t.length; i < n && !1 !== e.call(t[i], i, t[i]); i++);else for (i in t) if (!1 === e.call(t[i], i, t[i])) break;
      return t;
    },
    makeArray: function (t, e) {
      var n = e || [];
      return null != t && (b(Object(t)) ? _.merge(n, "string" == typeof t ? [t] : t) : s.call(n, t)), n;
    },
    inArray: function (t, e, n) {
      return null == e ? -1 : a.call(e, t, n);
    },
    merge: function (t, e) {
      for (var n = +e.length, i = 0, r = t.length; i < n; i++) t[r++] = e[i];

      return t.length = r, t;
    },
    grep: function (t, e, n) {
      for (var i = [], r = 0, o = t.length, s = !n; r < o; r++) !e(t[r], r) !== s && i.push(t[r]);

      return i;
    },
    map: function (t, e, n) {
      var i,
          r,
          s = 0,
          a = [];
      if (b(t)) for (i = t.length; s < i; s++) null != (r = e(t[s], s, n)) && a.push(r);else for (s in t) null != (r = e(t[s], s, n)) && a.push(r);
      return o(a);
    },
    guid: 1,
    support: p
  }), "function" == typeof Symbol && (_.fn[Symbol.iterator] = n[Symbol.iterator]), _.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (t, e) {
    c["[object " + e + "]"] = e.toLowerCase();
  });

  var w =
  /*!
   * Sizzle CSS Selector Engine v2.3.5
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2020-03-14
   */
  function (t) {
    var e,
        n,
        i,
        r,
        o,
        s,
        a,
        c,
        l,
        u,
        h,
        d,
        p,
        f,
        m,
        g,
        v,
        y,
        x,
        _ = "sizzle" + 1 * new Date(),
        b = t.document,
        w = 0,
        M = 0,
        S = ct(),
        E = ct(),
        T = ct(),
        A = ct(),
        L = function (t, e) {
      return t === e && (h = !0), 0;
    },
        C = {}.hasOwnProperty,
        R = [],
        P = R.pop,
        O = R.push,
        N = R.push,
        D = R.slice,
        I = function (t, e) {
      for (var n = 0, i = t.length; n < i; n++) if (t[n] === e) return n;

      return -1;
    },
        z = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        B = "[\\x20\\t\\r\\n\\f]",
        k = "(?:\\\\[\\da-fA-F]{1,6}" + B + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        H = "\\[" + B + "*(" + k + ")(?:" + B + "*([*^$|!~]?=)" + B + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + k + "))|)" + B + "*\\]",
        F = ":(" + k + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + H + ")*)|.*)\\)|)",
        U = new RegExp(B + "+", "g"),
        G = new RegExp("^" + B + "+|((?:^|[^\\\\])(?:\\\\.)*)" + B + "+$", "g"),
        j = new RegExp("^" + B + "*," + B + "*"),
        V = new RegExp("^" + B + "*([>+~]|" + B + ")" + B + "*"),
        W = new RegExp(B + "|>"),
        q = new RegExp(F),
        X = new RegExp("^" + k + "$"),
        Y = {
      ID: new RegExp("^#(" + k + ")"),
      CLASS: new RegExp("^\\.(" + k + ")"),
      TAG: new RegExp("^(" + k + "|[*])"),
      ATTR: new RegExp("^" + H),
      PSEUDO: new RegExp("^" + F),
      CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + B + "*(even|odd|(([+-]|)(\\d*)n|)" + B + "*(?:([+-]|)" + B + "*(\\d+)|))" + B + "*\\)|)", "i"),
      bool: new RegExp("^(?:" + z + ")$", "i"),
      needsContext: new RegExp("^" + B + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + B + "*((?:-\\d)?\\d*)" + B + "*\\)|)(?=[^-]|$)", "i")
    },
        Z = /HTML$/i,
        J = /^(?:input|select|textarea|button)$/i,
        Q = /^h\d$/i,
        K = /^[^{]+\{\s*\[native \w/,
        $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        tt = /[+~]/,
        et = new RegExp("\\\\[\\da-fA-F]{1,6}" + B + "?|\\\\([^\\r\\n\\f])", "g"),
        nt = function (t, e) {
      var n = "0x" + t.slice(1) - 65536;
      return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320));
    },
        it = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        rt = function (t, e) {
      return e ? "\0" === t ? "ï¿½" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t;
    },
        ot = function () {
      d();
    },
        st = _t(function (t) {
      return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase();
    }, {
      dir: "parentNode",
      next: "legend"
    });

    try {
      N.apply(R = D.call(b.childNodes), b.childNodes), R[b.childNodes.length].nodeType;
    } catch (t) {
      N = {
        apply: R.length ? function (t, e) {
          O.apply(t, D.call(e));
        } : function (t, e) {
          for (var n = t.length, i = 0; t[n++] = e[i++];);

          t.length = n - 1;
        }
      };
    }

    function at(t, e, i, r) {
      var o,
          a,
          l,
          u,
          h,
          f,
          v,
          y = e && e.ownerDocument,
          b = e ? e.nodeType : 9;
      if (i = i || [], "string" != typeof t || !t || 1 !== b && 9 !== b && 11 !== b) return i;

      if (!r && (d(e), e = e || p, m)) {
        if (11 !== b && (h = $.exec(t))) if (o = h[1]) {
          if (9 === b) {
            if (!(l = e.getElementById(o))) return i;
            if (l.id === o) return i.push(l), i;
          } else if (y && (l = y.getElementById(o)) && x(e, l) && l.id === o) return i.push(l), i;
        } else {
          if (h[2]) return N.apply(i, e.getElementsByTagName(t)), i;
          if ((o = h[3]) && n.getElementsByClassName && e.getElementsByClassName) return N.apply(i, e.getElementsByClassName(o)), i;
        }

        if (n.qsa && !A[t + " "] && (!g || !g.test(t)) && (1 !== b || "object" !== e.nodeName.toLowerCase())) {
          if (v = t, y = e, 1 === b && (W.test(t) || V.test(t))) {
            for ((y = tt.test(t) && vt(e.parentNode) || e) === e && n.scope || ((u = e.getAttribute("id")) ? u = u.replace(it, rt) : e.setAttribute("id", u = _)), a = (f = s(t)).length; a--;) f[a] = (u ? "#" + u : ":scope") + " " + xt(f[a]);

            v = f.join(",");
          }

          try {
            return N.apply(i, y.querySelectorAll(v)), i;
          } catch (e) {
            A(t, !0);
          } finally {
            u === _ && e.removeAttribute("id");
          }
        }
      }

      return c(t.replace(G, "$1"), e, i, r);
    }

    function ct() {
      var t = [];
      return function e(n, r) {
        return t.push(n + " ") > i.cacheLength && delete e[t.shift()], e[n + " "] = r;
      };
    }

    function lt(t) {
      return t[_] = !0, t;
    }

    function ut(t) {
      var e = p.createElement("fieldset");

      try {
        return !!t(e);
      } catch (t) {
        return !1;
      } finally {
        e.parentNode && e.parentNode.removeChild(e), e = null;
      }
    }

    function ht(t, e) {
      for (var n = t.split("|"), r = n.length; r--;) i.attrHandle[n[r]] = e;
    }

    function dt(t, e) {
      var n = e && t,
          i = n && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
      if (i) return i;
      if (n) for (; n = n.nextSibling;) if (n === e) return -1;
      return t ? 1 : -1;
    }

    function pt(t) {
      return function (e) {
        return "input" === e.nodeName.toLowerCase() && e.type === t;
      };
    }

    function ft(t) {
      return function (e) {
        var n = e.nodeName.toLowerCase();
        return ("input" === n || "button" === n) && e.type === t;
      };
    }

    function mt(t) {
      return function (e) {
        return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && st(e) === t : e.disabled === t : "label" in e && e.disabled === t;
      };
    }

    function gt(t) {
      return lt(function (e) {
        return e = +e, lt(function (n, i) {
          for (var r, o = t([], n.length, e), s = o.length; s--;) n[r = o[s]] && (n[r] = !(i[r] = n[r]));
        });
      });
    }

    function vt(t) {
      return t && void 0 !== t.getElementsByTagName && t;
    }

    for (e in n = at.support = {}, o = at.isXML = function (t) {
      var e = t.namespaceURI,
          n = (t.ownerDocument || t).documentElement;
      return !Z.test(e || n && n.nodeName || "HTML");
    }, d = at.setDocument = function (t) {
      var e,
          r,
          s = t ? t.ownerDocument || t : b;
      return s != p && 9 === s.nodeType && s.documentElement ? (f = (p = s).documentElement, m = !o(p), b != p && (r = p.defaultView) && r.top !== r && (r.addEventListener ? r.addEventListener("unload", ot, !1) : r.attachEvent && r.attachEvent("onunload", ot)), n.scope = ut(function (t) {
        return f.appendChild(t).appendChild(p.createElement("div")), void 0 !== t.querySelectorAll && !t.querySelectorAll(":scope fieldset div").length;
      }), n.attributes = ut(function (t) {
        return t.className = "i", !t.getAttribute("className");
      }), n.getElementsByTagName = ut(function (t) {
        return t.appendChild(p.createComment("")), !t.getElementsByTagName("*").length;
      }), n.getElementsByClassName = K.test(p.getElementsByClassName), n.getById = ut(function (t) {
        return f.appendChild(t).id = _, !p.getElementsByName || !p.getElementsByName(_).length;
      }), n.getById ? (i.filter.ID = function (t) {
        var e = t.replace(et, nt);
        return function (t) {
          return t.getAttribute("id") === e;
        };
      }, i.find.ID = function (t, e) {
        if (void 0 !== e.getElementById && m) {
          var n = e.getElementById(t);
          return n ? [n] : [];
        }
      }) : (i.filter.ID = function (t) {
        var e = t.replace(et, nt);
        return function (t) {
          var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
          return n && n.value === e;
        };
      }, i.find.ID = function (t, e) {
        if (void 0 !== e.getElementById && m) {
          var n,
              i,
              r,
              o = e.getElementById(t);

          if (o) {
            if ((n = o.getAttributeNode("id")) && n.value === t) return [o];

            for (r = e.getElementsByName(t), i = 0; o = r[i++];) if ((n = o.getAttributeNode("id")) && n.value === t) return [o];
          }

          return [];
        }
      }), i.find.TAG = n.getElementsByTagName ? function (t, e) {
        return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : n.qsa ? e.querySelectorAll(t) : void 0;
      } : function (t, e) {
        var n,
            i = [],
            r = 0,
            o = e.getElementsByTagName(t);

        if ("*" === t) {
          for (; n = o[r++];) 1 === n.nodeType && i.push(n);

          return i;
        }

        return o;
      }, i.find.CLASS = n.getElementsByClassName && function (t, e) {
        if (void 0 !== e.getElementsByClassName && m) return e.getElementsByClassName(t);
      }, v = [], g = [], (n.qsa = K.test(p.querySelectorAll)) && (ut(function (t) {
        var e;
        f.appendChild(t).innerHTML = "<a id='" + _ + "'></a><select id='" + _ + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + B + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || g.push("\\[" + B + "*(?:value|" + z + ")"), t.querySelectorAll("[id~=" + _ + "-]").length || g.push("~="), (e = p.createElement("input")).setAttribute("name", ""), t.appendChild(e), t.querySelectorAll("[name='']").length || g.push("\\[" + B + "*name" + B + "*=" + B + "*(?:''|\"\")"), t.querySelectorAll(":checked").length || g.push(":checked"), t.querySelectorAll("a#" + _ + "+*").length || g.push(".#.+[+~]"), t.querySelectorAll("\\\f"), g.push("[\\r\\n\\f]");
      }), ut(function (t) {
        t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
        var e = p.createElement("input");
        e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && g.push("name" + B + "*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), f.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), g.push(",.*:");
      })), (n.matchesSelector = K.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && ut(function (t) {
        n.disconnectedMatch = y.call(t, "*"), y.call(t, "[s!='']:x"), v.push("!=", F);
      }), g = g.length && new RegExp(g.join("|")), v = v.length && new RegExp(v.join("|")), e = K.test(f.compareDocumentPosition), x = e || K.test(f.contains) ? function (t, e) {
        var n = 9 === t.nodeType ? t.documentElement : t,
            i = e && e.parentNode;
        return t === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(i)));
      } : function (t, e) {
        if (e) for (; e = e.parentNode;) if (e === t) return !0;
        return !1;
      }, L = e ? function (t, e) {
        if (t === e) return h = !0, 0;
        var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
        return i || (1 & (i = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !n.sortDetached && e.compareDocumentPosition(t) === i ? t == p || t.ownerDocument == b && x(b, t) ? -1 : e == p || e.ownerDocument == b && x(b, e) ? 1 : u ? I(u, t) - I(u, e) : 0 : 4 & i ? -1 : 1);
      } : function (t, e) {
        if (t === e) return h = !0, 0;
        var n,
            i = 0,
            r = t.parentNode,
            o = e.parentNode,
            s = [t],
            a = [e];
        if (!r || !o) return t == p ? -1 : e == p ? 1 : r ? -1 : o ? 1 : u ? I(u, t) - I(u, e) : 0;
        if (r === o) return dt(t, e);

        for (n = t; n = n.parentNode;) s.unshift(n);

        for (n = e; n = n.parentNode;) a.unshift(n);

        for (; s[i] === a[i];) i++;

        return i ? dt(s[i], a[i]) : s[i] == b ? -1 : a[i] == b ? 1 : 0;
      }, p) : p;
    }, at.matches = function (t, e) {
      return at(t, null, null, e);
    }, at.matchesSelector = function (t, e) {
      if (d(t), n.matchesSelector && m && !A[e + " "] && (!v || !v.test(e)) && (!g || !g.test(e))) try {
        var i = y.call(t, e);
        if (i || n.disconnectedMatch || t.document && 11 !== t.document.nodeType) return i;
      } catch (t) {
        A(e, !0);
      }
      return at(e, p, null, [t]).length > 0;
    }, at.contains = function (t, e) {
      return (t.ownerDocument || t) != p && d(t), x(t, e);
    }, at.attr = function (t, e) {
      (t.ownerDocument || t) != p && d(t);
      var r = i.attrHandle[e.toLowerCase()],
          o = r && C.call(i.attrHandle, e.toLowerCase()) ? r(t, e, !m) : void 0;
      return void 0 !== o ? o : n.attributes || !m ? t.getAttribute(e) : (o = t.getAttributeNode(e)) && o.specified ? o.value : null;
    }, at.escape = function (t) {
      return (t + "").replace(it, rt);
    }, at.error = function (t) {
      throw new Error("Syntax error, unrecognized expression: " + t);
    }, at.uniqueSort = function (t) {
      var e,
          i = [],
          r = 0,
          o = 0;

      if (h = !n.detectDuplicates, u = !n.sortStable && t.slice(0), t.sort(L), h) {
        for (; e = t[o++];) e === t[o] && (r = i.push(o));

        for (; r--;) t.splice(i[r], 1);
      }

      return u = null, t;
    }, r = at.getText = function (t) {
      var e,
          n = "",
          i = 0,
          o = t.nodeType;

      if (o) {
        if (1 === o || 9 === o || 11 === o) {
          if ("string" == typeof t.textContent) return t.textContent;

          for (t = t.firstChild; t; t = t.nextSibling) n += r(t);
        } else if (3 === o || 4 === o) return t.nodeValue;
      } else for (; e = t[i++];) n += r(e);

      return n;
    }, (i = at.selectors = {
      cacheLength: 50,
      createPseudo: lt,
      match: Y,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function (t) {
          return t[1] = t[1].replace(et, nt), t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4);
        },
        CHILD: function (t) {
          return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || at.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && at.error(t[0]), t;
        },
        PSEUDO: function (t) {
          var e,
              n = !t[6] && t[2];
          return Y.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && q.test(n) && (e = s(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(0, e), t[2] = n.slice(0, e)), t.slice(0, 3));
        }
      },
      filter: {
        TAG: function (t) {
          var e = t.replace(et, nt).toLowerCase();
          return "*" === t ? function () {
            return !0;
          } : function (t) {
            return t.nodeName && t.nodeName.toLowerCase() === e;
          };
        },
        CLASS: function (t) {
          var e = S[t + " "];
          return e || (e = new RegExp("(^|" + B + ")" + t + "(" + B + "|$)")) && S(t, function (t) {
            return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "");
          });
        },
        ATTR: function (t, e, n) {
          return function (i) {
            var r = at.attr(i, t);
            return null == r ? "!=" === e : !e || (r += "", "=" === e ? r === n : "!=" === e ? r !== n : "^=" === e ? n && 0 === r.indexOf(n) : "*=" === e ? n && r.indexOf(n) > -1 : "$=" === e ? n && r.slice(-n.length) === n : "~=" === e ? (" " + r.replace(U, " ") + " ").indexOf(n) > -1 : "|=" === e && (r === n || r.slice(0, n.length + 1) === n + "-"));
          };
        },
        CHILD: function (t, e, n, i, r) {
          var o = "nth" !== t.slice(0, 3),
              s = "last" !== t.slice(-4),
              a = "of-type" === e;
          return 1 === i && 0 === r ? function (t) {
            return !!t.parentNode;
          } : function (e, n, c) {
            var l,
                u,
                h,
                d,
                p,
                f,
                m = o !== s ? "nextSibling" : "previousSibling",
                g = e.parentNode,
                v = a && e.nodeName.toLowerCase(),
                y = !c && !a,
                x = !1;

            if (g) {
              if (o) {
                for (; m;) {
                  for (d = e; d = d[m];) if (a ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;

                  f = m = "only" === t && !f && "nextSibling";
                }

                return !0;
              }

              if (f = [s ? g.firstChild : g.lastChild], s && y) {
                for (x = (p = (l = (u = (h = (d = g)[_] || (d[_] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] || [])[0] === w && l[1]) && l[2], d = p && g.childNodes[p]; d = ++p && d && d[m] || (x = p = 0) || f.pop();) if (1 === d.nodeType && ++x && d === e) {
                  u[t] = [w, p, x];
                  break;
                }
              } else if (y && (x = p = (l = (u = (h = (d = e)[_] || (d[_] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] || [])[0] === w && l[1]), !1 === x) for (; (d = ++p && d && d[m] || (x = p = 0) || f.pop()) && ((a ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++x || (y && ((u = (h = d[_] || (d[_] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] = [w, x]), d !== e)););

              return (x -= r) === i || x % i == 0 && x / i >= 0;
            }
          };
        },
        PSEUDO: function (t, e) {
          var n,
              r = i.pseudos[t] || i.setFilters[t.toLowerCase()] || at.error("unsupported pseudo: " + t);
          return r[_] ? r(e) : r.length > 1 ? (n = [t, t, "", e], i.setFilters.hasOwnProperty(t.toLowerCase()) ? lt(function (t, n) {
            for (var i, o = r(t, e), s = o.length; s--;) t[i = I(t, o[s])] = !(n[i] = o[s]);
          }) : function (t) {
            return r(t, 0, n);
          }) : r;
        }
      },
      pseudos: {
        not: lt(function (t) {
          var e = [],
              n = [],
              i = a(t.replace(G, "$1"));
          return i[_] ? lt(function (t, e, n, r) {
            for (var o, s = i(t, null, r, []), a = t.length; a--;) (o = s[a]) && (t[a] = !(e[a] = o));
          }) : function (t, r, o) {
            return e[0] = t, i(e, null, o, n), e[0] = null, !n.pop();
          };
        }),
        has: lt(function (t) {
          return function (e) {
            return at(t, e).length > 0;
          };
        }),
        contains: lt(function (t) {
          return t = t.replace(et, nt), function (e) {
            return (e.textContent || r(e)).indexOf(t) > -1;
          };
        }),
        lang: lt(function (t) {
          return X.test(t || "") || at.error("unsupported lang: " + t), t = t.replace(et, nt).toLowerCase(), function (e) {
            var n;

            do {
              if (n = m ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-");
            } while ((e = e.parentNode) && 1 === e.nodeType);

            return !1;
          };
        }),
        target: function (e) {
          var n = t.location && t.location.hash;
          return n && n.slice(1) === e.id;
        },
        root: function (t) {
          return t === f;
        },
        focus: function (t) {
          return t === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(t.type || t.href || ~t.tabIndex);
        },
        enabled: mt(!1),
        disabled: mt(!0),
        checked: function (t) {
          var e = t.nodeName.toLowerCase();
          return "input" === e && !!t.checked || "option" === e && !!t.selected;
        },
        selected: function (t) {
          return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected;
        },
        empty: function (t) {
          for (t = t.firstChild; t; t = t.nextSibling) if (t.nodeType < 6) return !1;

          return !0;
        },
        parent: function (t) {
          return !i.pseudos.empty(t);
        },
        header: function (t) {
          return Q.test(t.nodeName);
        },
        input: function (t) {
          return J.test(t.nodeName);
        },
        button: function (t) {
          var e = t.nodeName.toLowerCase();
          return "input" === e && "button" === t.type || "button" === e;
        },
        text: function (t) {
          var e;
          return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase());
        },
        first: gt(function () {
          return [0];
        }),
        last: gt(function (t, e) {
          return [e - 1];
        }),
        eq: gt(function (t, e, n) {
          return [n < 0 ? n + e : n];
        }),
        even: gt(function (t, e) {
          for (var n = 0; n < e; n += 2) t.push(n);

          return t;
        }),
        odd: gt(function (t, e) {
          for (var n = 1; n < e; n += 2) t.push(n);

          return t;
        }),
        lt: gt(function (t, e, n) {
          for (var i = n < 0 ? n + e : n > e ? e : n; --i >= 0;) t.push(i);

          return t;
        }),
        gt: gt(function (t, e, n) {
          for (var i = n < 0 ? n + e : n; ++i < e;) t.push(i);

          return t;
        })
      }
    }).pseudos.nth = i.pseudos.eq, {
      radio: !0,
      checkbox: !0,
      file: !0,
      password: !0,
      image: !0
    }) i.pseudos[e] = pt(e);

    for (e in {
      submit: !0,
      reset: !0
    }) i.pseudos[e] = ft(e);

    function yt() {}

    function xt(t) {
      for (var e = 0, n = t.length, i = ""; e < n; e++) i += t[e].value;

      return i;
    }

    function _t(t, e, n) {
      var i = e.dir,
          r = e.next,
          o = r || i,
          s = n && "parentNode" === o,
          a = M++;
      return e.first ? function (e, n, r) {
        for (; e = e[i];) if (1 === e.nodeType || s) return t(e, n, r);

        return !1;
      } : function (e, n, c) {
        var l,
            u,
            h,
            d = [w, a];

        if (c) {
          for (; e = e[i];) if ((1 === e.nodeType || s) && t(e, n, c)) return !0;
        } else for (; e = e[i];) if (1 === e.nodeType || s) if (u = (h = e[_] || (e[_] = {}))[e.uniqueID] || (h[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase()) e = e[i] || e;else {
          if ((l = u[o]) && l[0] === w && l[1] === a) return d[2] = l[2];
          if (u[o] = d, d[2] = t(e, n, c)) return !0;
        }

        return !1;
      };
    }

    function bt(t) {
      return t.length > 1 ? function (e, n, i) {
        for (var r = t.length; r--;) if (!t[r](e, n, i)) return !1;

        return !0;
      } : t[0];
    }

    function wt(t, e, n, i, r) {
      for (var o, s = [], a = 0, c = t.length, l = null != e; a < c; a++) (o = t[a]) && (n && !n(o, i, r) || (s.push(o), l && e.push(a)));

      return s;
    }

    function Mt(t, e, n, i, r, o) {
      return i && !i[_] && (i = Mt(i)), r && !r[_] && (r = Mt(r, o)), lt(function (o, s, a, c) {
        var l,
            u,
            h,
            d = [],
            p = [],
            f = s.length,
            m = o || function (t, e, n) {
          for (var i = 0, r = e.length; i < r; i++) at(t, e[i], n);

          return n;
        }(e || "*", a.nodeType ? [a] : a, []),
            g = !t || !o && e ? m : wt(m, d, t, a, c),
            v = n ? r || (o ? t : f || i) ? [] : s : g;

        if (n && n(g, v, a, c), i) for (l = wt(v, p), i(l, [], a, c), u = l.length; u--;) (h = l[u]) && (v[p[u]] = !(g[p[u]] = h));

        if (o) {
          if (r || t) {
            if (r) {
              for (l = [], u = v.length; u--;) (h = v[u]) && l.push(g[u] = h);

              r(null, v = [], l, c);
            }

            for (u = v.length; u--;) (h = v[u]) && (l = r ? I(o, h) : d[u]) > -1 && (o[l] = !(s[l] = h));
          }
        } else v = wt(v === s ? v.splice(f, v.length) : v), r ? r(null, s, v, c) : N.apply(s, v);
      });
    }

    function St(t) {
      for (var e, n, r, o = t.length, s = i.relative[t[0].type], a = s || i.relative[" "], c = s ? 1 : 0, u = _t(function (t) {
        return t === e;
      }, a, !0), h = _t(function (t) {
        return I(e, t) > -1;
      }, a, !0), d = [function (t, n, i) {
        var r = !s && (i || n !== l) || ((e = n).nodeType ? u(t, n, i) : h(t, n, i));
        return e = null, r;
      }]; c < o; c++) if (n = i.relative[t[c].type]) d = [_t(bt(d), n)];else {
        if ((n = i.filter[t[c].type].apply(null, t[c].matches))[_]) {
          for (r = ++c; r < o && !i.relative[t[r].type]; r++);

          return Mt(c > 1 && bt(d), c > 1 && xt(t.slice(0, c - 1).concat({
            value: " " === t[c - 2].type ? "*" : ""
          })).replace(G, "$1"), n, c < r && St(t.slice(c, r)), r < o && St(t = t.slice(r)), r < o && xt(t));
        }

        d.push(n);
      }

      return bt(d);
    }

    return yt.prototype = i.filters = i.pseudos, i.setFilters = new yt(), s = at.tokenize = function (t, e) {
      var n,
          r,
          o,
          s,
          a,
          c,
          l,
          u = E[t + " "];
      if (u) return e ? 0 : u.slice(0);

      for (a = t, c = [], l = i.preFilter; a;) {
        for (s in n && !(r = j.exec(a)) || (r && (a = a.slice(r[0].length) || a), c.push(o = [])), n = !1, (r = V.exec(a)) && (n = r.shift(), o.push({
          value: n,
          type: r[0].replace(G, " ")
        }), a = a.slice(n.length)), i.filter) !(r = Y[s].exec(a)) || l[s] && !(r = l[s](r)) || (n = r.shift(), o.push({
          value: n,
          type: s,
          matches: r
        }), a = a.slice(n.length));

        if (!n) break;
      }

      return e ? a.length : a ? at.error(t) : E(t, c).slice(0);
    }, a = at.compile = function (t, e) {
      var n,
          r = [],
          o = [],
          a = T[t + " "];

      if (!a) {
        for (e || (e = s(t)), n = e.length; n--;) (a = St(e[n]))[_] ? r.push(a) : o.push(a);

        (a = T(t, function (t, e) {
          var n = e.length > 0,
              r = t.length > 0,
              o = function (o, s, a, c, u) {
            var h,
                f,
                g,
                v = 0,
                y = "0",
                x = o && [],
                _ = [],
                b = l,
                M = o || r && i.find.TAG("*", u),
                S = w += null == b ? 1 : Math.random() || .1,
                E = M.length;

            for (u && (l = s == p || s || u); y !== E && null != (h = M[y]); y++) {
              if (r && h) {
                for (f = 0, s || h.ownerDocument == p || (d(h), a = !m); g = t[f++];) if (g(h, s || p, a)) {
                  c.push(h);
                  break;
                }

                u && (w = S);
              }

              n && ((h = !g && h) && v--, o && x.push(h));
            }

            if (v += y, n && y !== v) {
              for (f = 0; g = e[f++];) g(x, _, s, a);

              if (o) {
                if (v > 0) for (; y--;) x[y] || _[y] || (_[y] = P.call(c));
                _ = wt(_);
              }

              N.apply(c, _), u && !o && _.length > 0 && v + e.length > 1 && at.uniqueSort(c);
            }

            return u && (w = S, l = b), x;
          };

          return n ? lt(o) : o;
        }(o, r))).selector = t;
      }

      return a;
    }, c = at.select = function (t, e, n, r) {
      var o,
          c,
          l,
          u,
          h,
          d = "function" == typeof t && t,
          p = !r && s(t = d.selector || t);

      if (n = n || [], 1 === p.length) {
        if ((c = p[0] = p[0].slice(0)).length > 2 && "ID" === (l = c[0]).type && 9 === e.nodeType && m && i.relative[c[1].type]) {
          if (!(e = (i.find.ID(l.matches[0].replace(et, nt), e) || [])[0])) return n;
          d && (e = e.parentNode), t = t.slice(c.shift().value.length);
        }

        for (o = Y.needsContext.test(t) ? 0 : c.length; o-- && (l = c[o], !i.relative[u = l.type]);) if ((h = i.find[u]) && (r = h(l.matches[0].replace(et, nt), tt.test(c[0].type) && vt(e.parentNode) || e))) {
          if (c.splice(o, 1), !(t = r.length && xt(c))) return N.apply(n, r), n;
          break;
        }
      }

      return (d || a(t, p))(r, e, !m, n, !e || tt.test(t) && vt(e.parentNode) || e), n;
    }, n.sortStable = _.split("").sort(L).join("") === _, n.detectDuplicates = !!h, d(), n.sortDetached = ut(function (t) {
      return 1 & t.compareDocumentPosition(p.createElement("fieldset"));
    }), ut(function (t) {
      return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href");
    }) || ht("type|href|height|width", function (t, e, n) {
      if (!n) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2);
    }), n.attributes && ut(function (t) {
      return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value");
    }) || ht("value", function (t, e, n) {
      if (!n && "input" === t.nodeName.toLowerCase()) return t.defaultValue;
    }), ut(function (t) {
      return null == t.getAttribute("disabled");
    }) || ht(z, function (t, e, n) {
      var i;
      if (!n) return !0 === t[e] ? e.toLowerCase() : (i = t.getAttributeNode(e)) && i.specified ? i.value : null;
    }), at;
  }(t);

  _.find = w, (_.expr = w.selectors)[":"] = _.expr.pseudos, _.uniqueSort = _.unique = w.uniqueSort, _.text = w.getText, _.isXMLDoc = w.isXML, _.contains = w.contains, _.escapeSelector = w.escape;

  var M = function (t, e, n) {
    for (var i = [], r = void 0 !== n; (t = t[e]) && 9 !== t.nodeType;) if (1 === t.nodeType) {
      if (r && _(t).is(n)) break;
      i.push(t);
    }

    return i;
  },
      S = function (t, e) {
    for (var n = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && n.push(t);

    return n;
  },
      E = _.expr.match.needsContext;

  function T(t, e) {
    return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase();
  }

  var A = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

  function L(t, e, n) {
    return f(e) ? _.grep(t, function (t, i) {
      return !!e.call(t, i, t) !== n;
    }) : e.nodeType ? _.grep(t, function (t) {
      return t === e !== n;
    }) : "string" != typeof e ? _.grep(t, function (t) {
      return a.call(e, t) > -1 !== n;
    }) : _.filter(e, t, n);
  }

  _.filter = function (t, e, n) {
    var i = e[0];
    return n && (t = ":not(" + t + ")"), 1 === e.length && 1 === i.nodeType ? _.find.matchesSelector(i, t) ? [i] : [] : _.find.matches(t, _.grep(e, function (t) {
      return 1 === t.nodeType;
    }));
  }, _.fn.extend({
    find: function (t) {
      var e,
          n,
          i = this.length,
          r = this;
      if ("string" != typeof t) return this.pushStack(_(t).filter(function () {
        for (e = 0; e < i; e++) if (_.contains(r[e], this)) return !0;
      }));

      for (n = this.pushStack([]), e = 0; e < i; e++) _.find(t, r[e], n);

      return i > 1 ? _.uniqueSort(n) : n;
    },
    filter: function (t) {
      return this.pushStack(L(this, t || [], !1));
    },
    not: function (t) {
      return this.pushStack(L(this, t || [], !0));
    },
    is: function (t) {
      return !!L(this, "string" == typeof t && E.test(t) ? _(t) : t || [], !1).length;
    }
  });
  var C,
      R = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
  (_.fn.init = function (t, e, n) {
    var i, r;
    if (!t) return this;

    if (n = n || C, "string" == typeof t) {
      if (!(i = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : R.exec(t)) || !i[1] && e) return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);

      if (i[1]) {
        if (e = e instanceof _ ? e[0] : e, _.merge(this, _.parseHTML(i[1], e && e.nodeType ? e.ownerDocument || e : g, !0)), A.test(i[1]) && _.isPlainObject(e)) for (i in e) f(this[i]) ? this[i](e[i]) : this.attr(i, e[i]);
        return this;
      }

      return (r = g.getElementById(i[2])) && (this[0] = r, this.length = 1), this;
    }

    return t.nodeType ? (this[0] = t, this.length = 1, this) : f(t) ? void 0 !== n.ready ? n.ready(t) : t(_) : _.makeArray(t, this);
  }).prototype = _.fn, C = _(g);
  var P = /^(?:parents|prev(?:Until|All))/,
      O = {
    children: !0,
    contents: !0,
    next: !0,
    prev: !0
  };

  function N(t, e) {
    for (; (t = t[e]) && 1 !== t.nodeType;);

    return t;
  }

  _.fn.extend({
    has: function (t) {
      var e = _(t, this),
          n = e.length;

      return this.filter(function () {
        for (var t = 0; t < n; t++) if (_.contains(this, e[t])) return !0;
      });
    },
    closest: function (t, e) {
      var n,
          i = 0,
          r = this.length,
          o = [],
          s = "string" != typeof t && _(t);

      if (!E.test(t)) for (; i < r; i++) for (n = this[i]; n && n !== e; n = n.parentNode) if (n.nodeType < 11 && (s ? s.index(n) > -1 : 1 === n.nodeType && _.find.matchesSelector(n, t))) {
        o.push(n);
        break;
      }
      return this.pushStack(o.length > 1 ? _.uniqueSort(o) : o);
    },
    index: function (t) {
      return t ? "string" == typeof t ? a.call(_(t), this[0]) : a.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    },
    add: function (t, e) {
      return this.pushStack(_.uniqueSort(_.merge(this.get(), _(t, e))));
    },
    addBack: function (t) {
      return this.add(null == t ? this.prevObject : this.prevObject.filter(t));
    }
  }), _.each({
    parent: function (t) {
      var e = t.parentNode;
      return e && 11 !== e.nodeType ? e : null;
    },
    parents: function (t) {
      return M(t, "parentNode");
    },
    parentsUntil: function (t, e, n) {
      return M(t, "parentNode", n);
    },
    next: function (t) {
      return N(t, "nextSibling");
    },
    prev: function (t) {
      return N(t, "previousSibling");
    },
    nextAll: function (t) {
      return M(t, "nextSibling");
    },
    prevAll: function (t) {
      return M(t, "previousSibling");
    },
    nextUntil: function (t, e, n) {
      return M(t, "nextSibling", n);
    },
    prevUntil: function (t, e, n) {
      return M(t, "previousSibling", n);
    },
    siblings: function (t) {
      return S((t.parentNode || {}).firstChild, t);
    },
    children: function (t) {
      return S(t.firstChild);
    },
    contents: function (t) {
      return null != t.contentDocument && i(t.contentDocument) ? t.contentDocument : (T(t, "template") && (t = t.content || t), _.merge([], t.childNodes));
    }
  }, function (t, e) {
    _.fn[t] = function (n, i) {
      var r = _.map(this, e, n);

      return "Until" !== t.slice(-5) && (i = n), i && "string" == typeof i && (r = _.filter(i, r)), this.length > 1 && (O[t] || _.uniqueSort(r), P.test(t) && r.reverse()), this.pushStack(r);
    };
  });
  var D = /[^\x20\t\r\n\f]+/g;

  function I(t) {
    return t;
  }

  function z(t) {
    throw t;
  }

  function B(t, e, n, i) {
    var r;

    try {
      t && f(r = t.promise) ? r.call(t).done(e).fail(n) : t && f(r = t.then) ? r.call(t, e, n) : e.apply(void 0, [t].slice(i));
    } catch (t) {
      n.apply(void 0, [t]);
    }
  }

  _.Callbacks = function (t) {
    t = "string" == typeof t ? function (t) {
      var e = {};
      return _.each(t.match(D) || [], function (t, n) {
        e[n] = !0;
      }), e;
    }(t) : _.extend({}, t);

    var e,
        n,
        i,
        r,
        o = [],
        s = [],
        a = -1,
        c = function () {
      for (r = r || t.once, i = e = !0; s.length; a = -1) for (n = s.shift(); ++a < o.length;) !1 === o[a].apply(n[0], n[1]) && t.stopOnFalse && (a = o.length, n = !1);

      t.memory || (n = !1), e = !1, r && (o = n ? [] : "");
    },
        l = {
      add: function () {
        return o && (n && !e && (a = o.length - 1, s.push(n)), function e(n) {
          _.each(n, function (n, i) {
            f(i) ? t.unique && l.has(i) || o.push(i) : i && i.length && "string" !== x(i) && e(i);
          });
        }(arguments), n && !e && c()), this;
      },
      remove: function () {
        return _.each(arguments, function (t, e) {
          for (var n; (n = _.inArray(e, o, n)) > -1;) o.splice(n, 1), n <= a && a--;
        }), this;
      },
      has: function (t) {
        return t ? _.inArray(t, o) > -1 : o.length > 0;
      },
      empty: function () {
        return o && (o = []), this;
      },
      disable: function () {
        return r = s = [], o = n = "", this;
      },
      disabled: function () {
        return !o;
      },
      lock: function () {
        return r = s = [], n || e || (o = n = ""), this;
      },
      locked: function () {
        return !!r;
      },
      fireWith: function (t, n) {
        return r || (n = [t, (n = n || []).slice ? n.slice() : n], s.push(n), e || c()), this;
      },
      fire: function () {
        return l.fireWith(this, arguments), this;
      },
      fired: function () {
        return !!i;
      }
    };

    return l;
  }, _.extend({
    Deferred: function (e) {
      var n = [["notify", "progress", _.Callbacks("memory"), _.Callbacks("memory"), 2], ["resolve", "done", _.Callbacks("once memory"), _.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", _.Callbacks("once memory"), _.Callbacks("once memory"), 1, "rejected"]],
          i = "pending",
          r = {
        state: function () {
          return i;
        },
        always: function () {
          return o.done(arguments).fail(arguments), this;
        },
        catch: function (t) {
          return r.then(null, t);
        },
        pipe: function () {
          var t = arguments;
          return _.Deferred(function (e) {
            _.each(n, function (n, i) {
              var r = f(t[i[4]]) && t[i[4]];
              o[i[1]](function () {
                var t = r && r.apply(this, arguments);
                t && f(t.promise) ? t.promise().progress(e.notify).done(e.resolve).fail(e.reject) : e[i[0] + "With"](this, r ? [t] : arguments);
              });
            }), t = null;
          }).promise();
        },
        then: function (e, i, r) {
          var o = 0;

          function s(e, n, i, r) {
            return function () {
              var a = this,
                  c = arguments,
                  l = function () {
                var t, l;

                if (!(e < o)) {
                  if ((t = i.apply(a, c)) === n.promise()) throw new TypeError("Thenable self-resolution");
                  l = t && ("object" == typeof t || "function" == typeof t) && t.then, f(l) ? r ? l.call(t, s(o, n, I, r), s(o, n, z, r)) : (o++, l.call(t, s(o, n, I, r), s(o, n, z, r), s(o, n, I, n.notifyWith))) : (i !== I && (a = void 0, c = [t]), (r || n.resolveWith)(a, c));
                }
              },
                  u = r ? l : function () {
                try {
                  l();
                } catch (t) {
                  _.Deferred.exceptionHook && _.Deferred.exceptionHook(t, u.stackTrace), e + 1 >= o && (i !== z && (a = void 0, c = [t]), n.rejectWith(a, c));
                }
              };

              e ? u() : (_.Deferred.getStackHook && (u.stackTrace = _.Deferred.getStackHook()), t.setTimeout(u));
            };
          }

          return _.Deferred(function (t) {
            n[0][3].add(s(0, t, f(r) ? r : I, t.notifyWith)), n[1][3].add(s(0, t, f(e) ? e : I)), n[2][3].add(s(0, t, f(i) ? i : z));
          }).promise();
        },
        promise: function (t) {
          return null != t ? _.extend(t, r) : r;
        }
      },
          o = {};
      return _.each(n, function (t, e) {
        var s = e[2],
            a = e[5];
        r[e[1]] = s.add, a && s.add(function () {
          i = a;
        }, n[3 - t][2].disable, n[3 - t][3].disable, n[0][2].lock, n[0][3].lock), s.add(e[3].fire), o[e[0]] = function () {
          return o[e[0] + "With"](this === o ? void 0 : this, arguments), this;
        }, o[e[0] + "With"] = s.fireWith;
      }), r.promise(o), e && e.call(o, o), o;
    },
    when: function (t) {
      var e = arguments.length,
          n = e,
          i = Array(n),
          o = r.call(arguments),
          s = _.Deferred(),
          a = function (t) {
        return function (n) {
          i[t] = this, o[t] = arguments.length > 1 ? r.call(arguments) : n, --e || s.resolveWith(i, o);
        };
      };

      if (e <= 1 && (B(t, s.done(a(n)).resolve, s.reject, !e), "pending" === s.state() || f(o[n] && o[n].then))) return s.then();

      for (; n--;) B(o[n], a(n), s.reject);

      return s.promise();
    }
  });
  var k = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  _.Deferred.exceptionHook = function (e, n) {
    t.console && t.console.warn && e && k.test(e.name) && t.console.warn("jQuery.Deferred exception: " + e.message, e.stack, n);
  }, _.readyException = function (e) {
    t.setTimeout(function () {
      throw e;
    });
  };

  var H = _.Deferred();

  function F() {
    g.removeEventListener("DOMContentLoaded", F), t.removeEventListener("load", F), _.ready();
  }

  _.fn.ready = function (t) {
    return H.then(t).catch(function (t) {
      _.readyException(t);
    }), this;
  }, _.extend({
    isReady: !1,
    readyWait: 1,
    ready: function (t) {
      (!0 === t ? --_.readyWait : _.isReady) || (_.isReady = !0, !0 !== t && --_.readyWait > 0 || H.resolveWith(g, [_]));
    }
  }), _.ready.then = H.then, "complete" === g.readyState || "loading" !== g.readyState && !g.documentElement.doScroll ? t.setTimeout(_.ready) : (g.addEventListener("DOMContentLoaded", F), t.addEventListener("load", F));

  var U = function t(e, n, i, r, o, s, a) {
    var c = 0,
        l = e.length,
        u = null == i;
    if ("object" === x(i)) for (c in o = !0, i) t(e, n, c, i[c], !0, s, a);else if (void 0 !== r && (o = !0, f(r) || (a = !0), u && (a ? (n.call(e, r), n = null) : (u = n, n = function (t, e, n) {
      return u.call(_(t), n);
    })), n)) for (; c < l; c++) n(e[c], i, a ? r : r.call(e[c], c, n(e[c], i)));
    return o ? e : u ? n.call(e) : l ? n(e[0], i) : s;
  },
      G = /^-ms-/,
      j = /-([a-z])/g;

  function V(t, e) {
    return e.toUpperCase();
  }

  function W(t) {
    return t.replace(G, "ms-").replace(j, V);
  }

  var q = function (t) {
    return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType;
  };

  function X() {
    this.expando = _.expando + X.uid++;
  }

  X.uid = 1, X.prototype = {
    cache: function (t) {
      var e = t[this.expando];
      return e || (e = {}, q(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
        value: e,
        configurable: !0
      }))), e;
    },
    set: function (t, e, n) {
      var i,
          r = this.cache(t);
      if ("string" == typeof e) r[W(e)] = n;else for (i in e) r[W(i)] = e[i];
      return r;
    },
    get: function (t, e) {
      return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][W(e)];
    },
    access: function (t, e, n) {
      return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t, e, n), void 0 !== n ? n : e);
    },
    remove: function (t, e) {
      var n,
          i = t[this.expando];

      if (void 0 !== i) {
        if (void 0 !== e) {
          n = (e = Array.isArray(e) ? e.map(W) : (e = W(e)) in i ? [e] : e.match(D) || []).length;

          for (; n--;) delete i[e[n]];
        }

        (void 0 === e || _.isEmptyObject(i)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando]);
      }
    },
    hasData: function (t) {
      var e = t[this.expando];
      return void 0 !== e && !_.isEmptyObject(e);
    }
  };
  var Y = new X(),
      Z = new X(),
      J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      Q = /[A-Z]/g;

  function K(t, e, n) {
    var i;
    if (void 0 === n && 1 === t.nodeType) if (i = "data-" + e.replace(Q, "-$&").toLowerCase(), "string" == typeof (n = t.getAttribute(i))) {
      try {
        n = function (t) {
          return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : J.test(t) ? JSON.parse(t) : t);
        }(n);
      } catch (t) {}

      Z.set(t, e, n);
    } else n = void 0;
    return n;
  }

  _.extend({
    hasData: function (t) {
      return Z.hasData(t) || Y.hasData(t);
    },
    data: function (t, e, n) {
      return Z.access(t, e, n);
    },
    removeData: function (t, e) {
      Z.remove(t, e);
    },
    _data: function (t, e, n) {
      return Y.access(t, e, n);
    },
    _removeData: function (t, e) {
      Y.remove(t, e);
    }
  }), _.fn.extend({
    data: function (t, e) {
      var n,
          i,
          r,
          o = this[0],
          s = o && o.attributes;

      if (void 0 === t) {
        if (this.length && (r = Z.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
          for (n = s.length; n--;) s[n] && 0 === (i = s[n].name).indexOf("data-") && (i = W(i.slice(5)), K(o, i, r[i]));

          Y.set(o, "hasDataAttrs", !0);
        }

        return r;
      }

      return "object" == typeof t ? this.each(function () {
        Z.set(this, t);
      }) : U(this, function (e) {
        var n;
        if (o && void 0 === e) return void 0 !== (n = Z.get(o, t)) || void 0 !== (n = K(o, t)) ? n : void 0;
        this.each(function () {
          Z.set(this, t, e);
        });
      }, null, e, arguments.length > 1, null, !0);
    },
    removeData: function (t) {
      return this.each(function () {
        Z.remove(this, t);
      });
    }
  }), _.extend({
    queue: function (t, e, n) {
      var i;
      if (t) return e = (e || "fx") + "queue", i = Y.get(t, e), n && (!i || Array.isArray(n) ? i = Y.access(t, e, _.makeArray(n)) : i.push(n)), i || [];
    },
    dequeue: function (t, e) {
      var n = _.queue(t, e = e || "fx"),
          i = n.length,
          r = n.shift(),
          o = _._queueHooks(t, e);

      "inprogress" === r && (r = n.shift(), i--), r && ("fx" === e && n.unshift("inprogress"), delete o.stop, r.call(t, function () {
        _.dequeue(t, e);
      }, o)), !i && o && o.empty.fire();
    },
    _queueHooks: function (t, e) {
      var n = e + "queueHooks";
      return Y.get(t, n) || Y.access(t, n, {
        empty: _.Callbacks("once memory").add(function () {
          Y.remove(t, [e + "queue", n]);
        })
      });
    }
  }), _.fn.extend({
    queue: function (t, e) {
      var n = 2;
      return "string" != typeof t && (e = t, t = "fx", n--), arguments.length < n ? _.queue(this[0], t) : void 0 === e ? this : this.each(function () {
        var n = _.queue(this, t, e);

        _._queueHooks(this, t), "fx" === t && "inprogress" !== n[0] && _.dequeue(this, t);
      });
    },
    dequeue: function (t) {
      return this.each(function () {
        _.dequeue(this, t);
      });
    },
    clearQueue: function (t) {
      return this.queue(t || "fx", []);
    },
    promise: function (t, e) {
      var n,
          i = 1,
          r = _.Deferred(),
          o = this,
          s = this.length,
          a = function () {
        --i || r.resolveWith(o, [o]);
      };

      for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; s--;) (n = Y.get(o[s], t + "queueHooks")) && n.empty && (i++, n.empty.add(a));

      return a(), r.promise(e);
    }
  });

  var $ = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
      tt = new RegExp("^(?:([+-])=|)(" + $ + ")([a-z%]*)$", "i"),
      et = ["Top", "Right", "Bottom", "Left"],
      nt = g.documentElement,
      it = function (t) {
    return _.contains(t.ownerDocument, t);
  },
      rt = {
    composed: !0
  };

  nt.getRootNode && (it = function (t) {
    return _.contains(t.ownerDocument, t) || t.getRootNode(rt) === t.ownerDocument;
  });

  var ot = function (t, e) {
    return "none" === (t = e || t).style.display || "" === t.style.display && it(t) && "none" === _.css(t, "display");
  };

  function st(t, e, n, i) {
    var r,
        o,
        s = 20,
        a = i ? function () {
      return i.cur();
    } : function () {
      return _.css(t, e, "");
    },
        c = a(),
        l = n && n[3] || (_.cssNumber[e] ? "" : "px"),
        u = t.nodeType && (_.cssNumber[e] || "px" !== l && +c) && tt.exec(_.css(t, e));

    if (u && u[3] !== l) {
      for (c /= 2, l = l || u[3], u = +c || 1; s--;) _.style(t, e, u + l), (1 - o) * (1 - (o = a() / c || .5)) <= 0 && (s = 0), u /= o;

      _.style(t, e, (u *= 2) + l), n = n || [];
    }

    return n && (u = +u || +c || 0, r = n[1] ? u + (n[1] + 1) * n[2] : +n[2], i && (i.unit = l, i.start = u, i.end = r)), r;
  }

  var at = {};

  function ct(t) {
    var e,
        n = t.ownerDocument,
        i = t.nodeName,
        r = at[i];
    return r || (e = n.body.appendChild(n.createElement(i)), r = _.css(e, "display"), e.parentNode.removeChild(e), "none" === r && (r = "block"), at[i] = r, r);
  }

  function lt(t, e) {
    for (var n, i, r = [], o = 0, s = t.length; o < s; o++) (i = t[o]).style && (n = i.style.display, e ? ("none" === n && (r[o] = Y.get(i, "display") || null, r[o] || (i.style.display = "")), "" === i.style.display && ot(i) && (r[o] = ct(i))) : "none" !== n && (r[o] = "none", Y.set(i, "display", n)));

    for (o = 0; o < s; o++) null != r[o] && (t[o].style.display = r[o]);

    return t;
  }

  _.fn.extend({
    show: function () {
      return lt(this, !0);
    },
    hide: function () {
      return lt(this);
    },
    toggle: function (t) {
      return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function () {
        ot(this) ? _(this).show() : _(this).hide();
      });
    }
  });

  var ut,
      ht,
      dt = /^(?:checkbox|radio)$/i,
      pt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
      ft = /^$|^module$|\/(?:java|ecma)script/i;
  ut = g.createDocumentFragment().appendChild(g.createElement("div")), (ht = g.createElement("input")).setAttribute("type", "radio"), ht.setAttribute("checked", "checked"), ht.setAttribute("name", "t"), ut.appendChild(ht), p.checkClone = ut.cloneNode(!0).cloneNode(!0).lastChild.checked, ut.innerHTML = "<textarea>x</textarea>", p.noCloneChecked = !!ut.cloneNode(!0).lastChild.defaultValue, ut.innerHTML = "<option></option>", p.option = !!ut.lastChild;
  var mt = {
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };

  function gt(t, e) {
    var n;
    return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && T(t, e) ? _.merge([t], n) : n;
  }

  function vt(t, e) {
    for (var n = 0, i = t.length; n < i; n++) Y.set(t[n], "globalEval", !e || Y.get(e[n], "globalEval"));
  }

  mt.tbody = mt.tfoot = mt.colgroup = mt.caption = mt.thead, mt.th = mt.td, p.option || (mt.optgroup = mt.option = [1, "<select multiple='multiple'>", "</select>"]);
  var yt = /<|&#?\w+;/;

  function xt(t, e, n, i, r) {
    for (var o, s, a, c, l, u, h = e.createDocumentFragment(), d = [], p = 0, f = t.length; p < f; p++) if ((o = t[p]) || 0 === o) if ("object" === x(o)) _.merge(d, o.nodeType ? [o] : o);else if (yt.test(o)) {
      for (s = s || h.appendChild(e.createElement("div")), a = (pt.exec(o) || ["", ""])[1].toLowerCase(), c = mt[a] || mt._default, s.innerHTML = c[1] + _.htmlPrefilter(o) + c[2], u = c[0]; u--;) s = s.lastChild;

      _.merge(d, s.childNodes), (s = h.firstChild).textContent = "";
    } else d.push(e.createTextNode(o));

    for (h.textContent = "", p = 0; o = d[p++];) if (i && _.inArray(o, i) > -1) r && r.push(o);else if (l = it(o), s = gt(h.appendChild(o), "script"), l && vt(s), n) for (u = 0; o = s[u++];) ft.test(o.type || "") && n.push(o);

    return h;
  }

  var _t = /^key/,
      bt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      wt = /^([^.]*)(?:\.(.+)|)/;

  function Mt() {
    return !0;
  }

  function St() {
    return !1;
  }

  function Et(t, e) {
    return t === function () {
      try {
        return g.activeElement;
      } catch (t) {}
    }() == ("focus" === e);
  }

  function Tt(t, e, n, i, r, o) {
    var s, a;

    if ("object" == typeof e) {
      for (a in "string" != typeof n && (i = i || n, n = void 0), e) Tt(t, a, n, i, e[a], o);

      return t;
    }

    if (null == i && null == r ? (r = n, i = n = void 0) : null == r && ("string" == typeof n ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), !1 === r) r = St;else if (!r) return t;
    return 1 === o && (s = r, (r = function (t) {
      return _().off(t), s.apply(this, arguments);
    }).guid = s.guid || (s.guid = _.guid++)), t.each(function () {
      _.event.add(this, e, r, i, n);
    });
  }

  function At(t, e, n) {
    n ? (Y.set(t, e, !1), _.event.add(t, e, {
      namespace: !1,
      handler: function (t) {
        var i,
            o,
            s = Y.get(this, e);

        if (1 & t.isTrigger && this[e]) {
          if (s.length) (_.event.special[e] || {}).delegateType && t.stopPropagation();else if (s = r.call(arguments), Y.set(this, e, s), i = n(this, e), this[e](), s !== (o = Y.get(this, e)) || i ? Y.set(this, e, !1) : o = {}, s !== o) return t.stopImmediatePropagation(), t.preventDefault(), o.value;
        } else s.length && (Y.set(this, e, {
          value: _.event.trigger(_.extend(s[0], _.Event.prototype), s.slice(1), this)
        }), t.stopImmediatePropagation());
      }
    })) : void 0 === Y.get(t, e) && _.event.add(t, e, Mt);
  }

  _.event = {
    global: {},
    add: function (t, e, n, i, r) {
      var o,
          s,
          a,
          c,
          l,
          u,
          h,
          d,
          p,
          f,
          m,
          g = Y.get(t);
      if (q(t)) for (n.handler && (n = (o = n).handler, r = o.selector), r && _.find.matchesSelector(nt, r), n.guid || (n.guid = _.guid++), (c = g.events) || (c = g.events = Object.create(null)), (s = g.handle) || (s = g.handle = function (e) {
        return void 0 !== _ && _.event.triggered !== e.type ? _.event.dispatch.apply(t, arguments) : void 0;
      }), l = (e = (e || "").match(D) || [""]).length; l--;) p = m = (a = wt.exec(e[l]) || [])[1], f = (a[2] || "").split(".").sort(), p && (h = _.event.special[p] || {}, p = (r ? h.delegateType : h.bindType) || p, h = _.event.special[p] || {}, u = _.extend({
        type: p,
        origType: m,
        data: i,
        handler: n,
        guid: n.guid,
        selector: r,
        needsContext: r && _.expr.match.needsContext.test(r),
        namespace: f.join(".")
      }, o), (d = c[p]) || ((d = c[p] = []).delegateCount = 0, h.setup && !1 !== h.setup.call(t, i, f, s) || t.addEventListener && t.addEventListener(p, s)), h.add && (h.add.call(t, u), u.handler.guid || (u.handler.guid = n.guid)), r ? d.splice(d.delegateCount++, 0, u) : d.push(u), _.event.global[p] = !0);
    },
    remove: function (t, e, n, i, r) {
      var o,
          s,
          a,
          c,
          l,
          u,
          h,
          d,
          p,
          f,
          m,
          g = Y.hasData(t) && Y.get(t);

      if (g && (c = g.events)) {
        for (l = (e = (e || "").match(D) || [""]).length; l--;) if (p = m = (a = wt.exec(e[l]) || [])[1], f = (a[2] || "").split(".").sort(), p) {
          for (h = _.event.special[p] || {}, d = c[p = (i ? h.delegateType : h.bindType) || p] || [], a = a[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = o = d.length; o--;) u = d[o], !r && m !== u.origType || n && n.guid !== u.guid || a && !a.test(u.namespace) || i && i !== u.selector && ("**" !== i || !u.selector) || (d.splice(o, 1), u.selector && d.delegateCount--, h.remove && h.remove.call(t, u));

          s && !d.length && (h.teardown && !1 !== h.teardown.call(t, f, g.handle) || _.removeEvent(t, p, g.handle), delete c[p]);
        } else for (p in c) _.event.remove(t, p + e[l], n, i, !0);

        _.isEmptyObject(c) && Y.remove(t, "handle events");
      }
    },
    dispatch: function (t) {
      var e,
          n,
          i,
          r,
          o,
          s,
          a = new Array(arguments.length),
          c = _.event.fix(t),
          l = (Y.get(this, "events") || Object.create(null))[c.type] || [],
          u = _.event.special[c.type] || {};

      for (a[0] = c, e = 1; e < arguments.length; e++) a[e] = arguments[e];

      if (c.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, c)) {
        for (s = _.event.handlers.call(this, c, l), e = 0; (r = s[e++]) && !c.isPropagationStopped();) for (c.currentTarget = r.elem, n = 0; (o = r.handlers[n++]) && !c.isImmediatePropagationStopped();) c.rnamespace && !1 !== o.namespace && !c.rnamespace.test(o.namespace) || (c.handleObj = o, c.data = o.data, void 0 !== (i = ((_.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, a)) && !1 === (c.result = i) && (c.preventDefault(), c.stopPropagation()));

        return u.postDispatch && u.postDispatch.call(this, c), c.result;
      }
    },
    handlers: function (t, e) {
      var n,
          i,
          r,
          o,
          s,
          a = [],
          c = e.delegateCount,
          l = t.target;
      if (c && l.nodeType && !("click" === t.type && t.button >= 1)) for (; l !== this; l = l.parentNode || this) if (1 === l.nodeType && ("click" !== t.type || !0 !== l.disabled)) {
        for (o = [], s = {}, n = 0; n < c; n++) void 0 === s[r = (i = e[n]).selector + " "] && (s[r] = i.needsContext ? _(r, this).index(l) > -1 : _.find(r, this, null, [l]).length), s[r] && o.push(i);

        o.length && a.push({
          elem: l,
          handlers: o
        });
      }
      return l = this, c < e.length && a.push({
        elem: l,
        handlers: e.slice(c)
      }), a;
    },
    addProp: function (t, e) {
      Object.defineProperty(_.Event.prototype, t, {
        enumerable: !0,
        configurable: !0,
        get: f(e) ? function () {
          if (this.originalEvent) return e(this.originalEvent);
        } : function () {
          if (this.originalEvent) return this.originalEvent[t];
        },
        set: function (e) {
          Object.defineProperty(this, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: e
          });
        }
      });
    },
    fix: function (t) {
      return t[_.expando] ? t : new _.Event(t);
    },
    special: {
      load: {
        noBubble: !0
      },
      click: {
        setup: function (t) {
          var e = this || t;
          return dt.test(e.type) && e.click && T(e, "input") && At(e, "click", Mt), !1;
        },
        trigger: function (t) {
          var e = this || t;
          return dt.test(e.type) && e.click && T(e, "input") && At(e, "click"), !0;
        },
        _default: function (t) {
          var e = t.target;
          return dt.test(e.type) && e.click && T(e, "input") && Y.get(e, "click") || T(e, "a");
        }
      },
      beforeunload: {
        postDispatch: function (t) {
          void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result);
        }
      }
    }
  }, _.removeEvent = function (t, e, n) {
    t.removeEventListener && t.removeEventListener(e, n);
  }, (_.Event = function (t, e) {
    if (!(this instanceof _.Event)) return new _.Event(t, e);
    t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? Mt : St, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && _.extend(this, e), this.timeStamp = t && t.timeStamp || Date.now(), this[_.expando] = !0;
  }).prototype = {
    constructor: _.Event,
    isDefaultPrevented: St,
    isPropagationStopped: St,
    isImmediatePropagationStopped: St,
    isSimulated: !1,
    preventDefault: function () {
      var t = this.originalEvent;
      this.isDefaultPrevented = Mt, t && !this.isSimulated && t.preventDefault();
    },
    stopPropagation: function () {
      var t = this.originalEvent;
      this.isPropagationStopped = Mt, t && !this.isSimulated && t.stopPropagation();
    },
    stopImmediatePropagation: function () {
      var t = this.originalEvent;
      this.isImmediatePropagationStopped = Mt, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation();
    }
  }, _.each({
    altKey: !0,
    bubbles: !0,
    cancelable: !0,
    changedTouches: !0,
    ctrlKey: !0,
    detail: !0,
    eventPhase: !0,
    metaKey: !0,
    pageX: !0,
    pageY: !0,
    shiftKey: !0,
    view: !0,
    char: !0,
    code: !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pointerId: !0,
    pointerType: !0,
    screenX: !0,
    screenY: !0,
    targetTouches: !0,
    toElement: !0,
    touches: !0,
    which: function (t) {
      var e = t.button;
      return null == t.which && _t.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && bt.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which;
    }
  }, _.event.addProp), _.each({
    focus: "focusin",
    blur: "focusout"
  }, function (t, e) {
    _.event.special[t] = {
      setup: function () {
        return At(this, t, Et), !1;
      },
      trigger: function () {
        return At(this, t), !0;
      },
      delegateType: e
    };
  }), _.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (t, e) {
    _.event.special[t] = {
      delegateType: e,
      bindType: e,
      handle: function (t) {
        var n,
            i = this,
            r = t.relatedTarget,
            o = t.handleObj;
        return r && (r === i || _.contains(i, r)) || (t.type = o.origType, n = o.handler.apply(this, arguments), t.type = e), n;
      }
    };
  }), _.fn.extend({
    on: function (t, e, n, i) {
      return Tt(this, t, e, n, i);
    },
    one: function (t, e, n, i) {
      return Tt(this, t, e, n, i, 1);
    },
    off: function (t, e, n) {
      var i, r;
      if (t && t.preventDefault && t.handleObj) return i = t.handleObj, _(t.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;

      if ("object" == typeof t) {
        for (r in t) this.off(r, e, t[r]);

        return this;
      }

      return !1 !== e && "function" != typeof e || (n = e, e = void 0), !1 === n && (n = St), this.each(function () {
        _.event.remove(this, t, n, e);
      });
    }
  });
  var Lt = /<script|<style|<link/i,
      Ct = /checked\s*(?:[^=]|=\s*.checked.)/i,
      Rt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  function Pt(t, e) {
    return T(t, "table") && T(11 !== e.nodeType ? e : e.firstChild, "tr") && _(t).children("tbody")[0] || t;
  }

  function Ot(t) {
    return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t;
  }

  function Nt(t) {
    return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t;
  }

  function Dt(t, e) {
    var n, i, r, o, s, a;

    if (1 === e.nodeType) {
      if (Y.hasData(t) && (a = Y.get(t).events)) for (r in Y.remove(e, "handle events"), a) for (n = 0, i = a[r].length; n < i; n++) _.event.add(e, r, a[r][n]);
      Z.hasData(t) && (o = Z.access(t), s = _.extend({}, o), Z.set(e, s));
    }
  }

  function It(t, e) {
    var n = e.nodeName.toLowerCase();
    "input" === n && dt.test(t.type) ? e.checked = t.checked : "input" !== n && "textarea" !== n || (e.defaultValue = t.defaultValue);
  }

  function zt(t, e, n, i) {
    e = o(e);
    var r,
        s,
        a,
        c,
        l,
        u,
        h = 0,
        d = t.length,
        m = d - 1,
        g = e[0],
        v = f(g);
    if (v || d > 1 && "string" == typeof g && !p.checkClone && Ct.test(g)) return t.each(function (r) {
      var o = t.eq(r);
      v && (e[0] = g.call(this, r, o.html())), zt(o, e, n, i);
    });

    if (d && (s = (r = xt(e, t[0].ownerDocument, !1, t, i)).firstChild, 1 === r.childNodes.length && (r = s), s || i)) {
      for (c = (a = _.map(gt(r, "script"), Ot)).length; h < d; h++) l = r, h !== m && (l = _.clone(l, !0, !0), c && _.merge(a, gt(l, "script"))), n.call(t[h], l, h);

      if (c) for (u = a[a.length - 1].ownerDocument, _.map(a, Nt), h = 0; h < c; h++) l = a[h], ft.test(l.type || "") && !Y.access(l, "globalEval") && _.contains(u, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? _._evalUrl && !l.noModule && _._evalUrl(l.src, {
        nonce: l.nonce || l.getAttribute("nonce")
      }, u) : y(l.textContent.replace(Rt, ""), l, u));
    }

    return t;
  }

  function Bt(t, e, n) {
    for (var i, r = e ? _.filter(e, t) : t, o = 0; null != (i = r[o]); o++) n || 1 !== i.nodeType || _.cleanData(gt(i)), i.parentNode && (n && it(i) && vt(gt(i, "script")), i.parentNode.removeChild(i));

    return t;
  }

  _.extend({
    htmlPrefilter: function (t) {
      return t;
    },
    clone: function (t, e, n) {
      var i,
          r,
          o,
          s,
          a = t.cloneNode(!0),
          c = it(t);
      if (!(p.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || _.isXMLDoc(t))) for (s = gt(a), i = 0, r = (o = gt(t)).length; i < r; i++) It(o[i], s[i]);
      if (e) if (n) for (o = o || gt(t), s = s || gt(a), i = 0, r = o.length; i < r; i++) Dt(o[i], s[i]);else Dt(t, a);
      return (s = gt(a, "script")).length > 0 && vt(s, !c && gt(t, "script")), a;
    },
    cleanData: function (t) {
      for (var e, n, i, r = _.event.special, o = 0; void 0 !== (n = t[o]); o++) if (q(n)) {
        if (e = n[Y.expando]) {
          if (e.events) for (i in e.events) r[i] ? _.event.remove(n, i) : _.removeEvent(n, i, e.handle);
          n[Y.expando] = void 0;
        }

        n[Z.expando] && (n[Z.expando] = void 0);
      }
    }
  }), _.fn.extend({
    detach: function (t) {
      return Bt(this, t, !0);
    },
    remove: function (t) {
      return Bt(this, t);
    },
    text: function (t) {
      return U(this, function (t) {
        return void 0 === t ? _.text(this) : this.empty().each(function () {
          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t);
        });
      }, null, t, arguments.length);
    },
    append: function () {
      return zt(this, arguments, function (t) {
        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Pt(this, t).appendChild(t);
      });
    },
    prepend: function () {
      return zt(this, arguments, function (t) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var e = Pt(this, t);
          e.insertBefore(t, e.firstChild);
        }
      });
    },
    before: function () {
      return zt(this, arguments, function (t) {
        this.parentNode && this.parentNode.insertBefore(t, this);
      });
    },
    after: function () {
      return zt(this, arguments, function (t) {
        this.parentNode && this.parentNode.insertBefore(t, this.nextSibling);
      });
    },
    empty: function () {
      for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (_.cleanData(gt(t, !1)), t.textContent = "");

      return this;
    },
    clone: function (t, e) {
      return t = null != t && t, e = null == e ? t : e, this.map(function () {
        return _.clone(this, t, e);
      });
    },
    html: function (t) {
      return U(this, function (t) {
        var e = this[0] || {},
            n = 0,
            i = this.length;
        if (void 0 === t && 1 === e.nodeType) return e.innerHTML;

        if ("string" == typeof t && !Lt.test(t) && !mt[(pt.exec(t) || ["", ""])[1].toLowerCase()]) {
          t = _.htmlPrefilter(t);

          try {
            for (; n < i; n++) 1 === (e = this[n] || {}).nodeType && (_.cleanData(gt(e, !1)), e.innerHTML = t);

            e = 0;
          } catch (t) {}
        }

        e && this.empty().append(t);
      }, null, t, arguments.length);
    },
    replaceWith: function () {
      var t = [];
      return zt(this, arguments, function (e) {
        var n = this.parentNode;
        _.inArray(this, t) < 0 && (_.cleanData(gt(this)), n && n.replaceChild(e, this));
      }, t);
    }
  }), _.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (t, e) {
    _.fn[t] = function (t) {
      for (var n, i = [], r = _(t), o = r.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), _(r[a])[e](n), s.apply(i, n.get());

      return this.pushStack(i);
    };
  });

  var kt = new RegExp("^(" + $ + ")(?!px)[a-z%]+$", "i"),
      Ht = function (e) {
    var n = e.ownerDocument.defaultView;
    return n && n.opener || (n = t), n.getComputedStyle(e);
  },
      Ft = function (t, e, n) {
    var i,
        r,
        o = {};

    for (r in e) o[r] = t.style[r], t.style[r] = e[r];

    for (r in i = n.call(t), e) t.style[r] = o[r];

    return i;
  },
      Ut = new RegExp(et.join("|"), "i");

  function Gt(t, e, n) {
    var i,
        r,
        o,
        s,
        a = t.style;
    return (n = n || Ht(t)) && ("" !== (s = n.getPropertyValue(e) || n[e]) || it(t) || (s = _.style(t, e)), !p.pixelBoxStyles() && kt.test(s) && Ut.test(e) && (i = a.width, r = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = s, s = n.width, a.width = i, a.minWidth = r, a.maxWidth = o)), void 0 !== s ? s + "" : s;
  }

  function jt(t, e) {
    return {
      get: function () {
        if (!t()) return (this.get = e).apply(this, arguments);
        delete this.get;
      }
    };
  }

  !function () {
    function e() {
      if (u) {
        l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", nt.appendChild(l).appendChild(u);
        var e = t.getComputedStyle(u);
        i = "1%" !== e.top, c = 12 === n(e.marginLeft), u.style.right = "60%", s = 36 === n(e.right), r = 36 === n(e.width), u.style.position = "absolute", o = 12 === n(u.offsetWidth / 3), nt.removeChild(l), u = null;
      }
    }

    function n(t) {
      return Math.round(parseFloat(t));
    }

    var i,
        r,
        o,
        s,
        a,
        c,
        l = g.createElement("div"),
        u = g.createElement("div");
    u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", p.clearCloneStyle = "content-box" === u.style.backgroundClip, _.extend(p, {
      boxSizingReliable: function () {
        return e(), r;
      },
      pixelBoxStyles: function () {
        return e(), s;
      },
      pixelPosition: function () {
        return e(), i;
      },
      reliableMarginLeft: function () {
        return e(), c;
      },
      scrollboxSize: function () {
        return e(), o;
      },
      reliableTrDimensions: function () {
        var e, n, i, r;
        return null == a && (e = g.createElement("table"), n = g.createElement("tr"), i = g.createElement("div"), e.style.cssText = "position:absolute;left:-11111px", n.style.height = "1px", i.style.height = "9px", nt.appendChild(e).appendChild(n).appendChild(i), r = t.getComputedStyle(n), a = parseInt(r.height) > 3, nt.removeChild(e)), a;
      }
    }));
  }();
  var Vt = ["Webkit", "Moz", "ms"],
      Wt = g.createElement("div").style,
      qt = {};

  function Xt(t) {
    return _.cssProps[t] || qt[t] || (t in Wt ? t : qt[t] = function (t) {
      for (var e = t[0].toUpperCase() + t.slice(1), n = Vt.length; n--;) if ((t = Vt[n] + e) in Wt) return t;
    }(t) || t);
  }

  var Yt = /^(none|table(?!-c[ea]).+)/,
      Zt = /^--/,
      Jt = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      Qt = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function Kt(t, e, n) {
    var i = tt.exec(e);
    return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : e;
  }

  function $t(t, e, n, i, r, o) {
    var s = "width" === e ? 1 : 0,
        a = 0,
        c = 0;
    if (n === (i ? "border" : "content")) return 0;

    for (; s < 4; s += 2) "margin" === n && (c += _.css(t, n + et[s], !0, r)), i ? ("content" === n && (c -= _.css(t, "padding" + et[s], !0, r)), "margin" !== n && (c -= _.css(t, "border" + et[s] + "Width", !0, r))) : (c += _.css(t, "padding" + et[s], !0, r), "padding" !== n ? c += _.css(t, "border" + et[s] + "Width", !0, r) : a += _.css(t, "border" + et[s] + "Width", !0, r));

    return !i && o >= 0 && (c += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - o - c - a - .5)) || 0), c;
  }

  function te(t, e, n) {
    var i = Ht(t),
        r = (!p.boxSizingReliable() || n) && "border-box" === _.css(t, "boxSizing", !1, i),
        o = r,
        s = Gt(t, e, i),
        a = "offset" + e[0].toUpperCase() + e.slice(1);

    if (kt.test(s)) {
      if (!n) return s;
      s = "auto";
    }

    return (!p.boxSizingReliable() && r || !p.reliableTrDimensions() && T(t, "tr") || "auto" === s || !parseFloat(s) && "inline" === _.css(t, "display", !1, i)) && t.getClientRects().length && (r = "border-box" === _.css(t, "boxSizing", !1, i), (o = a in t) && (s = t[a])), (s = parseFloat(s) || 0) + $t(t, e, n || (r ? "border" : "content"), o, i, s) + "px";
  }

  function ee(t, e, n, i, r) {
    return new ee.prototype.init(t, e, n, i, r);
  }

  _.extend({
    cssHooks: {
      opacity: {
        get: function (t, e) {
          if (e) {
            var n = Gt(t, "opacity");
            return "" === n ? "1" : n;
          }
        }
      }
    },
    cssNumber: {
      animationIterationCount: !0,
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      gridArea: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnStart: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowStart: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {},
    style: function (t, e, n, i) {
      if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
        var r,
            o,
            s,
            a = W(e),
            c = Zt.test(e),
            l = t.style;
        if (c || (e = Xt(a)), s = _.cssHooks[e] || _.cssHooks[a], void 0 === n) return s && "get" in s && void 0 !== (r = s.get(t, !1, i)) ? r : l[e];
        "string" == (o = typeof n) && (r = tt.exec(n)) && r[1] && (n = st(t, e, r), o = "number"), null != n && n == n && ("number" !== o || c || (n += r && r[3] || (_.cssNumber[a] ? "" : "px")), p.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (l[e] = "inherit"), s && "set" in s && void 0 === (n = s.set(t, n, i)) || (c ? l.setProperty(e, n) : l[e] = n));
      }
    },
    css: function (t, e, n, i) {
      var r,
          o,
          s,
          a = W(e);
      return Zt.test(e) || (e = Xt(a)), (s = _.cssHooks[e] || _.cssHooks[a]) && "get" in s && (r = s.get(t, !0, n)), void 0 === r && (r = Gt(t, e, i)), "normal" === r && e in Qt && (r = Qt[e]), "" === n || n ? (o = parseFloat(r), !0 === n || isFinite(o) ? o || 0 : r) : r;
    }
  }), _.each(["height", "width"], function (t, e) {
    _.cssHooks[e] = {
      get: function (t, n, i) {
        if (n) return !Yt.test(_.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? te(t, e, i) : Ft(t, Jt, function () {
          return te(t, e, i);
        });
      },
      set: function (t, n, i) {
        var r,
            o = Ht(t),
            s = !p.scrollboxSize() && "absolute" === o.position,
            a = (s || i) && "border-box" === _.css(t, "boxSizing", !1, o),
            c = i ? $t(t, e, i, a, o) : 0;

        return a && s && (c -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(o[e]) - $t(t, e, "border", !1, o) - .5)), c && (r = tt.exec(n)) && "px" !== (r[3] || "px") && (t.style[e] = n, n = _.css(t, e)), Kt(0, n, c);
      }
    };
  }), _.cssHooks.marginLeft = jt(p.reliableMarginLeft, function (t, e) {
    if (e) return (parseFloat(Gt(t, "marginLeft")) || t.getBoundingClientRect().left - Ft(t, {
      marginLeft: 0
    }, function () {
      return t.getBoundingClientRect().left;
    })) + "px";
  }), _.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (t, e) {
    _.cssHooks[t + e] = {
      expand: function (n) {
        for (var i = 0, r = {}, o = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++) r[t + et[i] + e] = o[i] || o[i - 2] || o[0];

        return r;
      }
    }, "margin" !== t && (_.cssHooks[t + e].set = Kt);
  }), _.fn.extend({
    css: function (t, e) {
      return U(this, function (t, e, n) {
        var i,
            r,
            o = {},
            s = 0;

        if (Array.isArray(e)) {
          for (i = Ht(t), r = e.length; s < r; s++) o[e[s]] = _.css(t, e[s], !1, i);

          return o;
        }

        return void 0 !== n ? _.style(t, e, n) : _.css(t, e);
      }, t, e, arguments.length > 1);
    }
  }), _.Tween = ee, ee.prototype = {
    constructor: ee,
    init: function (t, e, n, i, r, o) {
      this.elem = t, this.prop = n, this.easing = r || _.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = i, this.unit = o || (_.cssNumber[n] ? "" : "px");
    },
    cur: function () {
      var t = ee.propHooks[this.prop];
      return t && t.get ? t.get(this) : ee.propHooks._default.get(this);
    },
    run: function (t) {
      var e,
          n = ee.propHooks[this.prop];
      return this.options.duration ? this.pos = e = _.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : ee.propHooks._default.set(this), this;
    }
  }, ee.prototype.init.prototype = ee.prototype, ee.propHooks = {
    _default: {
      get: function (t) {
        var e;
        return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = _.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0;
      },
      set: function (t) {
        _.fx.step[t.prop] ? _.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !_.cssHooks[t.prop] && null == t.elem.style[Xt(t.prop)] ? t.elem[t.prop] = t.now : _.style(t.elem, t.prop, t.now + t.unit);
      }
    }
  }, ee.propHooks.scrollTop = ee.propHooks.scrollLeft = {
    set: function (t) {
      t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now);
    }
  }, _.easing = {
    linear: function (t) {
      return t;
    },
    swing: function (t) {
      return .5 - Math.cos(t * Math.PI) / 2;
    },
    _default: "swing"
  }, (_.fx = ee.prototype.init).step = {};
  var ne,
      ie,
      re = /^(?:toggle|show|hide)$/,
      oe = /queueHooks$/;

  function se() {
    ie && (!1 === g.hidden && t.requestAnimationFrame ? t.requestAnimationFrame(se) : t.setTimeout(se, _.fx.interval), _.fx.tick());
  }

  function ae() {
    return t.setTimeout(function () {
      ne = void 0;
    }), ne = Date.now();
  }

  function ce(t, e) {
    var n,
        i = 0,
        r = {
      height: t
    };

    for (e = e ? 1 : 0; i < 4; i += 2 - e) r["margin" + (n = et[i])] = r["padding" + n] = t;

    return e && (r.opacity = r.width = t), r;
  }

  function le(t, e, n) {
    for (var i, r = (ue.tweeners[e] || []).concat(ue.tweeners["*"]), o = 0, s = r.length; o < s; o++) if (i = r[o].call(n, e, t)) return i;
  }

  function ue(t, e, n) {
    var i,
        r,
        o = 0,
        s = ue.prefilters.length,
        a = _.Deferred().always(function () {
      delete c.elem;
    }),
        c = function () {
      if (r) return !1;

      for (var e = ne || ae(), n = Math.max(0, l.startTime + l.duration - e), i = 1 - (n / l.duration || 0), o = 0, s = l.tweens.length; o < s; o++) l.tweens[o].run(i);

      return a.notifyWith(t, [l, i, n]), i < 1 && s ? n : (s || a.notifyWith(t, [l, 1, 0]), a.resolveWith(t, [l]), !1);
    },
        l = a.promise({
      elem: t,
      props: _.extend({}, e),
      opts: _.extend(!0, {
        specialEasing: {},
        easing: _.easing._default
      }, n),
      originalProperties: e,
      originalOptions: n,
      startTime: ne || ae(),
      duration: n.duration,
      tweens: [],
      createTween: function (e, n) {
        var i = _.Tween(t, l.opts, e, n, l.opts.specialEasing[e] || l.opts.easing);

        return l.tweens.push(i), i;
      },
      stop: function (e) {
        var n = 0,
            i = e ? l.tweens.length : 0;
        if (r) return this;

        for (r = !0; n < i; n++) l.tweens[n].run(1);

        return e ? (a.notifyWith(t, [l, 1, 0]), a.resolveWith(t, [l, e])) : a.rejectWith(t, [l, e]), this;
      }
    }),
        u = l.props;

    for (function (t, e) {
      var n, i, r, o, s;

      for (n in t) if (r = e[i = W(n)], o = t[n], Array.isArray(o) && (r = o[1], o = t[n] = o[0]), n !== i && (t[i] = o, delete t[n]), (s = _.cssHooks[i]) && ("expand" in s)) for (n in o = s.expand(o), delete t[i], o) (n in t) || (t[n] = o[n], e[n] = r);else e[i] = r;
    }(u, l.opts.specialEasing); o < s; o++) if (i = ue.prefilters[o].call(l, t, u, l.opts)) return f(i.stop) && (_._queueHooks(l.elem, l.opts.queue).stop = i.stop.bind(i)), i;

    return _.map(u, le, l), f(l.opts.start) && l.opts.start.call(t, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), _.fx.timer(_.extend(c, {
      elem: t,
      anim: l,
      queue: l.opts.queue
    })), l;
  }

  _.Animation = _.extend(ue, {
    tweeners: {
      "*": [function (t, e) {
        var n = this.createTween(t, e);
        return st(n.elem, t, tt.exec(e), n), n;
      }]
    },
    tweener: function (t, e) {
      f(t) ? (e = t, t = ["*"]) : t = t.match(D);

      for (var n, i = 0, r = t.length; i < r; i++) n = t[i], ue.tweeners[n] = ue.tweeners[n] || [], ue.tweeners[n].unshift(e);
    },
    prefilters: [function (t, e, n) {
      var i,
          r,
          o,
          s,
          a,
          c,
          l,
          u,
          h = "width" in e || "height" in e,
          d = this,
          p = {},
          f = t.style,
          m = t.nodeType && ot(t),
          g = Y.get(t, "fxshow");

      for (i in n.queue || (null == (s = _._queueHooks(t, "fx")).unqueued && (s.unqueued = 0, a = s.empty.fire, s.empty.fire = function () {
        s.unqueued || a();
      }), s.unqueued++, d.always(function () {
        d.always(function () {
          s.unqueued--, _.queue(t, "fx").length || s.empty.fire();
        });
      })), e) if (r = e[i], re.test(r)) {
        if (delete e[i], o = o || "toggle" === r, r === (m ? "hide" : "show")) {
          if ("show" !== r || !g || void 0 === g[i]) continue;
          m = !0;
        }

        p[i] = g && g[i] || _.style(t, i);
      }

      if ((c = !_.isEmptyObject(e)) || !_.isEmptyObject(p)) for (i in h && 1 === t.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], null == (l = g && g.display) && (l = Y.get(t, "display")), "none" === (u = _.css(t, "display")) && (l ? u = l : (lt([t], !0), l = t.style.display || l, u = _.css(t, "display"), lt([t]))), ("inline" === u || "inline-block" === u && null != l) && "none" === _.css(t, "float") && (c || (d.done(function () {
        f.display = l;
      }), null == l && (u = f.display, l = "none" === u ? "" : u)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", d.always(function () {
        f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2];
      })), c = !1, p) c || (g ? "hidden" in g && (m = g.hidden) : g = Y.access(t, "fxshow", {
        display: l
      }), o && (g.hidden = !m), m && lt([t], !0), d.done(function () {
        for (i in m || lt([t]), Y.remove(t, "fxshow"), p) _.style(t, i, p[i]);
      })), c = le(m ? g[i] : 0, i, d), i in g || (g[i] = c.start, m && (c.end = c.start, c.start = 0));
    }],
    prefilter: function (t, e) {
      e ? ue.prefilters.unshift(t) : ue.prefilters.push(t);
    }
  }), _.speed = function (t, e, n) {
    var i = t && "object" == typeof t ? _.extend({}, t) : {
      complete: n || !n && e || f(t) && t,
      duration: t,
      easing: n && e || e && !f(e) && e
    };
    return _.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in _.fx.speeds ? i.duration = _.fx.speeds[i.duration] : i.duration = _.fx.speeds._default), null != i.queue && !0 !== i.queue || (i.queue = "fx"), i.old = i.complete, i.complete = function () {
      f(i.old) && i.old.call(this), i.queue && _.dequeue(this, i.queue);
    }, i;
  }, _.fn.extend({
    fadeTo: function (t, e, n, i) {
      return this.filter(ot).css("opacity", 0).show().end().animate({
        opacity: e
      }, t, n, i);
    },
    animate: function (t, e, n, i) {
      var r = _.isEmptyObject(t),
          o = _.speed(e, n, i),
          s = function () {
        var e = ue(this, _.extend({}, t), o);
        (r || Y.get(this, "finish")) && e.stop(!0);
      };

      return s.finish = s, r || !1 === o.queue ? this.each(s) : this.queue(o.queue, s);
    },
    stop: function (t, e, n) {
      var i = function (t) {
        var e = t.stop;
        delete t.stop, e(n);
      };

      return "string" != typeof t && (n = e, e = t, t = void 0), e && this.queue(t || "fx", []), this.each(function () {
        var e = !0,
            r = null != t && t + "queueHooks",
            o = _.timers,
            s = Y.get(this);
        if (r) s[r] && s[r].stop && i(s[r]);else for (r in s) s[r] && s[r].stop && oe.test(r) && i(s[r]);

        for (r = o.length; r--;) o[r].elem !== this || null != t && o[r].queue !== t || (o[r].anim.stop(n), e = !1, o.splice(r, 1));

        !e && n || _.dequeue(this, t);
      });
    },
    finish: function (t) {
      return !1 !== t && (t = t || "fx"), this.each(function () {
        var e,
            n = Y.get(this),
            i = n[t + "queue"],
            r = n[t + "queueHooks"],
            o = _.timers,
            s = i ? i.length : 0;

        for (n.finish = !0, _.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = o.length; e--;) o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));

        for (e = 0; e < s; e++) i[e] && i[e].finish && i[e].finish.call(this);

        delete n.finish;
      });
    }
  }), _.each(["toggle", "show", "hide"], function (t, e) {
    var n = _.fn[e];

    _.fn[e] = function (t, i, r) {
      return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(ce(e, !0), t, i, r);
    };
  }), _.each({
    slideDown: ce("show"),
    slideUp: ce("hide"),
    slideToggle: ce("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (t, e) {
    _.fn[t] = function (t, n, i) {
      return this.animate(e, t, n, i);
    };
  }), _.timers = [], _.fx.tick = function () {
    var t,
        e = 0,
        n = _.timers;

    for (ne = Date.now(); e < n.length; e++) (t = n[e])() || n[e] !== t || n.splice(e--, 1);

    n.length || _.fx.stop(), ne = void 0;
  }, _.fx.timer = function (t) {
    _.timers.push(t), _.fx.start();
  }, _.fx.interval = 13, _.fx.start = function () {
    ie || (ie = !0, se());
  }, _.fx.stop = function () {
    ie = null;
  }, _.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  }, _.fn.delay = function (e, n) {
    return e = _.fx && _.fx.speeds[e] || e, n = n || "fx", this.queue(n, function (n, i) {
      var r = t.setTimeout(n, e);

      i.stop = function () {
        t.clearTimeout(r);
      };
    });
  }, function () {
    var t = g.createElement("input"),
        e = g.createElement("select").appendChild(g.createElement("option"));
    t.type = "checkbox", p.checkOn = "" !== t.value, p.optSelected = e.selected, (t = g.createElement("input")).value = "t", t.type = "radio", p.radioValue = "t" === t.value;
  }();
  var he,
      de = _.expr.attrHandle;
  _.fn.extend({
    attr: function (t, e) {
      return U(this, _.attr, t, e, arguments.length > 1);
    },
    removeAttr: function (t) {
      return this.each(function () {
        _.removeAttr(this, t);
      });
    }
  }), _.extend({
    attr: function (t, e, n) {
      var i,
          r,
          o = t.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return void 0 === t.getAttribute ? _.prop(t, e, n) : (1 === o && _.isXMLDoc(t) || (r = _.attrHooks[e.toLowerCase()] || (_.expr.match.bool.test(e) ? he : void 0)), void 0 !== n ? null === n ? void _.removeAttr(t, e) : r && "set" in r && void 0 !== (i = r.set(t, n, e)) ? i : (t.setAttribute(e, n + ""), n) : r && "get" in r && null !== (i = r.get(t, e)) ? i : null == (i = _.find.attr(t, e)) ? void 0 : i);
    },
    attrHooks: {
      type: {
        set: function (t, e) {
          if (!p.radioValue && "radio" === e && T(t, "input")) {
            var n = t.value;
            return t.setAttribute("type", e), n && (t.value = n), e;
          }
        }
      }
    },
    removeAttr: function (t, e) {
      var n,
          i = 0,
          r = e && e.match(D);
      if (r && 1 === t.nodeType) for (; n = r[i++];) t.removeAttribute(n);
    }
  }), he = {
    set: function (t, e, n) {
      return !1 === e ? _.removeAttr(t, n) : t.setAttribute(n, n), n;
    }
  }, _.each(_.expr.match.bool.source.match(/\w+/g), function (t, e) {
    var n = de[e] || _.find.attr;

    de[e] = function (t, e, i) {
      var r,
          o,
          s = e.toLowerCase();
      return i || (o = de[s], de[s] = r, r = null != n(t, e, i) ? s : null, de[s] = o), r;
    };
  });
  var pe = /^(?:input|select|textarea|button)$/i,
      fe = /^(?:a|area)$/i;

  function me(t) {
    return (t.match(D) || []).join(" ");
  }

  function ge(t) {
    return t.getAttribute && t.getAttribute("class") || "";
  }

  function ve(t) {
    return Array.isArray(t) ? t : "string" == typeof t && t.match(D) || [];
  }

  _.fn.extend({
    prop: function (t, e) {
      return U(this, _.prop, t, e, arguments.length > 1);
    },
    removeProp: function (t) {
      return this.each(function () {
        delete this[_.propFix[t] || t];
      });
    }
  }), _.extend({
    prop: function (t, e, n) {
      var i,
          r,
          o = t.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return 1 === o && _.isXMLDoc(t) || (e = _.propFix[e] || e, r = _.propHooks[e]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(t, n, e)) ? i : t[e] = n : r && "get" in r && null !== (i = r.get(t, e)) ? i : t[e];
    },
    propHooks: {
      tabIndex: {
        get: function (t) {
          var e = _.find.attr(t, "tabindex");

          return e ? parseInt(e, 10) : pe.test(t.nodeName) || fe.test(t.nodeName) && t.href ? 0 : -1;
        }
      }
    },
    propFix: {
      for: "htmlFor",
      class: "className"
    }
  }), p.optSelected || (_.propHooks.selected = {
    get: function (t) {
      var e = t.parentNode;
      return e && e.parentNode && e.parentNode.selectedIndex, null;
    },
    set: function (t) {
      var e = t.parentNode;
      e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex);
    }
  }), _.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    _.propFix[this.toLowerCase()] = this;
  }), _.fn.extend({
    addClass: function (t) {
      var e,
          n,
          i,
          r,
          o,
          s,
          a,
          c = 0;
      if (f(t)) return this.each(function (e) {
        _(this).addClass(t.call(this, e, ge(this)));
      });
      if ((e = ve(t)).length) for (; n = this[c++];) if (r = ge(n), i = 1 === n.nodeType && " " + me(r) + " ") {
        for (s = 0; o = e[s++];) i.indexOf(" " + o + " ") < 0 && (i += o + " ");

        r !== (a = me(i)) && n.setAttribute("class", a);
      }
      return this;
    },
    removeClass: function (t) {
      var e,
          n,
          i,
          r,
          o,
          s,
          a,
          c = 0;
      if (f(t)) return this.each(function (e) {
        _(this).removeClass(t.call(this, e, ge(this)));
      });
      if (!arguments.length) return this.attr("class", "");
      if ((e = ve(t)).length) for (; n = this[c++];) if (r = ge(n), i = 1 === n.nodeType && " " + me(r) + " ") {
        for (s = 0; o = e[s++];) for (; i.indexOf(" " + o + " ") > -1;) i = i.replace(" " + o + " ", " ");

        r !== (a = me(i)) && n.setAttribute("class", a);
      }
      return this;
    },
    toggleClass: function (t, e) {
      var n = typeof t,
          i = "string" === n || Array.isArray(t);
      return "boolean" == typeof e && i ? e ? this.addClass(t) : this.removeClass(t) : f(t) ? this.each(function (n) {
        _(this).toggleClass(t.call(this, n, ge(this), e), e);
      }) : this.each(function () {
        var e, r, o, s;
        if (i) for (r = 0, o = _(this), s = ve(t); e = s[r++];) o.hasClass(e) ? o.removeClass(e) : o.addClass(e);else void 0 !== t && "boolean" !== n || ((e = ge(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : Y.get(this, "__className__") || ""));
      });
    },
    hasClass: function (t) {
      var e,
          n,
          i = 0;

      for (e = " " + t + " "; n = this[i++];) if (1 === n.nodeType && (" " + me(ge(n)) + " ").indexOf(e) > -1) return !0;

      return !1;
    }
  });
  var ye = /\r/g;
  _.fn.extend({
    val: function (t) {
      var e,
          n,
          i,
          r = this[0];
      return arguments.length ? (i = f(t), this.each(function (n) {
        var r;
        1 === this.nodeType && (null == (r = i ? t.call(this, n, _(this).val()) : t) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = _.map(r, function (t) {
          return null == t ? "" : t + "";
        })), (e = _.valHooks[this.type] || _.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, r, "value") || (this.value = r));
      })) : r ? (e = _.valHooks[r.type] || _.valHooks[r.nodeName.toLowerCase()]) && "get" in e && void 0 !== (n = e.get(r, "value")) ? n : "string" == typeof (n = r.value) ? n.replace(ye, "") : null == n ? "" : n : void 0;
    }
  }), _.extend({
    valHooks: {
      option: {
        get: function (t) {
          var e = _.find.attr(t, "value");

          return null != e ? e : me(_.text(t));
        }
      },
      select: {
        get: function (t) {
          var e,
              n,
              i,
              r = t.options,
              o = t.selectedIndex,
              s = "select-one" === t.type,
              a = s ? null : [],
              c = s ? o + 1 : r.length;

          for (i = o < 0 ? c : s ? o : 0; i < c; i++) if (((n = r[i]).selected || i === o) && !n.disabled && (!n.parentNode.disabled || !T(n.parentNode, "optgroup"))) {
            if (e = _(n).val(), s) return e;
            a.push(e);
          }

          return a;
        },
        set: function (t, e) {
          for (var n, i, r = t.options, o = _.makeArray(e), s = r.length; s--;) ((i = r[s]).selected = _.inArray(_.valHooks.option.get(i), o) > -1) && (n = !0);

          return n || (t.selectedIndex = -1), o;
        }
      }
    }
  }), _.each(["radio", "checkbox"], function () {
    _.valHooks[this] = {
      set: function (t, e) {
        if (Array.isArray(e)) return t.checked = _.inArray(_(t).val(), e) > -1;
      }
    }, p.checkOn || (_.valHooks[this].get = function (t) {
      return null === t.getAttribute("value") ? "on" : t.value;
    });
  }), p.focusin = "onfocusin" in t;

  var xe = /^(?:focusinfocus|focusoutblur)$/,
      _e = function (t) {
    t.stopPropagation();
  };

  _.extend(_.event, {
    trigger: function (e, n, i, r) {
      var o,
          s,
          a,
          c,
          l,
          h,
          d,
          p,
          v = [i || g],
          y = u.call(e, "type") ? e.type : e,
          x = u.call(e, "namespace") ? e.namespace.split(".") : [];

      if (s = p = a = i = i || g, 3 !== i.nodeType && 8 !== i.nodeType && !xe.test(y + _.event.triggered) && (y.indexOf(".") > -1 && (x = y.split("."), y = x.shift(), x.sort()), l = y.indexOf(":") < 0 && "on" + y, (e = e[_.expando] ? e : new _.Event(y, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = x.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + x.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = i), n = null == n ? [e] : _.makeArray(n, [e]), d = _.event.special[y] || {}, r || !d.trigger || !1 !== d.trigger.apply(i, n))) {
        if (!r && !d.noBubble && !m(i)) {
          for (c = d.delegateType || y, xe.test(c + y) || (s = s.parentNode); s; s = s.parentNode) v.push(s), a = s;

          a === (i.ownerDocument || g) && v.push(a.defaultView || a.parentWindow || t);
        }

        for (o = 0; (s = v[o++]) && !e.isPropagationStopped();) p = s, e.type = o > 1 ? c : d.bindType || y, (h = (Y.get(s, "events") || Object.create(null))[e.type] && Y.get(s, "handle")) && h.apply(s, n), (h = l && s[l]) && h.apply && q(s) && (e.result = h.apply(s, n), !1 === e.result && e.preventDefault());

        return e.type = y, r || e.isDefaultPrevented() || d._default && !1 !== d._default.apply(v.pop(), n) || !q(i) || l && f(i[y]) && !m(i) && ((a = i[l]) && (i[l] = null), _.event.triggered = y, e.isPropagationStopped() && p.addEventListener(y, _e), i[y](), e.isPropagationStopped() && p.removeEventListener(y, _e), _.event.triggered = void 0, a && (i[l] = a)), e.result;
      }
    },
    simulate: function (t, e, n) {
      var i = _.extend(new _.Event(), n, {
        type: t,
        isSimulated: !0
      });

      _.event.trigger(i, null, e);
    }
  }), _.fn.extend({
    trigger: function (t, e) {
      return this.each(function () {
        _.event.trigger(t, e, this);
      });
    },
    triggerHandler: function (t, e) {
      var n = this[0];
      if (n) return _.event.trigger(t, e, n, !0);
    }
  }), p.focusin || _.each({
    focus: "focusin",
    blur: "focusout"
  }, function (t, e) {
    var n = function (t) {
      _.event.simulate(e, t.target, _.event.fix(t));
    };

    _.event.special[e] = {
      setup: function () {
        var i = this.ownerDocument || this.document || this,
            r = Y.access(i, e);
        r || i.addEventListener(t, n, !0), Y.access(i, e, (r || 0) + 1);
      },
      teardown: function () {
        var i = this.ownerDocument || this.document || this,
            r = Y.access(i, e) - 1;
        r ? Y.access(i, e, r) : (i.removeEventListener(t, n, !0), Y.remove(i, e));
      }
    };
  });
  var be = t.location,
      we = {
    guid: Date.now()
  },
      Me = /\?/;

  _.parseXML = function (e) {
    var n;
    if (!e || "string" != typeof e) return null;

    try {
      n = new t.DOMParser().parseFromString(e, "text/xml");
    } catch (t) {
      n = void 0;
    }

    return n && !n.getElementsByTagName("parsererror").length || _.error("Invalid XML: " + e), n;
  };

  var Se = /\[\]$/,
      Ee = /\r?\n/g,
      Te = /^(?:submit|button|image|reset|file)$/i,
      Ae = /^(?:input|select|textarea|keygen)/i;

  function Le(t, e, n, i) {
    var r;
    if (Array.isArray(e)) _.each(e, function (e, r) {
      n || Se.test(t) ? i(t, r) : Le(t + "[" + ("object" == typeof r && null != r ? e : "") + "]", r, n, i);
    });else if (n || "object" !== x(e)) i(t, e);else for (r in e) Le(t + "[" + r + "]", e[r], n, i);
  }

  _.param = function (t, e) {
    var n,
        i = [],
        r = function (t, e) {
      var n = f(e) ? e() : e;
      i[i.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n);
    };

    if (null == t) return "";
    if (Array.isArray(t) || t.jquery && !_.isPlainObject(t)) _.each(t, function () {
      r(this.name, this.value);
    });else for (n in t) Le(n, t[n], e, r);
    return i.join("&");
  }, _.fn.extend({
    serialize: function () {
      return _.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var t = _.prop(this, "elements");

        return t ? _.makeArray(t) : this;
      }).filter(function () {
        var t = this.type;
        return this.name && !_(this).is(":disabled") && Ae.test(this.nodeName) && !Te.test(t) && (this.checked || !dt.test(t));
      }).map(function (t, e) {
        var n = _(this).val();

        return null == n ? null : Array.isArray(n) ? _.map(n, function (t) {
          return {
            name: e.name,
            value: t.replace(Ee, "\r\n")
          };
        }) : {
          name: e.name,
          value: n.replace(Ee, "\r\n")
        };
      }).get();
    }
  });
  var Ce = /%20/g,
      Re = /#.*$/,
      Pe = /([?&])_=[^&]*/,
      Oe = /^(.*?):[ \t]*([^\r\n]*)$/gm,
      Ne = /^(?:GET|HEAD)$/,
      De = /^\/\//,
      Ie = {},
      ze = {},
      Be = "*/".concat("*"),
      ke = g.createElement("a");

  function He(t) {
    return function (e, n) {
      "string" != typeof e && (n = e, e = "*");
      var i,
          r = 0,
          o = e.toLowerCase().match(D) || [];
      if (f(n)) for (; i = o[r++];) "+" === i[0] ? (i = i.slice(1) || "*", (t[i] = t[i] || []).unshift(n)) : (t[i] = t[i] || []).push(n);
    };
  }

  function Fe(t, e, n, i) {
    var r = {},
        o = t === ze;

    function s(a) {
      var c;
      return r[a] = !0, _.each(t[a] || [], function (t, a) {
        var l = a(e, n, i);
        return "string" != typeof l || o || r[l] ? o ? !(c = l) : void 0 : (e.dataTypes.unshift(l), s(l), !1);
      }), c;
    }

    return s(e.dataTypes[0]) || !r["*"] && s("*");
  }

  function Ue(t, e) {
    var n,
        i,
        r = _.ajaxSettings.flatOptions || {};

    for (n in e) void 0 !== e[n] && ((r[n] ? t : i || (i = {}))[n] = e[n]);

    return i && _.extend(!0, t, i), t;
  }

  ke.href = be.href, _.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: be.href,
      type: "GET",
      isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(be.protocol),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": Be,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": JSON.parse,
        "text xml": _.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function (t, e) {
      return e ? Ue(Ue(t, _.ajaxSettings), e) : Ue(_.ajaxSettings, t);
    },
    ajaxPrefilter: He(Ie),
    ajaxTransport: He(ze),
    ajax: function (e, n) {
      "object" == typeof e && (n = e, e = void 0);

      var i,
          r,
          o,
          s,
          a,
          c,
          l,
          u,
          h,
          d,
          p = _.ajaxSetup({}, n = n || {}),
          f = p.context || p,
          m = p.context && (f.nodeType || f.jquery) ? _(f) : _.event,
          v = _.Deferred(),
          y = _.Callbacks("once memory"),
          x = p.statusCode || {},
          b = {},
          w = {},
          M = "canceled",
          S = {
        readyState: 0,
        getResponseHeader: function (t) {
          var e;

          if (l) {
            if (!s) for (s = {}; e = Oe.exec(o);) s[e[1].toLowerCase() + " "] = (s[e[1].toLowerCase() + " "] || []).concat(e[2]);
            e = s[t.toLowerCase() + " "];
          }

          return null == e ? null : e.join(", ");
        },
        getAllResponseHeaders: function () {
          return l ? o : null;
        },
        setRequestHeader: function (t, e) {
          return null == l && (t = w[t.toLowerCase()] = w[t.toLowerCase()] || t, b[t] = e), this;
        },
        overrideMimeType: function (t) {
          return null == l && (p.mimeType = t), this;
        },
        statusCode: function (t) {
          var e;
          if (t) if (l) S.always(t[S.status]);else for (e in t) x[e] = [x[e], t[e]];
          return this;
        },
        abort: function (t) {
          var e = t || M;
          return i && i.abort(e), E(0, e), this;
        }
      };

      if (v.promise(S), p.url = ((e || p.url || be.href) + "").replace(De, be.protocol + "//"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(D) || [""], null == p.crossDomain) {
        c = g.createElement("a");

        try {
          c.href = p.url, c.href = c.href, p.crossDomain = ke.protocol + "//" + ke.host != c.protocol + "//" + c.host;
        } catch (t) {
          p.crossDomain = !0;
        }
      }

      if (p.data && p.processData && "string" != typeof p.data && (p.data = _.param(p.data, p.traditional)), Fe(Ie, p, n, S), l) return S;

      for (h in (u = _.event && p.global) && 0 == _.active++ && _.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Ne.test(p.type), r = p.url.replace(Re, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Ce, "+")) : (d = p.url.slice(r.length), p.data && (p.processData || "string" == typeof p.data) && (r += (Me.test(r) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (r = r.replace(Pe, "$1"), d = (Me.test(r) ? "&" : "?") + "_=" + we.guid++ + d), p.url = r + d), p.ifModified && (_.lastModified[r] && S.setRequestHeader("If-Modified-Since", _.lastModified[r]), _.etag[r] && S.setRequestHeader("If-None-Match", _.etag[r])), (p.data && p.hasContent && !1 !== p.contentType || n.contentType) && S.setRequestHeader("Content-Type", p.contentType), S.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Be + "; q=0.01" : "") : p.accepts["*"]), p.headers) S.setRequestHeader(h, p.headers[h]);

      if (p.beforeSend && (!1 === p.beforeSend.call(f, S, p) || l)) return S.abort();

      if (M = "abort", y.add(p.complete), S.done(p.success), S.fail(p.error), i = Fe(ze, p, n, S)) {
        if (S.readyState = 1, u && m.trigger("ajaxSend", [S, p]), l) return S;
        p.async && p.timeout > 0 && (a = t.setTimeout(function () {
          S.abort("timeout");
        }, p.timeout));

        try {
          l = !1, i.send(b, E);
        } catch (t) {
          if (l) throw t;
          E(-1, t);
        }
      } else E(-1, "No Transport");

      function E(e, n, s, c) {
        var h,
            d,
            g,
            b,
            w,
            M = n;
        l || (l = !0, a && t.clearTimeout(a), i = void 0, o = c || "", S.readyState = e > 0 ? 4 : 0, h = e >= 200 && e < 300 || 304 === e, s && (b = function (t, e, n) {
          for (var i, r, o, s, a = t.contents, c = t.dataTypes; "*" === c[0];) c.shift(), void 0 === i && (i = t.mimeType || e.getResponseHeader("Content-Type"));

          if (i) for (r in a) if (a[r] && a[r].test(i)) {
            c.unshift(r);
            break;
          }
          if (c[0] in n) o = c[0];else {
            for (r in n) {
              if (!c[0] || t.converters[r + " " + c[0]]) {
                o = r;
                break;
              }

              s || (s = r);
            }

            o = o || s;
          }
          if (o) return o !== c[0] && c.unshift(o), n[o];
        }(p, S, s)), !h && _.inArray("script", p.dataTypes) > -1 && (p.converters["text script"] = function () {}), b = function (t, e, n, i) {
          var r,
              o,
              s,
              a,
              c,
              l = {},
              u = t.dataTypes.slice();
          if (u[1]) for (s in t.converters) l[s.toLowerCase()] = t.converters[s];

          for (o = u.shift(); o;) if (t.responseFields[o] && (n[t.responseFields[o]] = e), !c && i && t.dataFilter && (e = t.dataFilter(e, t.dataType)), c = o, o = u.shift()) if ("*" === o) o = c;else if ("*" !== c && c !== o) {
            if (!(s = l[c + " " + o] || l["* " + o])) for (r in l) if ((a = r.split(" "))[1] === o && (s = l[c + " " + a[0]] || l["* " + a[0]])) {
              !0 === s ? s = l[r] : !0 !== l[r] && (o = a[0], u.unshift(a[1]));
              break;
            }
            if (!0 !== s) if (s && t.throws) e = s(e);else try {
              e = s(e);
            } catch (t) {
              return {
                state: "parsererror",
                error: s ? t : "No conversion from " + c + " to " + o
              };
            }
          }

          return {
            state: "success",
            data: e
          };
        }(p, b, S, h), h ? (p.ifModified && ((w = S.getResponseHeader("Last-Modified")) && (_.lastModified[r] = w), (w = S.getResponseHeader("etag")) && (_.etag[r] = w)), 204 === e || "HEAD" === p.type ? M = "nocontent" : 304 === e ? M = "notmodified" : (M = b.state, d = b.data, h = !(g = b.error))) : (g = M, !e && M || (M = "error", e < 0 && (e = 0))), S.status = e, S.statusText = (n || M) + "", h ? v.resolveWith(f, [d, M, S]) : v.rejectWith(f, [S, M, g]), S.statusCode(x), x = void 0, u && m.trigger(h ? "ajaxSuccess" : "ajaxError", [S, p, h ? d : g]), y.fireWith(f, [S, M]), u && (m.trigger("ajaxComplete", [S, p]), --_.active || _.event.trigger("ajaxStop")));
      }

      return S;
    },
    getJSON: function (t, e, n) {
      return _.get(t, e, n, "json");
    },
    getScript: function (t, e) {
      return _.get(t, void 0, e, "script");
    }
  }), _.each(["get", "post"], function (t, e) {
    _[e] = function (t, n, i, r) {
      return f(n) && (r = r || i, i = n, n = void 0), _.ajax(_.extend({
        url: t,
        type: e,
        dataType: r,
        data: n,
        success: i
      }, _.isPlainObject(t) && t));
    };
  }), _.ajaxPrefilter(function (t) {
    var e;

    for (e in t.headers) "content-type" === e.toLowerCase() && (t.contentType = t.headers[e] || "");
  }), _._evalUrl = function (t, e, n) {
    return _.ajax({
      url: t,
      type: "GET",
      dataType: "script",
      cache: !0,
      async: !1,
      global: !1,
      converters: {
        "text script": function () {}
      },
      dataFilter: function (t) {
        _.globalEval(t, e, n);
      }
    });
  }, _.fn.extend({
    wrapAll: function (t) {
      var e;
      return this[0] && (f(t) && (t = t.call(this[0])), e = _(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function () {
        for (var t = this; t.firstElementChild;) t = t.firstElementChild;

        return t;
      }).append(this)), this;
    },
    wrapInner: function (t) {
      return f(t) ? this.each(function (e) {
        _(this).wrapInner(t.call(this, e));
      }) : this.each(function () {
        var e = _(this),
            n = e.contents();

        n.length ? n.wrapAll(t) : e.append(t);
      });
    },
    wrap: function (t) {
      var e = f(t);
      return this.each(function (n) {
        _(this).wrapAll(e ? t.call(this, n) : t);
      });
    },
    unwrap: function (t) {
      return this.parent(t).not("body").each(function () {
        _(this).replaceWith(this.childNodes);
      }), this;
    }
  }), _.expr.pseudos.hidden = function (t) {
    return !_.expr.pseudos.visible(t);
  }, _.expr.pseudos.visible = function (t) {
    return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length);
  }, _.ajaxSettings.xhr = function () {
    try {
      return new t.XMLHttpRequest();
    } catch (t) {}
  };

  var Ge = {
    0: 200,
    1223: 204
  },
      je = _.ajaxSettings.xhr();

  p.cors = !!je && "withCredentials" in je, p.ajax = je = !!je, _.ajaxTransport(function (e) {
    var n, i;
    if (p.cors || je && !e.crossDomain) return {
      send: function (r, o) {
        var s,
            a = e.xhr();
        if (a.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (s in e.xhrFields) a[s] = e.xhrFields[s];

        for (s in e.mimeType && a.overrideMimeType && a.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest"), r) a.setRequestHeader(s, r[s]);

        n = function (t) {
          return function () {
            n && (n = i = a.onload = a.onerror = a.onabort = a.ontimeout = a.onreadystatechange = null, "abort" === t ? a.abort() : "error" === t ? "number" != typeof a.status ? o(0, "error") : o(a.status, a.statusText) : o(Ge[a.status] || a.status, a.statusText, "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? {
              binary: a.response
            } : {
              text: a.responseText
            }, a.getAllResponseHeaders()));
          };
        }, a.onload = n(), i = a.onerror = a.ontimeout = n("error"), void 0 !== a.onabort ? a.onabort = i : a.onreadystatechange = function () {
          4 === a.readyState && t.setTimeout(function () {
            n && i();
          });
        }, n = n("abort");

        try {
          a.send(e.hasContent && e.data || null);
        } catch (t) {
          if (n) throw t;
        }
      },
      abort: function () {
        n && n();
      }
    };
  }), _.ajaxPrefilter(function (t) {
    t.crossDomain && (t.contents.script = !1);
  }), _.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function (t) {
        return _.globalEval(t), t;
      }
    }
  }), _.ajaxPrefilter("script", function (t) {
    void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET");
  }), _.ajaxTransport("script", function (t) {
    var e, n;
    if (t.crossDomain || t.scriptAttrs) return {
      send: function (i, r) {
        e = _("<script>").attr(t.scriptAttrs || {}).prop({
          charset: t.scriptCharset,
          src: t.url
        }).on("load error", n = function (t) {
          e.remove(), n = null, t && r("error" === t.type ? 404 : 200, t.type);
        }), g.head.appendChild(e[0]);
      },
      abort: function () {
        n && n();
      }
    };
  });
  var Ve,
      We = [],
      qe = /(=)\?(?=&|$)|\?\?/;
  _.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var t = We.pop() || _.expando + "_" + we.guid++;
      return this[t] = !0, t;
    }
  }), _.ajaxPrefilter("json jsonp", function (e, n, i) {
    var r,
        o,
        s,
        a = !1 !== e.jsonp && (qe.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && qe.test(e.data) && "data");
    if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = f(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(qe, "$1" + r) : !1 !== e.jsonp && (e.url += (Me.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
      return s || _.error(r + " was not called"), s[0];
    }, e.dataTypes[0] = "json", o = t[r], t[r] = function () {
      s = arguments;
    }, i.always(function () {
      void 0 === o ? _(t).removeProp(r) : t[r] = o, e[r] && (e.jsonpCallback = n.jsonpCallback, We.push(r)), s && f(o) && o(s[0]), s = o = void 0;
    }), "script";
  }), p.createHTMLDocument = ((Ve = g.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Ve.childNodes.length), _.parseHTML = function (t, e, n) {
    return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e, e = !1), e || (p.createHTMLDocument ? ((i = (e = g.implementation.createHTMLDocument("")).createElement("base")).href = g.location.href, e.head.appendChild(i)) : e = g), o = !n && [], (r = A.exec(t)) ? [e.createElement(r[1])] : (r = xt([t], e, o), o && o.length && _(o).remove(), _.merge([], r.childNodes)));
    var i, r, o;
  }, _.fn.load = function (t, e, n) {
    var i,
        r,
        o,
        s = this,
        a = t.indexOf(" ");
    return a > -1 && (i = me(t.slice(a)), t = t.slice(0, a)), f(e) ? (n = e, e = void 0) : e && "object" == typeof e && (r = "POST"), s.length > 0 && _.ajax({
      url: t,
      type: r || "GET",
      dataType: "html",
      data: e
    }).done(function (t) {
      o = arguments, s.html(i ? _("<div>").append(_.parseHTML(t)).find(i) : t);
    }).always(n && function (t, e) {
      s.each(function () {
        n.apply(this, o || [t.responseText, e, t]);
      });
    }), this;
  }, _.expr.pseudos.animated = function (t) {
    return _.grep(_.timers, function (e) {
      return t === e.elem;
    }).length;
  }, _.offset = {
    setOffset: function (t, e, n) {
      var i,
          r,
          o,
          s,
          a,
          c,
          l = _.css(t, "position"),
          u = _(t),
          h = {};

      "static" === l && (t.style.position = "relative"), a = u.offset(), o = _.css(t, "top"), c = _.css(t, "left"), ("absolute" === l || "fixed" === l) && (o + c).indexOf("auto") > -1 ? (s = (i = u.position()).top, r = i.left) : (s = parseFloat(o) || 0, r = parseFloat(c) || 0), f(e) && (e = e.call(t, n, _.extend({}, a))), null != e.top && (h.top = e.top - a.top + s), null != e.left && (h.left = e.left - a.left + r), "using" in e ? e.using.call(t, h) : ("number" == typeof h.top && (h.top += "px"), "number" == typeof h.left && (h.left += "px"), u.css(h));
    }
  }, _.fn.extend({
    offset: function (t) {
      if (arguments.length) return void 0 === t ? this : this.each(function (e) {
        _.offset.setOffset(this, t, e);
      });
      var e,
          n,
          i = this[0];
      return i ? i.getClientRects().length ? (e = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {
        top: e.top + n.pageYOffset,
        left: e.left + n.pageXOffset
      }) : {
        top: 0,
        left: 0
      } : void 0;
    },
    position: function () {
      if (this[0]) {
        var t,
            e,
            n,
            i = this[0],
            r = {
          top: 0,
          left: 0
        };
        if ("fixed" === _.css(i, "position")) e = i.getBoundingClientRect();else {
          for (e = this.offset(), n = i.ownerDocument, t = i.offsetParent || n.documentElement; t && (t === n.body || t === n.documentElement) && "static" === _.css(t, "position");) t = t.parentNode;

          t && t !== i && 1 === t.nodeType && ((r = _(t).offset()).top += _.css(t, "borderTopWidth", !0), r.left += _.css(t, "borderLeftWidth", !0));
        }
        return {
          top: e.top - r.top - _.css(i, "marginTop", !0),
          left: e.left - r.left - _.css(i, "marginLeft", !0)
        };
      }
    },
    offsetParent: function () {
      return this.map(function () {
        for (var t = this.offsetParent; t && "static" === _.css(t, "position");) t = t.offsetParent;

        return t || nt;
      });
    }
  }), _.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (t, e) {
    var n = "pageYOffset" === e;

    _.fn[t] = function (i) {
      return U(this, function (t, i, r) {
        var o;
        if (m(t) ? o = t : 9 === t.nodeType && (o = t.defaultView), void 0 === r) return o ? o[e] : t[i];
        o ? o.scrollTo(n ? o.pageXOffset : r, n ? r : o.pageYOffset) : t[i] = r;
      }, t, i, arguments.length);
    };
  }), _.each(["top", "left"], function (t, e) {
    _.cssHooks[e] = jt(p.pixelPosition, function (t, n) {
      if (n) return n = Gt(t, e), kt.test(n) ? _(t).position()[e] + "px" : n;
    });
  }), _.each({
    Height: "height",
    Width: "width"
  }, function (t, e) {
    _.each({
      padding: "inner" + t,
      content: e,
      "": "outer" + t
    }, function (n, i) {
      _.fn[i] = function (r, o) {
        var s = arguments.length && (n || "boolean" != typeof r),
            a = n || (!0 === r || !0 === o ? "margin" : "border");
        return U(this, function (e, n, r) {
          var o;
          return m(e) ? 0 === i.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body["scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o["client" + t])) : void 0 === r ? _.css(e, n, a) : _.style(e, n, r, a);
        }, e, s ? r : void 0, s);
      };
    });
  }), _.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (t, e) {
    _.fn[e] = function (t) {
      return this.on(e, t);
    };
  }), _.fn.extend({
    bind: function (t, e, n) {
      return this.on(t, null, e, n);
    },
    unbind: function (t, e) {
      return this.off(t, null, e);
    },
    delegate: function (t, e, n, i) {
      return this.on(e, t, n, i);
    },
    undelegate: function (t, e, n) {
      return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n);
    },
    hover: function (t, e) {
      return this.mouseenter(t).mouseleave(e || t);
    }
  }), _.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (t, e) {
    _.fn[e] = function (t, n) {
      return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e);
    };
  });
  var Xe = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  _.proxy = function (t, e) {
    var n, i, o;
    if ("string" == typeof e && (n = t[e], e = t, t = n), f(t)) return i = r.call(arguments, 2), (o = function () {
      return t.apply(e || this, i.concat(r.call(arguments)));
    }).guid = t.guid = t.guid || _.guid++, o;
  }, _.holdReady = function (t) {
    t ? _.readyWait++ : _.ready(!0);
  }, _.isArray = Array.isArray, _.parseJSON = JSON.parse, _.nodeName = T, _.isFunction = f, _.isWindow = m, _.camelCase = W, _.type = x, _.now = Date.now, _.isNumeric = function (t) {
    var e = _.type(t);

    return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t));
  }, _.trim = function (t) {
    return null == t ? "" : (t + "").replace(Xe, "");
  };
  var Ye = t.jQuery,
      Ze = t.$;
  return _.noConflict = function (e) {
    return t.$ === _ && (t.$ = Ze), e && t.jQuery === _ && (t.jQuery = Ye), _;
  }, void 0 === e && (t.jQuery = t.$ = _), _;
}, "object" == typeof Ku ? Ku = Ju.document ? Qu(Ju, !0) : function (t) {
  if (!t.document) throw new Error("jQuery requires a window with a document");
  return Qu(t);
} : Qu(Ju);
var $u,
    th = ($u = Ku) && $u.__esModule ? $u.default : $u;
window.$ = window.jQuery = th;
var eh = new Gl();
document.body.appendChild(eh.dom), new Date().getTime();
var nh = new function () {
  this.Speed = .1, this.Scale = 3, this.dotSize = 1, this.Draw_isolines = !0, this.Draw_cell_center = !0, this.Draw_grid = !1, this.Intensity_control_x = .19, this.Intensity_control_y = .15, this.Aura_color = [1, 1, 1], this.Aura_intensity = -1, this.Red_x = .7, this.Red_y = .7, this.Green_x = .09, this.Green_y = .8, this.Blue_x = .07, this.Blue_y = .8, this.Minimum_distance = 2;
}(),
    ih = new Bc(),
    rh = new i(0, 0),
    oh = new i(0, 0),
    sh = new i(0, 0),
    ah = {
  ms_Renderer: null,
  ms_Camera: null,
  ms_Scene: null,
  ms_Controls: null,
  raycaster: null,
  mouse: null,
  uniforms: null,
  Initialize: function () {
    this.ms_Renderer = new tr({
      antialias: !0,
      depth: !0,
      logarithmicDepthBuffer: !0,
      powerPreference: "high-performance"
    }), this.ms_Renderer.setPixelRatio(window.devicePixelRatio), document.body.appendChild(this.ms_Renderer.domElement), this.ms_Scene = new G(), this.ms_Scene.name = "Viewer", this.ms_Camera = new He(55, window.innerWidth / window.innerHeight, .5, 3e5), this.ms_Camera.position.set(4, 4, 4), this.ms_Camera.lookAt(0, 0, 0), this.ms_Scene.add(this.ms_Camera), this.ms_Controls = new Yu(this.ms_Camera, this.ms_Renderer.domElement), this.ms_Controls.userPan = !1, this.ms_Controls.userPanSpeed = 0, this.ms_Controls.minDistance = 0, this.ms_Controls.maxDistance = 2e3, this.ms_Controls.minPolarAngle = 0, this.ms_Controls.maxPolarAngle = .495 * Math.PI, new Ne(.75, .75, .75);
    var t = new Ze(4, 4, 1, 1),
        e = t.faceVertexUvs[0];
    e[0][0].set(0, 4), e[0][1].set(0, 0), e[0][2].set(4, 4), e[1][0].set(0, 0), e[1][1].set(4, 0), e[1][2].set(4, 4), t.uvsNeedUpdate = !0, this.uniforms = {
      scale: {
        value: nh.Scale
      },
      u_mouse: {
        value: new i(sh.x, sh.z)
      },
      dotSize: {
        value: nh.dotSize
      },
      u_time: {
        value: 0
      },
      showIso: {
        value: nh.Draw_isolines
      },
      showCenter: {
        value: nh.Draw_cell_center
      },
      showGrid: {
        value: nh.Draw_grid
      },
      minimumDist: {
        value: nh.Minimum_distance
      },
      auraColor: {
        value: new m(nh.Aura_color[0] / 255, nh.Aura_color[1] / 255, nh.Aura_color[2] / 255)
      },
      auraIntensity: {
        value: nh.intensity
      },
      rColor: {
        value: new i(nh.Red_x, nh.Red_y)
      },
      gColor: {
        value: new i(nh.Green_x, nh.Green_y)
      },
      bColor: {
        value: new i(nh.Blue_x, nh.Blue_y)
      },
      IntensityControl: {
        value: new i(nh.Intensity_control_x, nh.Intensity_control_y)
      }
    };
    var n = new Ee(t, new Be({
      vertexShader: " \n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            #else\n            precision mediump float;\n            #endif\n            precision mediump int;\n            \n            varying vec2 vUv;\n            varying vec3 vnormal;\n            varying vec3 vposition;\n\t\t\tvoid main()\n\t\t\t{\n                \n\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n                gl_Position = projectionMatrix * mvPosition;\n                vUv = uv;\n                vnormal = normal;\n                vposition = position;\n\t\t\t}\n                    ",
      side: 2,
      uniforms: this.uniforms,
      fragmentShader: "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float scale;\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform float dotSize;\n\nuniform bool showIso;\nuniform bool showCenter;\nuniform bool showGrid;\n\nuniform float minimumDist;\n\nuniform vec3 auraColor;\nuniform float auraIntensity;\n\nuniform vec2 rColor;\nuniform vec2 gColor;\nuniform vec2 bColor;\n\nuniform vec2 IntensityControl;\n\nvarying vec2 vUv;\nvarying vec3 vnormal;\nvarying vec3 vposition;\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main() {\n    vec2 st = vUv;\n    vec2 st2 = vUv;\n    \n    vec3 pos = vposition;\n    vec3 normal = vnormal;\n    \n    vec3 color = vec3(.0);\n    st *= scale ;\n    \n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = minimumDist;  // minimum distance\n    vec2 m_point;        // minimum point\n\tvec2 point2 =u_mouse;\n    for (int j=-1; j<=1; j++ ) {\n        for (int i=-1; i<=1; i++ ) {\n            vec2 neighbor = vec2(float(i),float(j));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.5*sin(u_time + 6.2831*point);\n            vec2 diff = neighbor + point - f_st;\n            float dist = length(diff);\n\n            if( dist < m_dist ) {\n                m_dist = dist;\n                m_point = point;\n            }\n        }\n    }\t\n    float dist = distance(st2, point2);\n    if ( dist < m_dist ) {\n        // Keep the closer distance\n        m_dist = dist;\n    \n        // Kepp the position of the closer point\n        m_point = point2;\n    }\n\tvec3 aura = auraColor*m_dist*auraIntensity;\n    color+=aura;\n    color.r += dot(m_point,rColor);\n    color.g += dot(m_point,gColor);\n    color.b += dot(m_point,bColor);\n    color += dot(m_point,IntensityControl);\n\t\n    \n\n    // Show isolines\n    if(showIso){\n        color -= abs(sin(40.0*m_dist))*0.07;\n    }\n    \n\n    // Draw cell center\n    if(showCenter)\n    color += 1.-step(.05, m_dist);\n\n    // Draw grid\n    if(showGrid)\n    color.r += step(.98, f_st.x) + step(.98, f_st.y);\n    \n    gl_FragColor = vec4(color,1.0);\n}\n            "
    }));
    n.position.x = 0, n.position.y = 0, this.ms_Scene.add(n);
    var r = new Xu(),
        o = r.addFolder("Red");
    o.add(nh, "Red_x", 0, 1), o.add(nh, "Red_y", 0, 1);
    var s = r.addFolder("Green");
    s.add(nh, "Green_x", 0, 1), s.add(nh, "Green_y", 0, 1);
    var a = r.addFolder("Blue");
    a.add(nh, "Blue_x", 0, 1), a.add(nh, "Blue_y", 0, 1);
    var c = r.addFolder("Intensity controller");
    c.add(nh, "Intensity_control_x", -1, 1), c.add(nh, "Intensity_control_y", -1, 1), r.addColor(nh, "Aura_color"), r.add(nh, "Aura_intensity", -2, 2), r.add(nh, "Speed", 0, .25), r.add(nh, "Scale", .5, 20), r.add(nh, "Minimum_distance", .1, 2), r.add(nh, "Draw_cell_center"), r.add(nh, "Draw_isolines"), r.add(nh, "Draw_grid");
  },
  Display: function () {
    this.ms_Renderer.render(this.ms_Scene, this.ms_Camera);
  },
  Update: function () {
    new Date().getTime();
    this.uniforms.scale.value = nh.Scale, this.uniforms.u_time.value += nh.Speed, this.uniforms.u_mouse.value = new i(oh.x, oh.y), this.uniforms.dotSize.value = nh.dotSize, this.uniforms.showIso.value = nh.Draw_isolines, this.uniforms.showCenter.value = nh.Draw_cell_center, this.uniforms.showGrid.value = nh.Draw_grid, this.uniforms.minimumDist.value = nh.Minimum_distance, this.uniforms.auraColor.value = new m(nh.Aura_color[0] / 255, nh.Aura_color[1] / 255, nh.Aura_color[2] / 255), this.uniforms.auraIntensity.value = nh.Aura_intensity, this.uniforms.rColor.value = new i(nh.Red_x, nh.Red_y), this.uniforms.gColor.value = new i(nh.Green_x, nh.Green_y), this.uniforms.bColor.value = new i(nh.Blue_x, nh.Blue_y), this.uniforms.IntensityControl.value = new i(nh.Intensity_control_x, nh.Intensity_control_y), this.Display();
  },
  Resize: function (t, e) {
    this.ms_Camera.aspect = t / e, this.ms_Camera.updateProjectionMatrix(), this.ms_Renderer.setSize(t, e), this.Display();
  }
};
ah.Initialize(), window.addEventListener("resize", function () {
  ah.Resize(window.innerWidth, window.innerHeight);
}), window.addEventListener("mousemove", function (t) {
  rh.x = t.clientX / window.innerWidth * 2 - 1, rh.y = -t.clientY / window.innerHeight * 2 + 1;
}, !1), ah.Resize(window.innerWidth, window.innerHeight);

var ch = function () {
  ah.Update(), ih.setFromCamera(rh, ah.ms_Camera);
  var t = ih.intersectObjects(ah.ms_Scene.children);
  null != t && null != t && 0 != t.length && (oh = t[0].uv), eh.update(), requestAnimationFrame(ch);
};

ch();
},{}]},{},["8c5b5622742e8e98989ec4c3a2f890b3","73e588dc321745e8ecbe86c06ea14bd1"], null)

//# sourceMappingURL=test.af111be5.e4480a42.0e8c7faf.js.map
